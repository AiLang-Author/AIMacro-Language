# AIMacro Status Doc Update
# AIMacro Language Status & Development Roadmap

**Version:** 1.0.0-alpha  
**Last Updated:**12-17-2025 
**Status:** Core functionality complete, comprehensive test suite passing

---

## ‚úÖ FULLY WORKING FEATURES

### Variables & Assignment
```python
x = 5
name = "Claude"
x += 1          # Augmented: +=, -=, *=, /=
```

### Arithmetic Operators
```python
a + b           # Addition
a - b           # Subtraction
a * b           # Multiplication
a / b           # Division (integer)
a % b           # Modulo
a ** b          # Power/Exponent
-x              # Unary negation
```

### Comparison Operators
```python
a == b          # Equal (works for numbers AND strings)
a != b          # Not equal (works for numbers AND strings)
a < b           # Less than
a <= b          # Less than or equal
a > b           # Greater than
a >= b          # Greater than or equal
```

### Boolean Operators
```python
a and b         # Logical AND
a or b          # Logical OR
not a           # Logical NOT (correct precedence!)
```

### Control Flow
```python
# If/elif/else
if condition:
    ...
elif other:
    ...
else:
    ...
end

# While loop
while condition:
    ...
end

# For loop with range
for i in range(n):          # 0 to n-1
for i in range(start, end): # start to end-1
for i in range(start, end, step):

# Loop control
break
continue
```

### Functions
```python
def function_name(param1, param2):
    # function body
    return value
end

# Supports:
# - Multiple parameters
# - Return values
# - Recursion
# - Nested function calls
```

### Strings
```python
s = "Hello"
s1 + s2                 # Concatenation
s1 + " " + s2           # Chained concatenation (auto-flattened)
"*" * 10                # String repeat
len(s)                  # String length
s1 == s2                # String equality (content comparison)
s1 != s2                # String inequality
str(number)             # Number to string conversion
```

### Lists
```python
nums = [1, 2, 3, 4, 5]  # List literal
nums = []               # Empty list
nums[0]                 # Index access
nums[2] = 999           # Index assignment
nums.append(x)          # Append element
len(nums)               # List length
```

### Built-in Functions
```python
print(x)                # Print (handles strings and numbers)
print(a, b, c)          # Multiple arguments
len(x)                  # Length (strings and lists)
str(x)                  # Convert to string
range(n)                # Range iterator
range(start, end)
range(start, end, step)
```

---

## ‚ö†Ô∏è KNOWN ISSUES

### Exit Segfault
- Program crashes AFTER completing all logic
- Happens during cleanup/exit
- Does NOT affect program correctness
- **Priority:** Medium (annoying but not blocking)

### `not x > 100` Edge Case
- Without parentheses, still parses incorrectly in isolated test
- Works correctly in full test suite (might be test-specific)
- **Workaround:** Use `not (x > 100)` for clarity
- **Priority:** Low (workaround available)

---

## üî¥ HIGH PRIORITY - Common Use Cases

### 1. `input()` Function
```python
name = input("Enter name: ")
age = input()
```
- **Status:** Mapped but untested
- **Effort:** Low - just needs testing/verification
- **Use Case:** Interactive programs

### 2. `int()` Conversion
```python
num = int("42")
num = int(user_input)
```
- **Status:** Mapped to AIMacro.Int
- **Effort:** Low - needs testing
- **Use Case:** Parse user input as numbers

### 3. String Indexing
```python
first_char = name[0]
last_char = name[-1]    # Negative indexing (stretch)
```
- **Status:** Not implemented
- **Effort:** Medium - need to detect string vs list indexing
- **Use Case:** Character-level string processing

### 4. `in` Operator for Strings
```python
if "x" in text:
if substring in string:
```
- **Status:** Not implemented
- **Effort:** Medium - new operator in parser + codegen
- **Use Case:** String searching, validation

### 5. String Methods (Core Set)
```python
s.find("sub")           # Find substring position
s.startswith("pre")     # Check prefix
s.endswith("suf")       # Check suffix
```
- **Status:** Mapped but untested
- **Effort:** Low - just testing
- **Use Case:** String validation, parsing

---

## üü° MEDIUM PRIORITY - Useful Features

### 6. `elif` Chain Bug Check
- Verify complex elif chains work correctly
- May already work, needs comprehensive test

### 7. Negative List Indexing
```python
nums[-1]                # Last element
nums[-2]                # Second to last
```
- **Status:** Not implemented
- **Effort:** Medium - modify index access codegen
- **Use Case:** Convenient list access

### 8. List Slicing (Basic)
```python
nums[1:3]               # Sublist
nums[:3]                # First 3
nums[2:]                # From index 2 to end
```
- **Status:** Not implemented
- **Effort:** High - new AST node, parser changes
- **Use Case:** List manipulation

### 9. `in` Operator for Lists
```python
if x in my_list:
```
- **Status:** Not implemented
- **Effort:** Medium - similar to string `in`
- **Use Case:** Membership testing

### 10. `None` Value
```python
x = None
if x is None:
if x is not None:
```
- **Status:** Partial (None token exists)
- **Effort:** Medium - need `is` operator
- **Use Case:** Optional values, null checks

### 11. Multiple Assignment
```python
a, b = 1, 2
a, b = b, a             # Swap
```
- **Status:** Not implemented
- **Effort:** High - tuple unpacking
- **Use Case:** Convenient assignment, swaps

---

## üü† LOW PRIORITY - Nice to Have

### 12. List Comprehensions
```python
squares = [x*x for x in range(10)]
evens = [x for x in nums if x % 2 == 0]
```
- **Status:** Not implemented
- **Effort:** Very High - complex parsing
- **Use Case:** Functional-style list creation

### 13. Dictionary Operations
```python
d = {"key": "value"}
d["key"]
d["new"] = "value"
d.keys()
d.values()
if "key" in d:
```
- **Status:** Basic creation works
- **Effort:** High - many operations
- **Use Case:** Key-value storage

### 14. F-strings
```python
f"Hello {name}, you are {age} years old"
```
- **Status:** Not implemented
- **Effort:** Very High - parser interpolation
- **Use Case:** String formatting (workaround: concat + str())

### 15. Default Function Arguments
```python
def greet(name, greeting="Hello"):
```
- **Status:** Not implemented
- **Effort:** Medium - parser + codegen
- **Use Case:** Flexible function signatures

### 16. String `join()`
```python
", ".join(["a", "b", "c"])
```
- **Status:** Mapped but untested
- **Effort:** Low if mapped correctly
- **Use Case:** Building strings from lists

### 17. `abs()`, `min()`, `max()` with Multiple Args
```python
abs(-5)
min(a, b, c)
max(1, 2, 3, 4, 5)
```
- **Status:** abs/min/max exist for 2 args
- **Effort:** Medium - variadic support
- **Use Case:** Math operations

---

## üîµ FUTURE - Advanced Features

### Classes & Objects
```python
class Person:
    def __init__(self, name):
        self.name = name
end
```
- **Effort:** Very High
- **Dependency:** Object system in AILang

### Exception Handling
```python
try:
    risky_operation()
except:
    handle_error()
end
```
- **Effort:** Very High
- **Dependency:** Exception system in AILang

### Imports
```python
import math
from utils import helper
```
- **Effort:** Very High
- **Dependency:** Module system

### Lambda Functions
```python
double = lambda x: x * 2
```
- **Effort:** High
- **Use Case:** Functional programming

### `*args` / `**kwargs`
```python
def func(*args, **kwargs):
```
- **Effort:** Very High
- **Use Case:** Flexible function signatures

---

## Development Order Recommendation

### Phase 1: Input/Output Complete
1. ‚úÖ `print()` - DONE
2. üî¥ `input()` - Test/verify
3. üî¥ `int()` - Test/verify

### Phase 2: String Power
4. üî¥ String indexing `s[0]`
5. üî¥ `in` operator for strings
6. üî¥ Core string methods (find, startswith, endswith)

### Phase 3: List Power
7. üü° Negative indexing
8. üü° `in` operator for lists
9. üü° Basic slicing

### Phase 4: Robustness
10. ‚ö†Ô∏è Fix exit segfault
11. üü° `None` and `is` operator
12. üü° Multiple assignment

### Phase 5: Convenience
13. üü† Dictionary operations
14. üü† Default arguments
15. üü† More built-ins

### Phase 6: Advanced
16. üîµ Classes (if needed)
17. üîµ Exceptions (if needed)

---

## Test Coverage

**Comprehensive test file:** `aimacro_full_test.aim`

| Category | Tests | Status |
|----------|-------|--------|
| Arithmetic | 8 ops | ‚úÖ PASS |
| Comparisons | 6 ops + 3 boolean | ‚úÖ PASS |
| Functions | 5 functions + recursion | ‚úÖ PASS |
| Strings | concat, repeat, len, equality, str() | ‚úÖ PASS |
| Control Flow | if/elif/else, while, for, break, continue | ‚úÖ PASS |
| Lists | literal, index, assign, append, len | ‚úÖ PASS |
| Augmented Assignment | +=, -=, *=, /= | ‚úÖ PASS |
| Nested Structures | loops, ifs, function calls | ‚úÖ PASS |
| Edge Cases | zero, empty, large numbers | ‚úÖ PASS |

---

## Architecture Notes

### Transpilation Pipeline
```
.aim (AIMacro) ‚Üí Lexer ‚Üí Parser ‚Üí AST ‚Üí CodeGen ‚Üí .ailang (AILang)
```

### Key Components
- `Library.AIMacroCore.ailang` - Lexer, token definitions
- `Library.AIMacroParserCore.ailang` - Parser, AST generation
- `Library.AIMacroCodeGen.ailang` - AILang code generation
- `Library.AIMacro.ailang` - Runtime support (Len, Str, Print, etc.)
- `Library.AIMacroString.ailang` - String operations
- `aimacro_console.ailang` - TUI development environment

### Smart Features
- **String variable tracking** - Compile-time type inference for string ops
- **Nested call flattening** - Extracts nested calls to temps for AILang compatibility
- **Polymorphic `len()`** - Works on both strings and lists via heuristic
- **Proper `not` precedence** - Matches Python's operator precedence
Add this to the **KNOWN ISSUES** or create a **LIMITATIONS** section:

---

## ‚ö†Ô∏è KNOWN LIMITATIONS

### Function Parameter Limit: 6 Maximum

Functions are limited to **6 parameters maximum** due to the x86-64 calling convention (System V ABI uses 6 registers for integer arguments).

```python
# ‚ùå This will NOT work correctly (7+ params):
def bad_function(a, b, c, d, e, f, g, h):
    return a + b + c + d + e + f + g + h
end

# ‚úÖ Use a list instead:
def good_function(params):
    a = params[0]
    b = params[1]
    c = params[2]
    # ... access as needed
    total = 0
    for i in range(len(params)):
        total += params[i]
    end
    return total
end

# Call with:
args = [1, 2, 3, 4, 5, 6, 7, 8]
result = good_function(args)
```

**Why this is fine:**
- 7+ parameters is rare in practice (most functions use 2-4)
- If you need that many inputs, a list/array is cleaner anyway
- Lists give you N inputs with no artificial limit
- Self-documenting: `process(config)` vs `process(a, b, c, d, e, f, g, h, i, j)`

**The compiler will warn you** if you exceed 6 parameters and show the workaround pattern.

---

Also update the **Functions** section under **FULLY WORKING FEATURES**:

### Functions
```python
def function_name(param1, param2):  # Max 6 parameters
    # function body
    return value
end

# Supports:
# - Up to 6 parameters (use list for more)
# - Return values
# - Recursion
# - Nested function calls
```

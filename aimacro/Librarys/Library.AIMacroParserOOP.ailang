// Library.AIMacroParserOOP.ailang
// OOP Parser Extensions for AIMacro Transpiler
// Handles Python class syntax parsing
//
// Dependencies: XArrays, AIMacroCore, AIMacroParserCore
//
// FIXED: Replaced non-existent functions with correct API:
//   - Parse_Current() -> Parse.pos (use state directly)
//   - Lex_TokenType(tok) -> Parse_Type()
//   - Lex_TokenText(tok) -> Parse_Val()
//   - Token.IDENT -> Token.IDENTIFIER

LibraryImport.XArrays
LibraryImport.AIMacroCore
LibraryImport.AIMacroParserCore

// =============================================================================
// NODE TYPES - Already defined in AIMacroCore.Node:
//   CLASS_DEF = 100
//   METHOD_DEF = 101  
//   ATTRIBUTE = 102
//   ATTR_ASSIGN = 103
//   METHOD_CALL = 104  (also used for list methods like .append)
//   SUPER_CALL = 105
//
// TOKEN TYPES - Already defined in AIMacroCore.Token:
//   DOT = 89
//   PASS = 19
//   IDENTIFIER = 1
// =============================================================================

// =============================================================================
// KEYWORD DETECTION
// =============================================================================

Function.Parse_IsClassKeyword {
    Input: text: Address
    Output: Integer
    Body: {
        // 'class' is treated as an identifier, detected by text comparison
        cmp = StringCompare(text, "class")
        IfCondition EqualTo(cmp, 0) ThenBlock: {
            ReturnValue(1)
        }
        
        // 'super' also treated as identifier
        cmp = StringCompare(text, "super")
        IfCondition EqualTo(cmp, 0) ThenBlock: {
            ReturnValue(1)
        }
        
        // 'pass' already has Token.PASS = 19
        
        ReturnValue(0)
    }
}

// =============================================================================
// CHECK FOR CLASS DEFINITION
// =============================================================================

Function.Parse_IsClassDef {
    Output: Integer
    Body: {
        // Check if current token is identifier "class"
        // FIXED: Use Parse_Type() and Parse_Val() instead of non-existent functions
        tok_type = Parse_Type()
        
        IfCondition EqualTo(tok_type, Token.IDENTIFIER) ThenBlock: {
            tok_text = Parse_Val()
            cmp = StringCompare(tok_text, "class")
            IfCondition EqualTo(cmp, 0) ThenBlock: {
                ReturnValue(1)
            }
        }
        
        ReturnValue(0)
    }
}

// =============================================================================
// HELPER: CHECK TOKEN WITHOUT CONSUMING
// =============================================================================

Function.Parse_Check {
    Input: expected_type: Integer
    Output: Integer
    Body: {
        tok_type = Parse_Type()
        IfCondition EqualTo(tok_type, expected_type) ThenBlock: {
            ReturnValue(1)
        }
        ReturnValue(0)
    }
}

// =============================================================================
// HELPER: CHECK IF AT END OF INPUT
// =============================================================================

Function.Parse_AtEnd {
    Output: Integer
    Body: {
        tok_type = Parse_Type()
        IfCondition EqualTo(tok_type, Token.EOF) ThenBlock: {
            ReturnValue(1)
        }
        ReturnValue(0)
    }
}

// =============================================================================
// HELPER: EXPECT IDENTIFIER AND RETURN ITS VALUE
// =============================================================================

Function.Parse_ExpectIdent {
    Output: Address
    Body: {
        tok_type = Parse_Type()
        IfCondition EqualTo(tok_type, Token.IDENTIFIER) ThenBlock: {
            name = Parse_Val()
            result = Parse_CopyStr(name)
            Parse_Advance()
            ReturnValue(result)
        }
        ReturnValue(0)
    }
}

// =============================================================================
// HELPER: REPORT PARSE ERROR
// =============================================================================

Function.Parse_Error {
    Input: msg: Address
    Body: {
        Parse.err = 1
        Parse.err_line = Parse_Line()
        Parse.err_col = Parse_Col()
        Parse.err_msg = msg
        PrintMessage("Parse Error: ")
        PrintMessage(msg)
        PrintMessage("\n")
    }
}

// =============================================================================
// HELPER: CHECK FOR IDENTIFIER WITH SPECIFIC NAME
// =============================================================================

Function.Parse_CheckIdent {
    Input: expected: Address
    Output: Integer
    Body: {
        // FIXED: Use Parse_Type() and Parse_Val()
        tok_type = Parse_Type()
        
        IfCondition EqualTo(tok_type, Token.IDENTIFIER) ThenBlock: {
            tok_text = Parse_Val()
            cmp = StringCompare(tok_text, expected)
            IfCondition EqualTo(cmp, 0) ThenBlock: {
                ReturnValue(1)
            }
        }
        
        ReturnValue(0)
    }
}

// =============================================================================
// CLASS DEFINITION PARSER
// =============================================================================
// Syntax: class ClassName[(BaseClass, Mixin, ...)]:
//             def method(...):
//                 ...
//             end
//         end

Function.Parse_ClassDef {
    Output: Address
    Body: {
        // Consume 'class' keyword
        Parse_Advance()  // skip 'class'
        
        // Get class name
        class_name = Parse_ExpectIdent()
        IfCondition EqualTo(class_name, 0) ThenBlock: {
            Parse_Error("Expected class name after 'class'")
            ReturnValue(0)
        }
        
        // Check for base classes: (Base, Mixin, ...)
        bases = XArray.XCreate(4)
        
        is_lparen = Parse_Check(Token.LPAREN)
        IfCondition EqualTo(is_lparen, 1) ThenBlock: {
            Parse_Advance()  // consume '('
            
            // Parse base class list
            is_rparen = Parse_Check(Token.RPAREN)
            IfCondition EqualTo(is_rparen, 0) ThenBlock: {
                // First base
                base = Parse_ExpectIdent()
                IfCondition NotEqual(base, 0) ThenBlock: {
                    XArray.XPush(bases, base)
                }
                
                // Additional bases
                WhileLoop EqualTo(1, 1) {
                    is_comma = Parse_Check(Token.COMMA)
                    IfCondition EqualTo(is_comma, 0) ThenBlock: {
                        BreakLoop
                    }
                    Parse_Advance()  // consume ','
                    
                    base = Parse_ExpectIdent()
                    IfCondition NotEqual(base, 0) ThenBlock: {
                        XArray.XPush(bases, base)
                    }
                }
            }
            
            is_rparen = Parse_Check(Token.RPAREN)
            IfCondition EqualTo(is_rparen, 0) ThenBlock: {
                Parse_Error("Expected ')' after base class list")
                ReturnValue(0)
            }
            Parse_Advance()  // consume ')'
        }
        
        // Expect colon
        is_colon = Parse_Check(Token.COLON)
        IfCondition EqualTo(is_colon, 0) ThenBlock: {
            Parse_Error("Expected ':' after class definition")
            ReturnValue(0)
        }
        Parse_Advance()  // consume ':'
        
        // Skip optional newline
        is_newline = Parse_Check(Token.NEWLINE)
        IfCondition EqualTo(is_newline, 1) ThenBlock: {
            Parse_Advance()
        }
        
        // Parse class body (until 'end')
        body = Parse_ClassBody()
        
        // Expect 'end' keyword
        is_end = Parse_Check(Token.END)
        IfCondition EqualTo(is_end, 0) ThenBlock: {
            Parse_Error("Expected 'end' after class body")
            ReturnValue(0)
        }
        Parse_Advance()  // consume 'end'
        
        // Build CLASS_DEF node
        // Structure: [type, line, col, name, bases, body]
        node = ArrayCreate(6)
        ArraySet(node, 0, Node.CLASS_DEF)
        ArraySet(node, 1, Parse_Line())
        ArraySet(node, 2, 0)
        ArraySet(node, 3, class_name)
        ArraySet(node, 4, bases)
        ArraySet(node, 5, body)
        
        ReturnValue(node)
    }
}

// =============================================================================
// CLASS BODY PARSER
// =============================================================================
// Parses until 'end' keyword is found

Function.Parse_ClassBody {
    Output: Address
    Body: {
        body = XArray.XCreate(16)
        
        WhileLoop EqualTo(1, 1) {
            // Check for 'end' keyword (end of class body)
            is_end = Parse_Check(Token.END)
            IfCondition EqualTo(is_end, 1) ThenBlock: {
                BreakLoop
            }
            
            // Check for end of input
            is_eof = Parse_AtEnd()
            IfCondition EqualTo(is_eof, 1) ThenBlock: {
                BreakLoop
            }
            
            // Skip blank lines
            is_newline = Parse_Check(Token.NEWLINE)
            IfCondition EqualTo(is_newline, 1) ThenBlock: {
                Parse_Advance()
            } ElseBlock: {
                // Check for 'pass'
                is_pass = Parse_Check(Token.PASS)
                IfCondition EqualTo(is_pass, 1) ThenBlock: {
                    Parse_Advance()  // consume 'pass'
                    // Skip newline if present
                    is_newline = Parse_Check(Token.NEWLINE)
                    IfCondition EqualTo(is_newline, 1) ThenBlock: {
                        Parse_Advance()
                    }
                    // pass is a no-op, don't add to body
                } ElseBlock: {
                    // Check for method definition
                    is_def = Parse_Check(Token.DEF)
                    IfCondition EqualTo(is_def, 1) ThenBlock: {
                        method = Parse_MethodDef()
                        IfCondition NotEqual(method, 0) ThenBlock: {
                            XArray.XPush(body, method)
                        }
                    } ElseBlock: {
                        // Could be class variable assignment
                        // For now, parse as statement
                        stmt = Parse_Stmt()
                        IfCondition NotEqual(stmt, 0) ThenBlock: {
                            XArray.XPush(body, stmt)
                        }
                    }
                }
            }
        }
        
        ReturnValue(body)
    }
}

// =============================================================================
// METHOD DEFINITION PARSER
// =============================================================================
// Syntax: def method_name(self, param1, param2, ...) -> return_type:
//             body
//         end

Function.Parse_MethodDef {
    Output: Address
    Body: {
        // Consume 'def'
        Parse_Advance()
        
        // Get method name
        method_name = Parse_ExpectIdent()
        IfCondition EqualTo(method_name, 0) ThenBlock: {
            Parse_Error("Expected method name after 'def'")
            ReturnValue(0)
        }
        
        // Expect '('
        is_lparen = Parse_Check(Token.LPAREN)
        IfCondition EqualTo(is_lparen, 0) ThenBlock: {
            Parse_Error("Expected '(' after method name")
            ReturnValue(0)
        }
        Parse_Advance()  // consume '('
        
        // Parse parameters
        params = Parse_MethodParams()
        
        // Expect ')'
        is_rparen = Parse_Check(Token.RPAREN)
        IfCondition EqualTo(is_rparen, 0) ThenBlock: {
            Parse_Error("Expected ')' after parameters")
            ReturnValue(0)
        }
        Parse_Advance()  // consume ')'
        
        // Optional return type annotation: -> type
        return_type = 0
        is_arrow = Parse_Check(Token.ARROW)
        IfCondition EqualTo(is_arrow, 1) ThenBlock: {
            Parse_Advance()  // consume '->'
            return_type = Parse_ExpectIdent()
        }
        
        // Expect ':'
        is_colon = Parse_Check(Token.COLON)
        IfCondition EqualTo(is_colon, 0) ThenBlock: {
            Parse_Error("Expected ':' after method signature")
            ReturnValue(0)
        }
        Parse_Advance()  // consume ':'
        
        // Skip optional newline
        is_newline = Parse_Check(Token.NEWLINE)
        IfCondition EqualTo(is_newline, 1) ThenBlock: {
            Parse_Advance()
        }
        
        // Parse method body using existing Parse_Block (parses until 'end' or terminator)
        body = Parse_Block()
        
        // Expect 'end' keyword
        is_end = Parse_Check(Token.END)
        IfCondition EqualTo(is_end, 1) ThenBlock: {
            Parse_Advance()  // consume 'end'
        }
        // Note: Parse_Block may have already consumed 'end', so we check but don't error
        
        // Skip optional newline after end
        is_newline = Parse_Check(Token.NEWLINE)
        IfCondition EqualTo(is_newline, 1) ThenBlock: {
            Parse_Advance()
        }
        
        // Build METHOD_DEF node
        // Structure: [type, line, col, name, params, return_type, body]
        node = ArrayCreate(7)
        ArraySet(node, 0, Node.METHOD_DEF)
        ArraySet(node, 1, Parse_Line())
        ArraySet(node, 2, 0)
        ArraySet(node, 3, method_name)
        ArraySet(node, 4, params)
        ArraySet(node, 5, return_type)
        ArraySet(node, 6, body)
        
        ReturnValue(node)
    }
}

// =============================================================================
// METHOD PARAMETERS PARSER
// =============================================================================
// Returns XArray of parameter nodes, each containing [name, type, default]

Function.Parse_MethodParams {
    Output: Address
    Body: {
        params = XArray.XCreate(8)
        
        // Empty params?
        is_rparen = Parse_Check(Token.RPAREN)
        IfCondition EqualTo(is_rparen, 1) ThenBlock: {
            ReturnValue(params)
        }
        
        // First parameter
        param = Parse_MethodParam()
        IfCondition NotEqual(param, 0) ThenBlock: {
            XArray.XPush(params, param)
        }
        
        // Additional parameters
        WhileLoop EqualTo(1, 1) {
            is_comma = Parse_Check(Token.COMMA)
            IfCondition EqualTo(is_comma, 0) ThenBlock: {
                BreakLoop
            }
            Parse_Advance()  // consume ','
            
            param = Parse_MethodParam()
            IfCondition NotEqual(param, 0) ThenBlock: {
                XArray.XPush(params, param)
            }
        }
        
        ReturnValue(params)
    }
}

Function.Parse_MethodParam {
    Output: Address
    Body: {
        // Get parameter name
        name = Parse_ExpectIdent()
        IfCondition EqualTo(name, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        // Optional type annotation: : type
        param_type = 0
        is_colon = Parse_Check(Token.COLON)
        IfCondition EqualTo(is_colon, 1) ThenBlock: {
            Parse_Advance()  // consume ':'
            param_type = Parse_ExpectIdent()
        }
        
        // Optional default value: = value
        default_val = 0
        is_assign = Parse_Check(Token.ASSIGN)
        IfCondition EqualTo(is_assign, 1) ThenBlock: {
            Parse_Advance()  // consume '='
            default_val = Parse_Expr()
        }
        
        // Build param node [name, type, default]
        param = ArrayCreate(4)
        ArraySet(param, 0, name)
        ArraySet(param, 1, param_type)
        ArraySet(param, 2, default_val)
        // Slot 3 reserved for "name" field access in AST_GetField
        ArraySet(param, 3, name)
        
        ReturnValue(param)
    }
}

// =============================================================================
// ATTRIBUTE ACCESS PARSER
// =============================================================================
// Called from Parse_Trailer when we see '.' after a primary expression
// Handles: obj.attr and obj.method(args)

Function.Parse_AttributeOrMethodCall {
    Input: left: Address
    Output: Address
    Body: {
        // We've just matched '.' - get attribute/method name
        attr_name = Parse_ExpectIdent()
        IfCondition EqualTo(attr_name, 0) ThenBlock: {
            Parse_Error("Expected attribute name after '.'")
            ReturnValue(left)
        }
        
        // Check if this is a method call: obj.method(...)
        is_lparen = Parse_Check(Token.LPAREN)
        IfCondition EqualTo(is_lparen, 1) ThenBlock: {
            Parse_Advance()  // consume '('
            
            // Parse arguments
            args = Parse_ArgList()
            
            is_rparen = Parse_Check(Token.RPAREN)
            IfCondition EqualTo(is_rparen, 0) ThenBlock: {
                Parse_Error("Expected ')' after method arguments")
                ReturnValue(0)
            }
            Parse_Advance()  // consume ')'
            
            // Build METHOD_CALL node
            // Structure: [type, line, col, object, method, args]
            node = ArrayCreate(6)
            ArraySet(node, 0, Node.METHOD_CALL)
            ArraySet(node, 1, Parse_Line())
            ArraySet(node, 2, 0)
            ArraySet(node, 3, left)
            ArraySet(node, 4, attr_name)
            ArraySet(node, 5, args)
            
            ReturnValue(node)
        }
        
        // Plain attribute access: obj.attr
        // Build ATTRIBUTE node
        // Structure: [type, line, col, object, attr]
        node = ArrayCreate(5)
        ArraySet(node, 0, Node.ATTRIBUTE)
        ArraySet(node, 1, Parse_Line())
        ArraySet(node, 2, 0)
        ArraySet(node, 3, left)
        ArraySet(node, 4, attr_name)
        
        ReturnValue(node)
    }
}

// =============================================================================
// SUPER CALL PARSER
// =============================================================================
// Syntax: super().method(args)

Function.Parse_SuperCall {
    Output: Address
    Body: {
        // We've seen 'super' - consume it
        Parse_Advance()
        
        // Expect ()
        is_lparen = Parse_Check(Token.LPAREN)
        IfCondition EqualTo(is_lparen, 0) ThenBlock: {
            Parse_Error("Expected '(' after 'super'")
            ReturnValue(0)
        }
        Parse_Advance()  // consume '('
        
        is_rparen = Parse_Check(Token.RPAREN)
        IfCondition EqualTo(is_rparen, 0) ThenBlock: {
            Parse_Error("Expected ')' after 'super('")
            ReturnValue(0)
        }
        Parse_Advance()  // consume ')'
        
        // Expect .method
        is_dot = Parse_Check(Token.DOT)
        IfCondition EqualTo(is_dot, 0) ThenBlock: {
            Parse_Error("Expected '.method' after 'super()'")
            ReturnValue(0)
        }
        Parse_Advance()  // consume '.'
        
        method_name = Parse_ExpectIdent()
        IfCondition EqualTo(method_name, 0) ThenBlock: {
            Parse_Error("Expected method name after 'super().'")
            ReturnValue(0)
        }
        
        // Expect (args)
        is_lparen = Parse_Check(Token.LPAREN)
        IfCondition EqualTo(is_lparen, 0) ThenBlock: {
            Parse_Error("Expected '(' after super method name")
            ReturnValue(0)
        }
        Parse_Advance()  // consume '('
        
        args = Parse_ArgList()
        
        is_rparen = Parse_Check(Token.RPAREN)
        IfCondition EqualTo(is_rparen, 0) ThenBlock: {
            Parse_Error("Expected ')' after super method arguments")
            ReturnValue(0)
        }
        Parse_Advance()  // consume ')'
        
        // Build SUPER_CALL node
        // Structure: [type, line, col, method, args]
        node = ArrayCreate(5)
        ArraySet(node, 0, Node.SUPER_CALL)
        ArraySet(node, 1, Parse_Line())
        ArraySet(node, 2, 0)
        ArraySet(node, 3, method_name)
        ArraySet(node, 4, args)
        
        ReturnValue(node)
    }
}

// =============================================================================
// ARGUMENT LIST PARSER (for method calls)
// =============================================================================

Function.Parse_ArgList {
    Output: Address
    Body: {
        args = XArray.XCreate(8)
        
        // Empty args?
        is_rparen = Parse_Check(Token.RPAREN)
        IfCondition EqualTo(is_rparen, 1) ThenBlock: {
            ReturnValue(args)
        }
        
        // First argument
        arg = Parse_Expr()
        IfCondition NotEqual(arg, 0) ThenBlock: {
            XArray.XPush(args, arg)
        }
        
        // Additional arguments
        WhileLoop EqualTo(1, 1) {
            is_comma = Parse_Check(Token.COMMA)
            IfCondition EqualTo(is_comma, 0) ThenBlock: {
                BreakLoop
            }
            Parse_Advance()  // consume ','
            
            arg = Parse_Expr()
            IfCondition NotEqual(arg, 0) ThenBlock: {
                XArray.XPush(args, arg)
            }
        }
        
        ReturnValue(args)
    }
}

// =============================================================================
// TRAILER PARSER (handles chained .attr, .method(), [index])
// =============================================================================

Function.Parse_Trailer_OOP {
    Input: left: Address
    Output: Address
    Body: {
        result = left
        
        // Loop to handle chained access: obj.attr1.attr2[0].method()
        WhileLoop EqualTo(1, 1) {
            // Check for '.'
            is_dot = Parse_Check(Token.DOT)
            IfCondition EqualTo(is_dot, 1) ThenBlock: {
                Parse_Advance()  // consume '.'
                result = Parse_AttributeOrMethodCall(result)
            } ElseBlock: {
                // Check for '['
                is_lbracket = Parse_Check(Token.LBRACKET)
                IfCondition EqualTo(is_lbracket, 1) ThenBlock: {
                    Parse_Advance()  // consume '['
                    index = Parse_Expr()
                    
                    is_rbracket = Parse_Check(Token.RBRACKET)
                    IfCondition EqualTo(is_rbracket, 0) ThenBlock: {
                        Parse_Error("Expected ']' after index")
                        ReturnValue(result)
                    }
                    Parse_Advance()  // consume ']'
                    
                    // Build INDEX_ACCESS node
                    node = ArrayCreate(5)
                    ArraySet(node, 0, Node.INDEX_ACCESS)
                    ArraySet(node, 1, Parse_Line())
                    ArraySet(node, 2, 0)
                    ArraySet(node, 3, result)
                    ArraySet(node, 4, index)
                    result = node
                } ElseBlock: {
                    // No more trailers
                    BreakLoop
                }
            }
        }
        
        ReturnValue(result)
    }
}

// =============================================================================
// ATTRIBUTE ASSIGNMENT NODE BUILDER
// =============================================================================

Function.Parse_AttrAssignment {
    Input: attr_node: Address
    Input: value: Address
    Output: Address
    Body: {
        // attr_node is an ATTRIBUTE node: [type, line, col, object, attr]
        obj = ArrayGet(attr_node, 3)
        attr_name = ArrayGet(attr_node, 4)
        
        // Build ATTR_ASSIGN node
        // Structure: [type, line, col, object, attr, value]
        node = ArrayCreate(6)
        ArraySet(node, 0, Node.ATTR_ASSIGN)
        ArraySet(node, 1, Parse_Line())
        ArraySet(node, 2, 0)
        ArraySet(node, 3, obj)
        ArraySet(node, 4, attr_name)
        ArraySet(node, 5, value)
        
        ReturnValue(node)
    }
}

// =============================================================================
// AST FIELD ACCESS FOR OOP NODES
// =============================================================================

Function.AST_GetField_OOP {
    Input: node: Address
    Input: field: Address
    Output: Address
    Body: {
        node_type = ArrayGet(node, 0)
        
        // CLASS_DEF: [type, line, col, name, bases, body]
        IfCondition EqualTo(node_type, Node.CLASS_DEF) ThenBlock: {
            cmp = StringCompare(field, "name")
            IfCondition EqualTo(cmp, 0) ThenBlock: {
                ReturnValue(ArrayGet(node, 3))
            }
            cmp = StringCompare(field, "bases")
            IfCondition EqualTo(cmp, 0) ThenBlock: {
                ReturnValue(ArrayGet(node, 4))
            }
            cmp = StringCompare(field, "body")
            IfCondition EqualTo(cmp, 0) ThenBlock: {
                ReturnValue(ArrayGet(node, 5))
            }
        }
        
        // METHOD_DEF: [type, line, col, name, params, return_type, body]
        IfCondition EqualTo(node_type, Node.METHOD_DEF) ThenBlock: {
            cmp = StringCompare(field, "name")
            IfCondition EqualTo(cmp, 0) ThenBlock: {
                ReturnValue(ArrayGet(node, 3))
            }
            cmp = StringCompare(field, "params")
            IfCondition EqualTo(cmp, 0) ThenBlock: {
                ReturnValue(ArrayGet(node, 4))
            }
            cmp = StringCompare(field, "return_type")
            IfCondition EqualTo(cmp, 0) ThenBlock: {
                ReturnValue(ArrayGet(node, 5))
            }
            cmp = StringCompare(field, "body")
            IfCondition EqualTo(cmp, 0) ThenBlock: {
                ReturnValue(ArrayGet(node, 6))
            }
        }
        
        // ATTRIBUTE: [type, line, col, object, attr]
        IfCondition EqualTo(node_type, Node.ATTRIBUTE) ThenBlock: {
            cmp = StringCompare(field, "object")
            IfCondition EqualTo(cmp, 0) ThenBlock: {
                ReturnValue(ArrayGet(node, 3))
            }
            cmp = StringCompare(field, "attr")
            IfCondition EqualTo(cmp, 0) ThenBlock: {
                ReturnValue(ArrayGet(node, 4))
            }
        }
        
        // ATTR_ASSIGN: [type, line, col, object, attr, value]
        IfCondition EqualTo(node_type, Node.ATTR_ASSIGN) ThenBlock: {
            cmp = StringCompare(field, "object")
            IfCondition EqualTo(cmp, 0) ThenBlock: {
                ReturnValue(ArrayGet(node, 3))
            }
            cmp = StringCompare(field, "attr")
            IfCondition EqualTo(cmp, 0) ThenBlock: {
                ReturnValue(ArrayGet(node, 4))
            }
            cmp = StringCompare(field, "value")
            IfCondition EqualTo(cmp, 0) ThenBlock: {
                ReturnValue(ArrayGet(node, 5))
            }
        }
        
        // METHOD_CALL: [type, line, col, object, method, args]
        IfCondition EqualTo(node_type, Node.METHOD_CALL) ThenBlock: {
            cmp = StringCompare(field, "object")
            IfCondition EqualTo(cmp, 0) ThenBlock: {
                ReturnValue(ArrayGet(node, 3))
            }
            cmp = StringCompare(field, "method")
            IfCondition EqualTo(cmp, 0) ThenBlock: {
                ReturnValue(ArrayGet(node, 4))
            }
            cmp = StringCompare(field, "args")
            IfCondition EqualTo(cmp, 0) ThenBlock: {
                ReturnValue(ArrayGet(node, 5))
            }
        }
        
        // SUPER_CALL: [type, line, col, method, args]
        IfCondition EqualTo(node_type, Node.SUPER_CALL) ThenBlock: {
            cmp = StringCompare(field, "method")
            IfCondition EqualTo(cmp, 0) ThenBlock: {
                ReturnValue(ArrayGet(node, 3))
            }
            cmp = StringCompare(field, "args")
            IfCondition EqualTo(cmp, 0) ThenBlock: {
                ReturnValue(ArrayGet(node, 4))
            }
        }
        
        // Fall through to standard AST_GetField
        ReturnValue(AST_GetField(node, field))
    }
}

// =============================================================================
// END Library.AIMacroParserOOP.ailang
// =============================================================================
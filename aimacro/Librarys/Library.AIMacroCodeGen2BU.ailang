// Library.AIMacroCodeGen2.ailang
// AILang Code Generator - Part 2: Program, Function, Statements
//
// Dependencies: XArrays, AIMacroCore, AIMacroParserCore, AIMacroCodeGen1, AIMacroCodeGen3, AIMacroCodeGen4

LibraryImport.XArrays
LibraryImport.TArrays
LibraryImport.AIMacroCore
LibraryImport.AIMacroParserCore
LibraryImport.AIMacroCodeGen1
LibraryImport.AIMacroCodeGen3
LibraryImport.AIMacroCodeGen4
LibraryImport.AIMacroTypeAnnotations
LibraryImport.AIMacroCodeGenDict
LibraryImport.AIMacroCodeGenOOP

// =============================================================================
// MAIN CODE GENERATION ENTRY
// =============================================================================
Function.Gen_Program {
    Input: ast: Address
    Body: {
        
        OOPGen_Reset()
        

        Gen_EmitLine("LibraryImport.AIMacro")
        Gen_EmitLine("LibraryImport.AIMacroString")
        Gen_EmitLine("LibraryImport.TArrays")
        Gen_EmitLine("LibraryImport.AIMacroTypes")
        Gen_EmitLine("LibraryImport.THash")
        Gen_EmitLine("LibraryImport.AIMacroDict")
        Gen_EmitLine("LibraryImport.OOP")
        Gen_EmitLine("LibraryImport.HashMap")
        Gen_Emit("\n")
        
        decls = ArrayGet(ast, 3)
        n = XArray.XSize(decls)
        
        // =========== FIRST PASS: Scan for >6 param functions ===========
        i = 0
        WhileLoop LessThan(i, n) {
            decl = XArray.XGet(decls, i)
            t = AST_Type(decl)
            IfCondition EqualTo(t, Node.FUNCTION) ThenBlock: {
                fname = ArrayGet(decl, 3)
                params = ArrayGet(decl, 4)
                num_params = XArray.XSize(params)
                
                // DEBUG
                PrintMessage("First pass - function: ")
                PrintString(fname)
                PrintMessage(" params: ")
                PrintNumber(num_params)
                PrintMessage("\n")
                
                IfCondition GreaterThan(num_params, 6) ThenBlock: {
                    PrintMessage("  ADDING TO PACKED LIST\n")
                    XArray.XPush(Gen.packed_funcs, fname)
                }
            }
            i = Add(i, 1)
        }

        // DEBUG - check list size
        PrintMessage("Packed funcs count: ")
        pf_size = XArray.XSize(Gen.packed_funcs)
        PrintNumber(pf_size)
        PrintMessage("\n")
        // =========== END FIRST PASS ===========
        
        has_main = 0
        
       // =========== SECOND PASS: Generate code ===========
        PrintMessage("Starting second pass...\n")
        i = 0
        WhileLoop LessThan(i, n) {
            PrintMessage("Second pass - decl ")
            PrintNumber(i)
            PrintMessage("\n")
            
            decl = XArray.XGet(decls, i)
            
            PrintMessage("  Got decl, calling Gen_Node\n")
            
            Gen_Node(decl)
            
            PrintMessage("  Gen_Node returned\n")
            
            t = AST_Type(decl)
            IfCondition EqualTo(t, Node.FUNCTION) ThenBlock: {
                name = ArrayGet(decl, 3)
                cmp = StringCompare(name, "main")
                IfCondition EqualTo(cmp, 0) ThenBlock: {
                    has_main = 1
                }
            }
            
            i = Add(i, 1)
        }
        PrintMessage("Second pass complete\n")
        // =========== END SECOND PASS ===========
        
        // =========== OOP ADDITIONS ===========
        // Emit class registration subroutine (if any classes were defined)
        OOPGen_EmitClassInitSubroutine()
        // =========== END OOP ADDITIONS ===========
        
        IfCondition EqualTo(has_main, 1) ThenBlock: {
            Gen_Emit("\n")
            
            // =========== OOP ADDITIONS ===========
            // Call class init before main if we have classes
            IfCondition EqualTo(OOPGen.has_classes, 1) ThenBlock: {
                Gen_EmitLine("__OOP_ClassInit()")
            }
            // =========== END OOP ADDITIONS ===========
            
            Gen_EmitLine("RunTask(Main)")
        }
    }
}

// =============================================================================
// NODE DISPATCH
// =============================================================================
Function.Gen_Node {
    Input: node: Address
    Body: {
        IfCondition EqualTo(node, 0) ThenBlock: {
            PrintMessage("[Gen_Node] node is NULL\n")
            ReturnValue(0)
        }
        
        t = AST_Type(node)
        PrintMessage("[Gen_Node] type=")
        PrintNumber(t)
        PrintMessage("\n")

        // ADD: Handle class definitions OOP features
        IfCondition EqualTo(t, Node.CLASS_DEF) ThenBlock: {
            PrintMessage("[Gen_Node] Calling OOPGen_ClassDef\n")
            OOPGen_ClassDef(node)
            PrintMessage("[Gen_Node] OOPGen_ClassDef returned\n")
            ReturnValue(0)
        }
        
        // =========== ADD THIS ===========
        IfCondition EqualTo(t, Node.ATTR_ASSIGN) ThenBlock: {
            OOPGen_AttrAssign(node)
            ReturnValue(0)
        }
        // =========== END ADD ===========

        IfCondition EqualTo(t, Node.FUNCTION) ThenBlock: {
            Gen_Function(node)
            ReturnValue(0)
        }
        IfCondition EqualTo(t, Node.IF_STMT) ThenBlock: {
            Gen_If(node)
            ReturnValue(0)
        }
        IfCondition EqualTo(t, Node.WHILE_STMT) ThenBlock: {
            Gen_While(node)
            ReturnValue(0)
        }
        IfCondition EqualTo(t, Node.FOR_STMT) ThenBlock: {
            Gen_For(node)
            ReturnValue(0)
        }
        IfCondition EqualTo(t, Node.RETURN_STMT) ThenBlock: {
            Gen_Return(node)
            ReturnValue(0)
        }
        IfCondition EqualTo(t, Node.BREAK_STMT) ThenBlock: {
            Gen_EmitIndent()
            Gen_Emit("BreakLoop\n")
            ReturnValue(0)
        }
        IfCondition EqualTo(t, Node.CONTINUE_STMT) ThenBlock: {
            Gen_EmitIndent()
            Gen_Emit("ContinueLoop\n")
            ReturnValue(0)
        }

        IfCondition EqualTo(t, Node.TRY_STMT) ThenBlock: {
            Gen_Try(node)
            ReturnValue(0)
        }
        
        // NEW: Handle pass statement - does nothing
        IfCondition EqualTo(t, Node.PASS_STMT) ThenBlock: {
            // pass generates no code
            ReturnValue(0)
        }

        IfCondition EqualTo(t, Node.TUPLE_UNPACK) ThenBlock: {
            Gen_TupleUnpack(node)
            ReturnValue(0)
        }
        IfCondition EqualTo(t, Node.TUPLE_FOR) ThenBlock: {
            Gen_TupleFor(node)
            ReturnValue(0)
        }
        
        IfCondition EqualTo(t, Node.ASSIGNMENT) ThenBlock: {
            Gen_Assignment(node)
            ReturnValue(0)
        }
        IfCondition EqualTo(t, Node.AUG_ASSIGN) ThenBlock: {
            Gen_AugAssignment(node)
            ReturnValue(0)
        }
        IfCondition EqualTo(t, Node.INDEX_ASSIGN) ThenBlock: {
            Gen_IndexAssign(node)
            ReturnValue(0)
        }
        
        // CALL as statement - flatten arguments first
        IfCondition EqualTo(t, Node.CALL) ThenBlock: {
            Gen_FlattenCallArgs(node)
            Gen_EmitIndent()
            Gen_CallExpr(node)
            Gen_Emit("\n")
            ReturnValue(0)
        }
        
        // METHOD_CALL as statement - flatten arguments first
        IfCondition EqualTo(t, Node.METHOD_CALL) ThenBlock: {
            Gen_FlattenMethodArgs(node)
            Gen_EmitIndent()
            Gen_MethodCallExpr(node)
            Gen_Emit("\n")
            ReturnValue(0)
        }
        
        Gen_EmitIndent()
        Gen_Expr(node)
        Gen_Emit("\n")
    }
}

// =============================================================================
// FUNCTION GENERATION
// =============================================================================
Function.Gen_Function {
    Input: node: Address
    Body: {
        name = ArrayGet(node, 3)

        // DEBUG - print which function we're processing
        PrintMessage("Processing function: ")
        PrintString(name)
        PrintMessage("\n")

        params = ArrayGet(node, 4)
        body = ArrayGet(node, 5)
        ret_type = ArrayGet(node, 6)
        
        num_params = XArray.XSize(params)
        
        // Set type annotation context for this function
        TypeAnno_EnterFunction(name)
        
        // Call the packed handler for more than 6 functions in a call
        IfCondition GreaterThan(num_params, 6) ThenBlock: {
            Gen_PackedFunction(name, params, body, ret_type, num_params)
            TypeAnno_ExitFunction()
            ReturnValue(0)
        }
        
        // RESET STATE FOR NEW FUNCTION
        Gen.temp_counter = 0
        XArray.XClear(Gen.param_names)
        XArray.XClear(Gen.string_vars)
        XArray.XClear(Gen.list_vars)
        XArray.XClear(Gen.dict_vars) 
        
        cmp = StringCompare(name, "main")
        is_main = EqualTo(cmp, 0)
        
        IfCondition And(EqualTo(is_main, 1), EqualTo(num_params, 0)) ThenBlock: {
            Gen_EmitLine("SubRoutine.Main {")
        } ElseBlock: {
            j = 0
            WhileLoop LessThan(j, num_params) {
                pname = XArray.XGet(params, j)
                XArray.XPush(Gen.param_names, pname)
                j = Add(j, 1)
            }
            
            Gen_Emit("Function.")
            Gen_Emit(name)
            Gen_Emit(" {\n")
            
            j = 0
            WhileLoop LessThan(j, num_params) {
                pname = XArray.XGet(params, j)
                Gen_Emit("    Input: p_")
                Gen_Emit(pname)
                Gen_Emit(": Integer\n")
                j = Add(j, 1)
            }
            
            IfCondition NotEqual(ret_type, 0) ThenBlock: {
                Gen_Emit("    Output: Integer\n")
            }
            
            Gen_EmitLine("    Body: {")
        }
        
        Gen.indent = Add(Gen.indent, 2)
        Gen_Body(body)
        Gen.indent = Subtract(Gen.indent, 2)
        
        IfCondition And(EqualTo(is_main, 1), EqualTo(num_params, 0)) ThenBlock: {
            Gen_EmitLine("}")
        } ElseBlock: {
            Gen_EmitLine("    }")
            Gen_EmitLine("}")
        }
        
        Gen_Emit("\n")
        XArray.XClear(Gen.param_names)
        
        // Exit type annotation context
        TypeAnno_ExitFunction()
    }
}



// =============================================================================
// HANDLE FUNCTIONS WITH >6 PARAMETERS - Pack into array
// =============================================================================
Function.Gen_PackedFunction {
    Input: name: Address
    Input: params: Address
    Input: body: Address
    Input: ret_type: Address
    Input: num_params: Integer
    Body: {

        // RESET STATE FOR NEW FUNCTION
        Gen.temp_counter = 0
        XArray.XClear(Gen.param_names)
        XArray.XClear(Gen.string_vars)
        XArray.XClear(Gen.list_vars)
        XArray.XClear(Gen.dict_vars)

        // Register param names for body generation
        j = 0
        WhileLoop LessThan(j, num_params) {
            pname = XArray.XGet(params, j)
            XArray.XPush(Gen.param_names, pname)
            j = Add(j, 1)
        }
        
        // Emit function header with single array param
        Gen_Emit("Function.")
        Gen_Emit(name)
        Gen_Emit(" {\n")
        Gen_Emit("    Input: p__args: Address\n")
        
        IfCondition NotEqual(ret_type, 0) ThenBlock: {
            Gen_Emit("    Output: Integer\n")
        }
        
        Gen_EmitLine("    Body: {")
        
        // Emit unpacking code for each parameter
        j = 0
        WhileLoop LessThan(j, num_params) {
            pname = XArray.XGet(params, j)
            idx_str = NumberToString(j)
            
            Gen_Emit("        p_")
            Gen_Emit(pname)
            Gen_Emit(" = DictGen_SmartGet(p__args, ")
            Gen_Emit(idx_str)
            Gen_Emit(")\n")
            
            Deallocate(idx_str, 0)
            j = Add(j, 1)
        }
        
        // Generate body
        Gen.indent = Add(Gen.indent, 2)
        Gen_Body(body)
        Gen.indent = Subtract(Gen.indent, 2)
        
        Gen_EmitLine("    }")
        Gen_EmitLine("}")
        Gen_Emit("\n")
        
        XArray.XClear(Gen.param_names)
    }
}

// =============================================================================
// BODY GENERATION
// =============================================================================
Function.Gen_Body {
    Input: stmts: Address
    Body: {
        IfCondition EqualTo(stmts, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        n = XArray.XSize(stmts)
        i = 0
        WhileLoop LessThan(i, n) {
            stmt = XArray.XGet(stmts, i)
            Gen_Node(stmt)
            i = Add(i, 1)
        }
    }
}

// =============================================================================
// SLICE ACCESS GENERATION
// =============================================================================

Function.Gen_SliceAccess {
    Input: node: Address
    Body: {
        expr = ArrayGet(node, 3)
        start_expr = ArrayGet(node, 4)
        end_expr = ArrayGet(node, 5)
        
        // Check if slicing a string
        expr_type = AST_Type(expr)
        is_string = 0
        IfCondition EqualTo(expr_type, Node.IDENT) ThenBlock: {
            var_name = ArrayGet(expr, 3)
            is_string = Gen_IsStringVar(var_name)
        }
        IfCondition EqualTo(expr_type, Node.STR_LIT) ThenBlock: {
            is_string = 1
        }
        
        IfCondition EqualTo(is_string, 1) ThenBlock: {
            Gen_Emit("AIMacro.StringSlice(")
        } ElseBlock: {
            Gen_Emit("AIMacro.ListSlice(")
        }
        
        Gen_Expr(expr)
        Gen_Emit(", ")
        
        // Start (default 0)
        IfCondition EqualTo(start_expr, 0) ThenBlock: {
            Gen_Emit("0")
        } ElseBlock: {
            Gen_Expr(start_expr)
        }
        Gen_Emit(", ")
        
        // End (default size - need runtime check)
        IfCondition EqualTo(end_expr, 0) ThenBlock: {
            // Default to length
            IfCondition EqualTo(is_string, 1) ThenBlock: {
                Gen_Emit("StringLength(")
            } ElseBlock: {
                Gen_Emit("XArray.XSize(")
            }
            Gen_Expr(expr)
            Gen_Emit(")")
        } ElseBlock: {
            Gen_Expr(end_expr)
        }
        
        Gen_Emit(")")
    }
}

// =============================================================================
// IF STATEMENT - WITH FULL NESTED CALL EXTRACTION
// =============================================================================
Function.Gen_If {
    Input: node: Address
    Body: {
        cond = ArrayGet(node, 3)
        then_body = ArrayGet(node, 4)
        else_body = ArrayGet(node, 5)
        
        // Check if condition has function calls that need extraction
        has_call = Gen_HasCall(cond)
        
        IfCondition EqualTo(has_call, 1) ThenBlock: {
            // Extract ALL nested calls from the condition
            Gen_ExtractConditionCalls(cond)
        }
        
        Gen_EmitIndent()
        Gen_Emit("IfCondition ")
        Gen_Expr(cond)
        Gen_Emit(" ThenBlock: {\n")
        
        Gen.indent = Add(Gen.indent, 1)
        Gen_Body(then_body)
        Gen.indent = Subtract(Gen.indent, 1)
        
        IfCondition NotEqual(else_body, 0) ThenBlock: {
            Gen_EmitIndent()
            Gen_Emit("} ElseBlock: {\n")
            Gen.indent = Add(Gen.indent, 1)
            Gen_Body(else_body)
            Gen.indent = Subtract(Gen.indent, 1)
        }
        
        Gen_EmitIndent()
        Gen_Emit("}\n")
    }
}

// =============================================================================
// TUPLE UNPACKING: a, b = 1, 2  OR  a, b = func()
// =============================================================================
Function.Gen_TupleUnpack {
    Input: node: Address
    Body: {
        targets = ArrayGet(node, 3)
        values = ArrayGet(node, 4)
        
        num_targets = XArray.XSize(targets)
        num_values = XArray.XSize(values)
        
        // Case 1: Multiple values on RHS (a, b = 1, 2)
        IfCondition EqualTo(num_targets, num_values) ThenBlock: {
            i = 0
            WhileLoop LessThan(i, num_targets) {
                target_name = XArray.XGet(targets, i)
                val = XArray.XGet(values, i)
                
                // Flatten if needed
                has_call = Gen_HasCall(val)
                IfCondition EqualTo(has_call, 1) ThenBlock: {
                    val = Gen_FlattenExpr(val)
                }
                
                Gen_EmitIndent()
                Gen_Emit(target_name)
                Gen_Emit(" = ")
                Gen_Expr(val)
                Gen_Emit("\n")
                
                i = Add(i, 1)
            }
            ReturnValue(0)
        }
        
        // Case 2: Single value on RHS (a, b = func() or a, b = some_list)
        IfCondition EqualTo(num_values, 1) ThenBlock: {
            val = XArray.XGet(values, 0)
            
            // Flatten the value to a temp
            has_call = Gen_HasCall(val)
            IfCondition EqualTo(has_call, 1) ThenBlock: {
                val = Gen_FlattenExpr(val)
            }
            
            // Generate temp variable for the source
            temp_id = Gen.temp_counter
            Gen.temp_counter = Add(Gen.temp_counter, 1)
            temp_suffix = NumberToString(temp_id)
            
            Gen_EmitIndent()
            Gen_Emit("__tup")
            Gen_Emit(temp_suffix)
            Gen_Emit(" = ")
            Gen_Expr(val)
            Gen_Emit("\n")
            
            // Unpack each target from the temp
            i = 0
            WhileLoop LessThan(i, num_targets) {
                target_name = XArray.XGet(targets, i)
                
                Gen_EmitIndent()
                Gen_Emit(target_name)
                Gen_Emit(" = DictGen_SmartGet(__tup")
                Gen_Emit(temp_suffix)
                Gen_Emit(", ")
                Gen_EmitNumber(i)
                Gen_Emit(")\n")
                
                i = Add(i, 1)
            }
            
            Deallocate(temp_suffix, 0)
            ReturnValue(0)
        }
        
        // Mismatch - emit error comment
        Gen_EmitIndent()
        Gen_Emit("// ERROR: Tuple unpack mismatch\n")
    }
}

// =============================================================================
// TUPLE FOR: for i, v in enumerate(x)  OR  for a, b in zip(x, y)
// =============================================================================
Function.Gen_TupleFor {
    Input: node: Address
    Body: {
        var1 = ArrayGet(node, 3)
        var2 = ArrayGet(node, 4)
        iterable = ArrayGet(node, 5)
        body = ArrayGet(node, 6)
        
        iter_type = AST_Type(iterable)
        
        // Check for enumerate()
        IfCondition EqualTo(iter_type, Node.CALL) ThenBlock: {
            call_name = ArrayGet(iterable, 3)
            
            cmp = StringCompare(call_name, "enumerate")
            IfCondition EqualTo(cmp, 0) ThenBlock: {
                Gen_ForEnumerate(var1, var2, iterable, body)
                ReturnValue(0)
            }
            
            cmp = StringCompare(call_name, "zip")
            IfCondition EqualTo(cmp, 0) ThenBlock: {
                Gen_ForZip(var1, var2, iterable, body)
                ReturnValue(0)
            }
        }
        
        // Generic tuple iteration - iterate and unpack pairs
        loop_id = Gen.temp_counter
        Gen.temp_counter = Add(Gen.temp_counter, 1)
        loop_suffix = NumberToString(loop_id)
        
        // Flatten iterable if needed
        iter_has_call = Gen_HasCall(iterable)
        IfCondition EqualTo(iter_has_call, 1) ThenBlock: {
            iterable = Gen_FlattenExpr(iterable)
        }
        
        // iter = <iterable>
        Gen_EmitIndent()
        Gen_Emit("iter")
        Gen_Emit(loop_suffix)
        Gen_Emit(" = ")
        Gen_Expr(iterable)
        Gen_Emit("\n")
        
        // iterlen = SmartLen(iter)
        Gen_EmitIndent()
        Gen_Emit("iterlen")
        Gen_Emit(loop_suffix)
        Gen_Emit(" = AIMacro.SmartLen(iter")
        Gen_Emit(loop_suffix)
        Gen_Emit(")\n")
        
        // iteri = 0
        Gen_EmitIndent()
        Gen_Emit("iteri")
        Gen_Emit(loop_suffix)
        Gen_Emit(" = 0\n")
        
        // WhileLoop
        Gen_EmitIndent()
        Gen_Emit("WhileLoop LessThan(iteri")
        Gen_Emit(loop_suffix)
        Gen_Emit(", iterlen")
        Gen_Emit(loop_suffix)
        Gen_Emit(") {\n")
        
        Gen.indent = Add(Gen.indent, 1)
        
        // pair = SmartGet(iter, iteri)
        Gen_EmitIndent()
        Gen_Emit("__pair")
        Gen_Emit(loop_suffix)
        Gen_Emit(" = DictGen_SmartGet(iter")
        Gen_Emit(loop_suffix)
        Gen_Emit(", iteri")
        Gen_Emit(loop_suffix)
        Gen_Emit(")\n")
        
        // var1 = SmartGet(pair, 0)
        Gen_EmitIndent()
        Gen_EmitIdent(var1)
        Gen_Emit(" = DictGen_SmartGet(__pair")
        Gen_Emit(loop_suffix)
        Gen_Emit(", 0)\n")
        
        // var2 = SmartGet(pair, 1)
        Gen_EmitIndent()
        Gen_EmitIdent(var2)
        Gen_Emit(" = DictGen_SmartGet(__pair")
        Gen_Emit(loop_suffix)
        Gen_Emit(", 1)\n")
        
        // Body
        Gen_Body(body)
        
        // iteri = Add(iteri, 1)
        Gen_EmitIndent()
        Gen_Emit("iteri")
        Gen_Emit(loop_suffix)
        Gen_Emit(" = Add(iteri")
        Gen_Emit(loop_suffix)
        Gen_Emit(", 1)\n")
        
        Gen.indent = Subtract(Gen.indent, 1)
        Gen_EmitIndent()
        Gen_Emit("}\n")
        
        Deallocate(loop_suffix, 0)
    }
}

// =============================================================================
// TRY STATEMENT
// =============================================================================
Function.Gen_Try {
    Input: node: Address
    Body: {
        try_body = ArrayGet(node, 3)
        except_clauses = ArrayGet(node, 4)
        finally_body = ArrayGet(node, 5)
        
        // Emit TryBlock
        Gen_EmitIndent()
        Gen_Emit("TryBlock: {\n")
        
        Gen.indent = Add(Gen.indent, 1)
        Gen_Body(try_body)
        Gen.indent = Subtract(Gen.indent, 1)
        
        // Emit CatchError clauses
        num_clauses = XArray.XSize(except_clauses)
        i = 0
        WhileLoop LessThan(i, num_clauses) {
            clause = XArray.XGet(except_clauses, i)
            exc_type = ArrayGet(clause, 3)
            exc_body = ArrayGet(clause, 4)
            
            Gen_EmitIndent()
            IfCondition EqualTo(exc_type, 0) ThenBlock: {
                // Bare except - catch all
                Gen_Emit("} CatchError: GeneralError {\n")
            } ElseBlock: {
                Gen_Emit("} CatchError: ")
                Gen_Emit(exc_type)
                Gen_Emit(" {\n")
            }
            
            Gen.indent = Add(Gen.indent, 1)
            Gen_Body(exc_body)
            Gen.indent = Subtract(Gen.indent, 1)
            
            i = Add(i, 1)
        }
        
        // If no except clauses, still need to close TryBlock
        IfCondition EqualTo(num_clauses, 0) ThenBlock: {
            Gen_EmitIndent()
            Gen_Emit("}\n")
        }
        
        // Emit FinallyBlock if present
        IfCondition NotEqual(finally_body, 0) ThenBlock: {
            Gen_EmitIndent()
            Gen_Emit("} FinallyBlock: {\n")
            
            Gen.indent = Add(Gen.indent, 1)
            Gen_Body(finally_body)
            Gen.indent = Subtract(Gen.indent, 1)
            
            Gen_EmitIndent()
            Gen_Emit("}\n")
        } ElseBlock: {
            // Close the last CatchError block
            IfCondition GreaterThan(num_clauses, 0) ThenBlock: {
                Gen_EmitIndent()
                Gen_Emit("}\n")
            }
        }
    }
}

// =============================================================================
// FOR ENUMERATE: for i, v in enumerate(items)
// Optimized - no actual enumerate() call needed
// =============================================================================
Function.Gen_ForEnumerate {
    Input: idx_var: Address
    Input: val_var: Address
    Input: enum_call: Address
    Input: body: Address
    Body: {
        // Get the list from enumerate(list)
        args = ArrayGet(enum_call, 4)
        list_arg = XArray.XGet(args, 0)
        
        loop_id = Gen.temp_counter
        Gen.temp_counter = Add(Gen.temp_counter, 1)
        loop_suffix = NumberToString(loop_id)
        
        // Check if list_arg is a list literal - needs special handling
        list_type = AST_Type(list_arg)
        IfCondition EqualTo(list_type, Node.LIST_LIT) ThenBlock: {
            // Create the list using Gen_ListAssignment pattern
            elems = ArrayGet(list_arg, 3)
            n = XArray.XSize(elems)
            
            Gen_EmitIndent()
            Gen_Emit("iter")
            Gen_Emit(loop_suffix)
            Gen_Emit(" = TArray.TCreate(")
            Gen_EmitNumber(n)
            Gen_Emit(")\n")
            
            i = 0
            WhileLoop LessThan(i, n) {
                elem = XArray.XGet(elems, i)
                
                // Flatten element if needed
                has_call = Gen_HasCall(elem)
                IfCondition EqualTo(has_call, 1) ThenBlock: {
                    elem = Gen_FlattenExpr(elem)
                }
                
                Gen_EmitIndent()
                Gen_Emit("TArray.TPush(iter")
                Gen_Emit(loop_suffix)
                Gen_Emit(", ")
                Gen_Expr(elem)
                Gen_Emit(")\n")
                i = Add(i, 1)
            }
        } ElseBlock: {
            // Flatten list if it has calls
            list_has_call = Gen_HasCall(list_arg)
            IfCondition EqualTo(list_has_call, 1) ThenBlock: {
                list_arg = Gen_FlattenExpr(list_arg)
            }
            
            // iter = <list>
            Gen_EmitIndent()
            Gen_Emit("iter")
            Gen_Emit(loop_suffix)
            Gen_Emit(" = ")
            Gen_Expr(list_arg)
            Gen_Emit("\n")
        }
        
        // iterlen = SmartLen(iter)
        Gen_EmitIndent()
        Gen_Emit("iterlen")
        Gen_Emit(loop_suffix)
        Gen_Emit(" = AIMacro.SmartLen(iter")
        Gen_Emit(loop_suffix)
        Gen_Emit(")\n")
        
        // idx_var = 0 (this IS the index variable!)
        Gen_EmitIndent()
        Gen_EmitIdent(idx_var)
        Gen_Emit(" = 0\n")
        
        // WhileLoop
        Gen_EmitIndent()
        Gen_Emit("WhileLoop LessThan(")
        Gen_EmitIdent(idx_var)
        Gen_Emit(", iterlen")
        Gen_Emit(loop_suffix)
        Gen_Emit(") {\n")
        
        Gen.indent = Add(Gen.indent, 1)
        
        // val_var = SmartGet(iter, idx_var)
        Gen_EmitIndent()
        Gen_EmitIdent(val_var)
        Gen_Emit(" = DictGen_SmartGet(iter")
        Gen_Emit(loop_suffix)
        Gen_Emit(", ")
        Gen_EmitIdent(idx_var)
        Gen_Emit(")\n")
        
        // Body
        Gen_Body(body)
        
        // idx_var = Add(idx_var, 1)
        Gen_EmitIndent()
        Gen_EmitIdent(idx_var)
        Gen_Emit(" = Add(")
        Gen_EmitIdent(idx_var)
        Gen_Emit(", 1)\n")
        
        Gen.indent = Subtract(Gen.indent, 1)
        Gen_EmitIndent()
        Gen_Emit("}\n")
        
        Deallocate(loop_suffix, 0)
    }
}

// =============================================================================
// FOR ZIP: for a, b in zip(list1, list2)
// Parallel iteration over two lists
// =============================================================================
Function.Gen_ForZip {
    Input: var1: Address
    Input: var2: Address
    Input: zip_call: Address
    Input: body: Address
    Body: {
        // Get both lists from zip(list1, list2)
        args = ArrayGet(zip_call, 4)
        list1_arg = XArray.XGet(args, 0)
        list2_arg = XArray.XGet(args, 1)
        
        loop_id = Gen.temp_counter
        Gen.temp_counter = Add(Gen.temp_counter, 1)
        loop_suffix = NumberToString(loop_id)
        
        // Handle list1 - check if literal
        list1_type = AST_Type(list1_arg)
        IfCondition EqualTo(list1_type, Node.LIST_LIT) ThenBlock: {
            elems = ArrayGet(list1_arg, 3)
            n = XArray.XSize(elems)
            
            Gen_EmitIndent()
            Gen_Emit("iter1_")
            Gen_Emit(loop_suffix)
            Gen_Emit(" = TArray.TCreate(")
            Gen_EmitNumber(n)
            Gen_Emit(")\n")
            
            i = 0
            WhileLoop LessThan(i, n) {
                elem = XArray.XGet(elems, i)
                has_call = Gen_HasCall(elem)
                IfCondition EqualTo(has_call, 1) ThenBlock: {
                    elem = Gen_FlattenExpr(elem)
                }
                Gen_EmitIndent()
                Gen_Emit("TArray.TPush(iter1_")
                Gen_Emit(loop_suffix)
                Gen_Emit(", ")
                Gen_Expr(elem)
                Gen_Emit(")\n")
                i = Add(i, 1)
            }
        } ElseBlock: {
            list1_has_call = Gen_HasCall(list1_arg)
            IfCondition EqualTo(list1_has_call, 1) ThenBlock: {
                list1_arg = Gen_FlattenExpr(list1_arg)
            }
            Gen_EmitIndent()
            Gen_Emit("iter1_")
            Gen_Emit(loop_suffix)
            Gen_Emit(" = ")
            Gen_Expr(list1_arg)
            Gen_Emit("\n")
        }
        
        // Handle list2 - check if literal
        list2_type = AST_Type(list2_arg)
        IfCondition EqualTo(list2_type, Node.LIST_LIT) ThenBlock: {
            elems = ArrayGet(list2_arg, 3)
            n = XArray.XSize(elems)
            
            Gen_EmitIndent()
            Gen_Emit("iter2_")
            Gen_Emit(loop_suffix)
            Gen_Emit(" = TArray.TCreate(")
            Gen_EmitNumber(n)
            Gen_Emit(")\n")
            
            i = 0
            WhileLoop LessThan(i, n) {
                elem = XArray.XGet(elems, i)
                has_call = Gen_HasCall(elem)
                IfCondition EqualTo(has_call, 1) ThenBlock: {
                    elem = Gen_FlattenExpr(elem)
                }
                Gen_EmitIndent()
                Gen_Emit("TArray.TPush(iter2_")
                Gen_Emit(loop_suffix)
                Gen_Emit(", ")
                Gen_Expr(elem)
                Gen_Emit(")\n")
                i = Add(i, 1)
            }
        } ElseBlock: {
            list2_has_call = Gen_HasCall(list2_arg)
            IfCondition EqualTo(list2_has_call, 1) ThenBlock: {
                list2_arg = Gen_FlattenExpr(list2_arg)
            }
            Gen_EmitIndent()
            Gen_Emit("iter2_")
            Gen_Emit(loop_suffix)
            Gen_Emit(" = ")
            Gen_Expr(list2_arg)
            Gen_Emit("\n")
        }
        
        // len1 = SmartLen(iter1)
        Gen_EmitIndent()
        Gen_Emit("len1_")
        Gen_Emit(loop_suffix)
        Gen_Emit(" = AIMacro.SmartLen(iter1_")
        Gen_Emit(loop_suffix)
        Gen_Emit(")\n")
        
        // len2 = SmartLen(iter2)
        Gen_EmitIndent()
        Gen_Emit("len2_")
        Gen_Emit(loop_suffix)
        Gen_Emit(" = AIMacro.SmartLen(iter2_")
        Gen_Emit(loop_suffix)
        Gen_Emit(")\n")
        
        // iterlen = Min(len1, len2)
        Gen_EmitIndent()
        Gen_Emit("iterlen")
        Gen_Emit(loop_suffix)
        Gen_Emit(" = Min(len1_")
        Gen_Emit(loop_suffix)
        Gen_Emit(", len2_")
        Gen_Emit(loop_suffix)
        Gen_Emit(")\n")
        
        // iteri = 0
        Gen_EmitIndent()
        Gen_Emit("iteri")
        Gen_Emit(loop_suffix)
        Gen_Emit(" = 0\n")
        
        // WhileLoop
        Gen_EmitIndent()
        Gen_Emit("WhileLoop LessThan(iteri")
        Gen_Emit(loop_suffix)
        Gen_Emit(", iterlen")
        Gen_Emit(loop_suffix)
        Gen_Emit(") {\n")
        
        Gen.indent = Add(Gen.indent, 1)
        
        // var1 = SmartGet(iter1, iteri)
        Gen_EmitIndent()
        Gen_EmitIdent(var1)
        Gen_Emit(" = DictGen_SmartGet(iter1_")
        Gen_Emit(loop_suffix)
        Gen_Emit(", iteri")
        Gen_Emit(loop_suffix)
        Gen_Emit(")\n")
        
        // var2 = SmartGet(iter2, iteri)
        Gen_EmitIndent()
        Gen_EmitIdent(var2)
        Gen_Emit(" = DictGen_SmartGet(iter2_")
        Gen_Emit(loop_suffix)
        Gen_Emit(", iteri")
        Gen_Emit(loop_suffix)
        Gen_Emit(")\n")
        
        // Body
        Gen_Body(body)
        
        // iteri = Add(iteri, 1)
        Gen_EmitIndent()
        Gen_Emit("iteri")
        Gen_Emit(loop_suffix)
        Gen_Emit(" = Add(iteri")
        Gen_Emit(loop_suffix)
        Gen_Emit(", 1)\n")
        
        Gen.indent = Subtract(Gen.indent, 1)
        Gen_EmitIndent()
        Gen_Emit("}\n")
        
        Deallocate(loop_suffix, 0)
    }
}

// =============================================================================
// EMIT CONDITION EXPRESSION (with temp substitution)
// =============================================================================
Function.Gen_CondExpr {
    Input: node: Address
    Body: {
        // After extraction, just emit normally
        Gen_Expr(node)
    }
}

// =============================================================================
// WHILE STATEMENT
// =============================================================================
Function.Gen_While {
    Input: node: Address
    Body: {
        cond = ArrayGet(node, 3)
        body = ArrayGet(node, 4)
        
        has_call = Gen_HasCall(cond)
        
        IfCondition EqualTo(has_call, 1) ThenBlock: {
            // Use infinite loop + break pattern for complex conditions
            Gen_EmitIndent()
            Gen_Emit("WhileLoop EqualTo(1, 1) {\n")
            Gen.indent = Add(Gen.indent, 1)
            
            // Extract and emit condition check
            Gen_ExtractCalls(cond)
            Gen_EmitIndent()
            Gen_Emit("IfCondition Not(")
            Gen_Expr(cond)
            Gen_Emit(") ThenBlock: {\n")
            Gen.indent = Add(Gen.indent, 1)
            Gen_EmitIndent()
            Gen_Emit("BreakLoop\n")
            Gen.indent = Subtract(Gen.indent, 1)
            Gen_EmitIndent()
            Gen_Emit("}\n")
            
            Gen_Body(body)
            Gen.indent = Subtract(Gen.indent, 1)
            Gen_EmitIndent()
            Gen_Emit("}\n")
        } ElseBlock: {
            Gen_EmitIndent()
            Gen_Emit("WhileLoop ")
            Gen_Expr(cond)
            Gen_Emit(" {\n")
            
            Gen.indent = Add(Gen.indent, 1)
            Gen_Body(body)
            Gen.indent = Subtract(Gen.indent, 1)
            
            Gen_EmitIndent()
            Gen_Emit("}\n")
        }
    }
}

// =============================================================================
// FOR STATEMENT
// =============================================================================
Function.Gen_For {
    Input: node: Address
    Body: {
        var_name = ArrayGet(node, 3)
        iterable = ArrayGet(node, 4)
        body = ArrayGet(node, 5)
        
        iter_type = AST_Type(iterable)
        
        // Check if it's range()
        IfCondition EqualTo(iter_type, Node.CALL) ThenBlock: {
            call_name = ArrayGet(iterable, 3)
            cmp = StringCompare(call_name, "range")
            IfCondition EqualTo(cmp, 0) ThenBlock: {
                Gen_ForRange(var_name, iterable, body)
                ReturnValue(0)
            }
        }
        
        // Generic for-each over a list/iterable
        // Transform: for x in items:  ->  i=0; while i<len: x=items[i]; ...; i+=1
        
        // Get unique suffix for loop variables
        loop_id = Gen.temp_counter
        Gen.temp_counter = Add(Gen.temp_counter, 1)
        loop_suffix = NumberToString(loop_id)
        
        // Flatten iterable if it has calls
        iter_has_call = Gen_HasCall(iterable)
        IfCondition EqualTo(iter_has_call, 1) ThenBlock: {
            iterable = Gen_FlattenExpr(iterable)
        }
        
        // Emit: iter_arr = <iterable>
        Gen_EmitIndent()
        Gen_Emit("iter")
        Gen_Emit(loop_suffix)
        Gen_Emit(" = ")
        Gen_Expr(iterable)
        Gen_Emit("\n")
        
        // Emit: iter_len = XArray.XSize(iter_arr)
        Gen_EmitIndent()
        Gen_Emit("iterlen")
        Gen_Emit(loop_suffix)
        Gen_Emit(" = AIMacro.SmartLen(iter")
        Gen_Emit(loop_suffix)
        Gen_Emit(")\n")
        
        // Emit: iter_i = 0
        Gen_EmitIndent()
        Gen_Emit("iteri")
        Gen_Emit(loop_suffix)
        Gen_Emit(" = 0\n")
        
        // Emit: WhileLoop LessThan(iter_i, iter_len) {
        Gen_EmitIndent()
        Gen_Emit("WhileLoop LessThan(iteri")
        Gen_Emit(loop_suffix)
        Gen_Emit(", iterlen")
        Gen_Emit(loop_suffix)
        Gen_Emit(") {\n")
        
        Gen.indent = Add(Gen.indent, 1)
        
        // Emit: var_name = XArray.XGet(iter_arr, iter_i)
        Gen_EmitIndent()
        Gen_EmitIdent(var_name)
        Gen_Emit(" = DictGen_SmartGet(iter")
        Gen_Emit(loop_suffix)
        Gen_Emit(", iteri")
        Gen_Emit(loop_suffix)
        Gen_Emit(")\n")
        
        // Emit body
        Gen_Body(body)
        
        // Emit: iter_i = Add(iter_i, 1)
        Gen_EmitIndent()
        Gen_Emit("iteri")
        Gen_Emit(loop_suffix)
        Gen_Emit(" = Add(iteri")
        Gen_Emit(loop_suffix)
        Gen_Emit(", 1)\n")
        
        Gen.indent = Subtract(Gen.indent, 1)
        
        Gen_EmitIndent()
        Gen_Emit("}\n")
        
        // Free suffix string
        Deallocate(loop_suffix, 0)
    }
}

// =============================================================================
// FOR-RANGE OPTIMIZATION
// =============================================================================
Function.Gen_ForRange {
    Input: var_name: Address
    Input: range_call: Address
    Input: body: Address
    Body: {
        args = ArrayGet(range_call, 4)
        num_args = XArray.XSize(args)
        
        // Get unique suffix for this loop's internal variables
        loop_id = Gen.temp_counter
        Gen.temp_counter = Add(Gen.temp_counter, 1)
        loop_suffix = NumberToString(loop_id)
        
        // Determine start, stop, step values
        // range(n)       -> start=0, stop=n, step=1
        // range(a, b)    -> start=a, stop=b, step=1
        // range(a, b, c) -> start=a, stop=b, step=c
        
        // Create internal loop counter name: lc<id> (loop counter)
        Gen_EmitIndent()
        Gen_Emit("lc")
        Gen_Emit(loop_suffix)
        Gen_Emit(" = ")
        IfCondition EqualTo(num_args, 1) ThenBlock: {
            Gen_Emit("0")
        } ElseBlock: {
            start_arg = XArray.XGet(args, 0)
            Gen_Expr(start_arg)
        }
        Gen_Emit("\n")
        
        // Set stop value: ls<id> (loop stop)
        Gen_EmitIndent()
        Gen_Emit("ls")
        Gen_Emit(loop_suffix)
        Gen_Emit(" = ")
        IfCondition EqualTo(num_args, 1) ThenBlock: {
            stop_arg = XArray.XGet(args, 0)
            Gen_Expr(stop_arg)
        } ElseBlock: {
            stop_arg = XArray.XGet(args, 1)
            Gen_Expr(stop_arg)
        }
        Gen_Emit("\n")
        
        // Set step value: lt<id> (loop step)
        Gen_EmitIndent()
        Gen_Emit("lt")
        Gen_Emit(loop_suffix)
        Gen_Emit(" = ")
        IfCondition EqualTo(num_args, 3) ThenBlock: {
            step_arg = XArray.XGet(args, 2)
            Gen_Expr(step_arg)
        } ElseBlock: {
            Gen_Emit("1")
        }
        Gen_Emit("\n")
        
        // While loop
        Gen_EmitIndent()
        Gen_Emit("WhileLoop LessThan(lc")
        Gen_Emit(loop_suffix)
        Gen_Emit(", ls")
        Gen_Emit(loop_suffix)
        Gen_Emit(") {\n")
        
        Gen.indent = Add(Gen.indent, 1)
        
        // CRITICAL: Copy loop counter to user variable FIRST
        // This way continue won't skip the increment
        Gen_EmitIndent()
        Gen_EmitIdent(var_name)
        Gen_Emit(" = lc")
        Gen_Emit(loop_suffix)
        Gen_Emit("\n")
        
        // INCREMENT IMMEDIATELY (before body)
        // This is the key fix - continue will skip body but not this
        Gen_EmitIndent()
        Gen_Emit("lc")
        Gen_Emit(loop_suffix)
        Gen_Emit(" = Add(lc")
        Gen_Emit(loop_suffix)
        Gen_Emit(", lt")
        Gen_Emit(loop_suffix)
        Gen_Emit(")\n")
        
        // Now emit the body - user uses var_name which has current value
        // If continue fires, it goes back to loop check, but increment already done
        Gen_Body(body)
        
        Gen.indent = Subtract(Gen.indent, 1)
        Gen_EmitIndent()
        Gen_Emit("}\n")
        
        // Free the suffix string
        Deallocate(loop_suffix, 0)
    }
}

// =============================================================================
// RETURN STATEMENT - Also needs call extraction
// =============================================================================
// =============================================================================
// RETURN STATEMENT - Also needs call extraction
// =============================================================================
Function.Gen_Return {
    Input: node: Address
    Body: {
        value = ArrayGet(node, 3)
        
        IfCondition EqualTo(value, 0) ThenBlock: {
            Gen_EmitIndent()
            Gen_Emit("ReturnValue(0)\n")
            ReturnValue(0)
        }
        
        value_type = AST_Type(value)
        
        // =========== OOP CLASS INSTANTIATION IN RETURN ===========
        // Handle: return ClassName(args)
        IfCondition EqualTo(value_type, Node.CALL) ThenBlock: {
            call_name = ArrayGet(value, 3)
            call_args = ArrayGet(value, 4)
            is_class = OOPGen_IsClassName(call_name)
            IfCondition EqualTo(is_class, 1) ThenBlock: {
                PrintMessage("[Gen_Return] Class instantiation in return: ")
                PrintString(call_name)
                PrintMessage("\n")
                
                // OOPGen_InstanceCreation emits the setup code and returns
                // the temp var holding the instance
                instance_var = OOPGen_InstanceCreation(call_name, call_args)
                
                // Return the instance
                Gen_EmitIndent()
                Gen_Emit("ReturnValue(")
                Gen_Emit(instance_var)
                Gen_Emit(")\n")
                ReturnValue(0)
            }
        }
        // =========== END OOP CLASS INSTANTIATION ===========
        
        // =========== OOP METHOD CALL IN RETURN ===========
        // Handle: return obj.method(args)
        IfCondition EqualTo(value_type, Node.METHOD_CALL) ThenBlock: {
            obj = AST_GetField(value, "object")
            method = AST_GetField(value, "method")
            args = AST_GetField(value, "args")
            
            // Check if object is a known builtin type
            obj_type = AST_Type(obj)
            is_known_list = 0
            is_known_dict = 0
            is_known_str = 0
            IfCondition EqualTo(obj_type, Node.IDENT) ThenBlock: {
                obj_name = ArrayGet(obj, 3)
                is_known_list = Gen_IsListVar(obj_name)
                is_known_dict = Gen_IsDictVar(obj_name)
                is_known_str = Gen_IsStringVar(obj_name)
            }
            
            // If it's a known container, use standard method handling
            is_known = Or(is_known_list, Or(is_known_dict, is_known_str))
            IfCondition EqualTo(is_known, 0) ThenBlock: {
                // Not a known container - might be OOP, use OOP dispatch
                PrintMessage("[Gen_Return] OOP method call in return: ")
                PrintString(method)
                PrintMessage("\n")
                
                IfCondition EqualTo(args, 0) ThenBlock: {
                    num_args = 0
                } ElseBlock: {
                    num_args = XArray.XSize(args)
                }
                
                args_var = OOPGen_TempVar("args")
                
                Gen_EmitIndent()
                Gen_Emit(args_var)
                Gen_Emit(" = TArray.TCreate(")
                Gen_EmitNumber(num_args)
                Gen_Emit(")\n")
                
                i = 0
                WhileLoop LessThan(i, num_args) {
                    arg = XArray.XGet(args, i)
                    arg_has_call = Gen_HasCall(arg)
                    IfCondition EqualTo(arg_has_call, 1) ThenBlock: {
                        arg = Gen_FlattenExpr(arg)
                    }
                    Gen_EmitIndent()
                    Gen_Emit("TArray.TPush(")
                    Gen_Emit(args_var)
                    Gen_Emit(", ")
                    Gen_Expr(arg)
                    Gen_Emit(")\n")
                    i = Add(i, 1)
                }
                
                result_var = Gen_TempName()
                Gen_EmitIndent()
                Gen_Emit(result_var)
                Gen_Emit(" = OOP.MethodCall(")
                Gen_Expr(obj)
                Gen_Emit(", \"")
                Gen_Emit(method)
                Gen_Emit("\", ")
                Gen_Emit(args_var)
                Gen_Emit(")\n")
                
                Gen_EmitIndent()
                Gen_Emit("TArray.TDestroy(")
                Gen_Emit(args_var)
                Gen_Emit(")\n")
                
                Gen_EmitIndent()
                Gen_Emit("ReturnValue(")
                Gen_Emit(result_var)
                Gen_Emit(")\n")
                ReturnValue(0)
            }
        }
        // =========== END OOP METHOD CALL ===========
        
        // FLATTEN THE RETURN VALUE if it has calls OR is a binary op
        has_call = Gen_HasCall(value)
        is_binary = EqualTo(value_type, Node.BINARY_OP)
        
        IfCondition Or(EqualTo(has_call, 1), EqualTo(is_binary, 1)) ThenBlock: {
            value = Gen_FlattenExpr(value)
        }
        
        Gen_EmitIndent()
        Gen_Emit("ReturnValue(")
        Gen_Expr(value)
        Gen_Emit(")\n")
    }
}

Function.Gen_Assignment {
    Input: node: Address
    Body: {
        target = ArrayGet(node, 3)
        value = ArrayGet(node, 4)
        
        value_type = AST_Type(value)
        
        // Extract target name from AST node for type tracking
        target_type = AST_Type(target)
        target_name = target
        IfCondition EqualTo(target_type, Node.IDENT) ThenBlock: {
            target_name = ArrayGet(target, 3)
        }
        
        // DEBUG: Show assignment being processed
        PrintMessage("[Gen_Assignment] Processing: ")
        IfCondition EqualTo(target_type, Node.IDENT) ThenBlock: {
            PrintString(target_name)
        } ElseBlock: {
            PrintMessage("<non-ident target>")
        }
        PrintMessage(" = <value_type=")
        PrintNumber(value_type)
        PrintMessage(">\n")
        
        // List literal - special handling
        IfCondition EqualTo(value_type, Node.LIST_LIT) ThenBlock: {
            Gen_MarkListVar(target_name)
            Gen_ListAssignment(target, value)
            ReturnValue(0)
        }
        
        // Dict literal - special handling
        IfCondition EqualTo(value_type, Node.DICT_LIT) ThenBlock: {
            Gen_DictAssignment(target, value)
            ReturnValue(0)
        }
        
        // =========== PACKED FUNCTION CALL (>6 params) ===========
        IfCondition EqualTo(value_type, Node.CALL) ThenBlock: {
            call_name = ArrayGet(value, 3)
            is_packed = Gen_IsPackedFunc(call_name)
            IfCondition EqualTo(is_packed, 1) ThenBlock: {
                call_args = ArrayGet(value, 4)
                Gen_PackedCallAssignment(target, call_name, call_args)
                ReturnValue(0)
            }
        }
        // =========== END PACKED FUNCTION CALL ===========
        
        // =========== OOP CLASS INSTANTIATION ===========
        IfCondition EqualTo(value_type, Node.CALL) ThenBlock: {
            call_name = ArrayGet(value, 3)
            call_args = ArrayGet(value, 4)
            is_class = OOPGen_IsClassName(call_name)
            IfCondition EqualTo(is_class, 1) ThenBlock: {
                PrintMessage("[Gen_Assignment] Class instantiation detected: ")
                PrintString(call_name)
                PrintMessage("\n")
                
                instance_var = OOPGen_InstanceCreation(call_name, call_args)
                
                Gen_EmitIndent()
                Gen_EmitIdent(target)
                Gen_Emit(" = ")
                Gen_Emit(instance_var)
                Gen_Emit("\n")
                ReturnValue(0)
            }
        }
        // =========== END OOP CLASS INSTANTIATION ===========

        // =========== METHOD CALL ASSIGNMENT ===========
        IfCondition EqualTo(value_type, Node.METHOD_CALL) ThenBlock: {
            obj = AST_GetField(value, "object")
            method = AST_GetField(value, "method")
            args = AST_GetField(value, "args")
            
            PrintMessage("[Gen_Assignment] Method call assignment: ")
            PrintString(method)
            PrintMessage("\n")
            
            // First check if object is a known container type
            obj_type = AST_Type(obj)
            is_known_dict = 0
            is_known_list = 0
            is_known_str = 0
            IfCondition EqualTo(obj_type, Node.IDENT) ThenBlock: {
                obj_name = ArrayGet(obj, 3)
                is_known_dict = Gen_IsDictVar(obj_name)
                is_known_list = Gen_IsListVar(obj_name)
                is_known_str = Gen_IsStringVar(obj_name)
            }
            
            // Check if this is a BUILT-IN method that should NOT go through OOP
            // Only mark as builtin if the object is a KNOWN container type
            is_builtin = 0
            
            // List methods - only if object is known list
            IfCondition EqualTo(is_known_list, 1) ThenBlock: {
                cmp = StringCompare(method, "pop")
                IfCondition EqualTo(cmp, 0) ThenBlock: { is_builtin = 1 }
                cmp = StringCompare(method, "append")
                IfCondition EqualTo(cmp, 0) ThenBlock: { is_builtin = 1 }
                cmp = StringCompare(method, "copy")
                IfCondition EqualTo(cmp, 0) ThenBlock: { is_builtin = 1 }
                cmp = StringCompare(method, "clear")
                IfCondition EqualTo(cmp, 0) ThenBlock: { is_builtin = 1 }
                cmp = StringCompare(method, "extend")
                IfCondition EqualTo(cmp, 0) ThenBlock: { is_builtin = 1 }
                cmp = StringCompare(method, "insert")
                IfCondition EqualTo(cmp, 0) ThenBlock: { is_builtin = 1 }
                cmp = StringCompare(method, "remove")
                IfCondition EqualTo(cmp, 0) ThenBlock: { is_builtin = 1 }
                cmp = StringCompare(method, "reverse")
                IfCondition EqualTo(cmp, 0) ThenBlock: { is_builtin = 1 }
                cmp = StringCompare(method, "sort")
                IfCondition EqualTo(cmp, 0) ThenBlock: { is_builtin = 1 }
                cmp = StringCompare(method, "index")
                IfCondition EqualTo(cmp, 0) ThenBlock: { is_builtin = 1 }
                cmp = StringCompare(method, "count")
                IfCondition EqualTo(cmp, 0) ThenBlock: { is_builtin = 1 }
            }
            
            // Dict methods - only if object is known dict
            IfCondition EqualTo(is_known_dict, 1) ThenBlock: {
                cmp = StringCompare(method, "get")
                IfCondition EqualTo(cmp, 0) ThenBlock: { is_builtin = 1 }
                cmp = StringCompare(method, "keys")
                IfCondition EqualTo(cmp, 0) ThenBlock: { is_builtin = 1 }
                cmp = StringCompare(method, "values")
                IfCondition EqualTo(cmp, 0) ThenBlock: { is_builtin = 1 }
                cmp = StringCompare(method, "items")
                IfCondition EqualTo(cmp, 0) ThenBlock: { is_builtin = 1 }
                cmp = StringCompare(method, "update")
                IfCondition EqualTo(cmp, 0) ThenBlock: { is_builtin = 1 }
                cmp = StringCompare(method, "setdefault")
                IfCondition EqualTo(cmp, 0) ThenBlock: { is_builtin = 1 }
                cmp = StringCompare(method, "pop")
                IfCondition EqualTo(cmp, 0) ThenBlock: { is_builtin = 1 }
            }
            
            // String methods - only if object is known string
            IfCondition EqualTo(is_known_str, 1) ThenBlock: {
                cmp = StringCompare(method, "upper")
                IfCondition EqualTo(cmp, 0) ThenBlock: { is_builtin = 1 }
                cmp = StringCompare(method, "lower")
                IfCondition EqualTo(cmp, 0) ThenBlock: { is_builtin = 1 }
                cmp = StringCompare(method, "strip")
                IfCondition EqualTo(cmp, 0) ThenBlock: { is_builtin = 1 }
                cmp = StringCompare(method, "lstrip")
                IfCondition EqualTo(cmp, 0) ThenBlock: { is_builtin = 1 }
                cmp = StringCompare(method, "rstrip")
                IfCondition EqualTo(cmp, 0) ThenBlock: { is_builtin = 1 }
                cmp = StringCompare(method, "split")
                IfCondition EqualTo(cmp, 0) ThenBlock: { is_builtin = 1 }
                cmp = StringCompare(method, "join")
                IfCondition EqualTo(cmp, 0) ThenBlock: { is_builtin = 1 }
                cmp = StringCompare(method, "replace")
                IfCondition EqualTo(cmp, 0) ThenBlock: { is_builtin = 1 }
                cmp = StringCompare(method, "find")
                IfCondition EqualTo(cmp, 0) ThenBlock: { is_builtin = 1 }
                cmp = StringCompare(method, "startswith")
                IfCondition EqualTo(cmp, 0) ThenBlock: { is_builtin = 1 }
                cmp = StringCompare(method, "endswith")
                IfCondition EqualTo(cmp, 0) ThenBlock: { is_builtin = 1 }
                cmp = StringCompare(method, "format")
                IfCondition EqualTo(cmp, 0) ThenBlock: { is_builtin = 1 }
                cmp = StringCompare(method, "count")
                IfCondition EqualTo(cmp, 0) ThenBlock: { is_builtin = 1 }
            }
            
            // If it's a builtin method, use standard method call handling
            IfCondition EqualTo(is_builtin, 1) ThenBlock: {
                PrintMessage("[Gen_Assignment] Builtin method detected, using Gen_MethodCallExpr\n")
                
                Gen_FlattenMethodArgs(value)
                
                Gen_EmitIndent()
                Gen_EmitIdent(target)
                Gen_Emit(" = ")
                Gen_MethodCallExpr(value)
                Gen_Emit("\n")
                ReturnValue(0)
            }
            
            // =========== OOP METHOD CALL (non-builtin) ===========
            PrintMessage("[Gen_Assignment] Non-builtin method, using OOP dispatch\n")
            
            IfCondition EqualTo(args, 0) ThenBlock: {
                num_args = 0
            } ElseBlock: {
                num_args = XArray.XSize(args)
            }
            
            args_var = OOPGen_TempVar("args")
            
            Gen_EmitIndent()
            Gen_Emit(args_var)
            Gen_Emit(" = TArray.TCreate(")
            Gen_EmitNumber(num_args)
            Gen_Emit(")\n")
            
            i = 0
            WhileLoop LessThan(i, num_args) {
                arg = XArray.XGet(args, i)
                
                arg_has_call = Gen_HasCall(arg)
                IfCondition EqualTo(arg_has_call, 1) ThenBlock: {
                    arg = Gen_FlattenExpr(arg)
                }
                
                Gen_EmitIndent()
                Gen_Emit("TArray.TPush(")
                Gen_Emit(args_var)
                Gen_Emit(", ")
                Gen_Expr(arg)
                Gen_Emit(")\n")
                
                i = Add(i, 1)
            }
            
            Gen_EmitIndent()
            Gen_EmitIdent(target)
            Gen_Emit(" = OOP.MethodCall(")
            Gen_Expr(obj)
            Gen_Emit(", \"")
            Gen_Emit(method)
            Gen_Emit("\", ")
            Gen_Emit(args_var)
            Gen_Emit(")\n")
            
            Gen_EmitIndent()
            Gen_Emit("TArray.TDestroy(")
            Gen_Emit(args_var)
            Gen_Emit(")\n")
            
            ReturnValue(0)
        }
        // =========== END METHOD CALL ASSIGNMENT ===========
        
        // =========== STRING PROPAGATION FROM IDENT ===========
        IfCondition EqualTo(value_type, Node.IDENT) ThenBlock: {
            val_name = ArrayGet(value, 3)
            PrintMessage("[Gen_Assignment] Value is IDENT: '")
            PrintString(val_name)
            PrintMessage("' - checking if string var\n")
            val_is_str = Gen_IsStringVar(val_name)
            IfCondition EqualTo(val_is_str, 1) ThenBlock: {
                PrintMessage("[Gen_Assignment] Propagating string-ness to '")
                PrintString(target_name)
                PrintMessage("'\n")
                Gen_MarkStringVar(target_name)
            }
        }
        // =========== END STRING PROPAGATION ===========
        
        // Check if value involves strings
        PrintMessage("[Gen_Assignment] Checking Gen_InvolvesString for value...\n")
        is_string_value = Gen_InvolvesString(value)
        PrintMessage("[Gen_Assignment] Gen_InvolvesString returned: ")
        PrintNumber(is_string_value)
        PrintMessage("\n")
        
        IfCondition EqualTo(is_string_value, 1) ThenBlock: {
            PrintMessage("[Gen_Assignment] Marking target '")
            PrintString(target_name)
            PrintMessage("' as string var\n")
            Gen_MarkStringVar(target_name)
            
            IfCondition EqualTo(value_type, Node.BINARY_OP) ThenBlock: {
                op = ArrayGet(value, 4)
                IfCondition EqualTo(op, Token.PLUS) ThenBlock: {
                    PrintMessage("[Gen_Assignment] String concat detected - flattening\n")
                    value = Gen_FlattenExpr(value)
                    
                    PrintMessage("[Gen_Assignment] After flatten, emitting: ")
                    PrintString(target_name)
                    PrintMessage(" = <flattened>\n")
                    
                    Gen_EmitIndent()
                    Gen_EmitIdent(target)
                    Gen_Emit(" = ")
                    Gen_Expr(value)
                    Gen_Emit("\n")
                    ReturnValue(0)
                }
            }
            
            IfCondition EqualTo(value_type, Node.CALL) ThenBlock: {
                Gen_FlattenCallArgs(value)
                Gen_EmitIndent()
                Gen_EmitIdent(target)
                Gen_Emit(" = ")
                Gen_CallExpr(value)
                Gen_Emit("\n")
                ReturnValue(0)
            }
            
            IfCondition EqualTo(value_type, Node.METHOD_CALL) ThenBlock: {
                Gen_FlattenMethodArgs(value)
                Gen_EmitIndent()
                Gen_EmitIdent(target)
                Gen_Emit(" = ")
                Gen_MethodCallExpr(value)
                Gen_Emit("\n")
                ReturnValue(0)
            }
        }
        
        PrintMessage("[Gen_Assignment] Taking default path for '")
        PrintString(target_name)
        PrintMessage("'\n")

        // =========== OOP ATTRIBUTE FLATTENING ===========
        IfCondition EqualTo(value_type, Node.ATTRIBUTE) ThenBlock: {
            value = OOPGen_FlattenExpr(value)
        }
        // =========== END OOP ATTRIBUTE FLATTENING ===========
        
        has_call = Gen_HasCall(value)
        IfCondition EqualTo(has_call, 1) ThenBlock: {
            value = Gen_FlattenExpr(value)
        }
        
        Gen_EmitIndent()
        Gen_EmitIdent(target)
        Gen_Emit(" = ")
        Gen_Expr(value)
        Gen_Emit("\n")
    }
}

// =============================================================================
// PACKED CALL WITH ASSIGNMENT - handles t9 = helper_many_params(1,2,3,4,5,6,7,8)
// =============================================================================
Function.Gen_PackedCallAssignment {
    Input: target: Address
    Input: name: Address
    Input: args: Address
    Body: {
        n = XArray.XSize(args)
        
        // Create pack array name
        pack_name = Gen_TempName()
        
        // Emit: __packN = TArray.TCreate(n)
        Gen_EmitIndent()
        Gen_Emit(pack_name)
        Gen_Emit(" = TArray.TCreate(")
        n_str = NumberToString(n)
        Gen_Emit(n_str)
        Gen_Emit(")\n")
        Deallocate(n_str, 0)
        
        // Emit: TArray.TPush(__packN, arg) for each arg
        idx = 0
        WhileLoop LessThan(idx, n) {
            Gen_EmitIndent()
            Gen_Emit("TArray.TPush(")
            Gen_Emit(pack_name)
            Gen_Emit(", ")
            arg = XArray.XGet(args, idx)
            Gen_Expr(arg)
            Gen_Emit(")\n")
            idx = Add(idx, 1)
        }
        
        // Emit: target = func(pack)
        Gen_EmitIndent()
        Gen_EmitIdent(target)
        Gen_Emit(" = ")
        Gen_Emit(name)
        Gen_Emit("(")
        Gen_Emit(pack_name)
        Gen_Emit(")\n")
    }
}

// =============================================================================
// AUGMENTED ASSIGNMENT (x += 1)
// =============================================================================
Function.Gen_AugAssignment {
    Input: node: Address
    Body: {
        name = ArrayGet(node, 3)
        op = ArrayGet(node, 4)
        value = ArrayGet(node, 5)
        
        // FLATTEN THE VALUE EXPRESSION FIRST
        has_call = Gen_HasCall(value)
        
        IfCondition EqualTo(has_call, 1) ThenBlock: {
            value = Gen_FlattenExpr(value)
        }
        
        op_name = Gen_OpName(op)
        
        Gen_EmitIndent()
        Gen_EmitIdent(name)
        Gen_Emit(" = ")
        Gen_Emit(op_name)
        Gen_Emit("(")
        Gen_EmitIdent(name)
        Gen_Emit(", ")
        Gen_Expr(value)
        Gen_Emit(")\n")
    }
}

// =============================================================================
// LIST ASSIGNMENT
// =============================================================================
Function.Gen_ListAssignment {
    Input: target: Address
    Input: list_node: Address
    Body: {
        elems = ArrayGet(list_node, 3)
        n = XArray.XSize(elems)
        
        // Extract target name if it's an AST node
        target_type = AST_Type(target)
        target_name = target
        IfCondition EqualTo(target_type, Node.IDENT) ThenBlock: {
            target_name = ArrayGet(target, 3)
        }
        
        Gen_EmitIndent()
        Gen_EmitIdent(target_name)
        Gen_Emit(" = TArray.TCreate(")
        Gen_EmitNumber(n)
        Gen_Emit(")\n")
        
        i = 0
        WhileLoop LessThan(i, n) {
            elem = XArray.XGet(elems, i)
            
            has_call = Gen_HasCall(elem)
            IfCondition EqualTo(has_call, 1) ThenBlock: {
                elem = Gen_FlattenExpr(elem)
            }
            
            Gen_EmitIndent()
            Gen_Emit("TArray.TPush(")
            Gen_EmitIdent(target_name)
            Gen_Emit(", ")
            Gen_Expr(elem)
            Gen_Emit(")\n")
            i = Add(i, 1)
        }
    }
}


// =============================================================================
// DICT ASSIGNMENT
// =============================================================================
Function.Gen_DictAssignment {
    Input: target: Address
    Input: dict_node: Address
    Body: {
        pairs = ArrayGet(dict_node, 3)
        n = XArray.XSize(pairs)
        num_pairs = Divide(n, 2)
        
        // Mark this variable as a dict
        Gen_MarkDictVar(target)
        
        capacity = Multiply(num_pairs, 2)
        IfCondition LessThan(capacity, 16) ThenBlock: {
            capacity = 16
        }
        
        Gen_EmitIndent()
        Gen_EmitIdent(target)
        Gen_Emit(" = THash.Create(")
        Gen_EmitNumber(capacity)
        Gen_Emit(")\n")
        
        i = 0
        WhileLoop LessThan(i, n) {
            key = XArray.XGet(pairs, i)
            value = XArray.XGet(pairs, Add(i, 1))
            
            Gen_EmitIndent()
            Gen_Emit("THash.Set(")
            Gen_EmitIdent(target)
            Gen_Emit(", ")
            Gen_Expr(key)
            Gen_Emit(", ")
            Gen_Expr(value)
            Gen_Emit(")\n")
            
            i = Add(i, 2)
        }
    }
}


// =============================================================================
// INDEX ASSIGNMENT
// =============================================================================
Function.Gen_IndexAssign {
    Input: node: Address
    Body: {
        expr = ArrayGet(node, 3)
        index = ArrayGet(node, 4)
        value = ArrayGet(node, 5)
        
        // Flatten index if it has nested calls
        index_has_call = Gen_HasCall(index)
        IfCondition EqualTo(index_has_call, 1) ThenBlock: {
            index = Gen_FlattenExpr(index)
        }
        
        // Flatten value if it has nested calls
        value_has_call = Gen_HasCall(value)
        IfCondition EqualTo(value_has_call, 1) ThenBlock: {
            value = Gen_FlattenExpr(value)
        }
        
        // Flatten expr (the container itself) if needed
        expr_has_call = Gen_HasCall(expr)
        IfCondition EqualTo(expr_has_call, 1) ThenBlock: {
            expr = Gen_FlattenExpr(expr)
        }
        
        // Check container type
        expr_type = AST_Type(expr)
        is_dict = 0
        is_list = 0
        
        IfCondition EqualTo(expr_type, Node.IDENT) ThenBlock: {
            var_name = ArrayGet(expr, 3)
            is_dict = Gen_IsDictVar(var_name)
            is_list = Gen_IsListVar(var_name)
        }
        IfCondition EqualTo(expr_type, Node.DICT_LIT) ThenBlock: {
            is_dict = 1
        }
        IfCondition EqualTo(expr_type, Node.LIST_LIT) ThenBlock: {
            is_list = 1
        }
        
        IfCondition EqualTo(is_dict, 1) ThenBlock: {
            // Known dict assignment: d["key"] = value
            Gen_EmitIndent()
            Gen_Emit("THash.Set(")
            Gen_Expr(expr)
            Gen_Emit(", ")
            Gen_Expr(index)
            Gen_Emit(", ")
            Gen_Expr(value)
            Gen_Emit(")\n")
            ReturnValue(0)
        }
        
        IfCondition EqualTo(is_list, 1) ThenBlock: {
            // Known list assignment - use SmartSet (handles XArray & TArray)
            Gen_EmitIndent()
            Gen_Emit("DictGen_SmartSet(")
            Gen_Expr(expr)
            Gen_Emit(", ")
            Gen_Expr(index)
            Gen_Emit(", ")
            Gen_Expr(value)
            Gen_Emit(")\n")
            ReturnValue(0)
        }
        
        // UNKNOWN TYPE - Use runtime dispatch (handles function parameters)
        Gen_EmitIndent()
        Gen_Emit("DictGen_SmartSet(")
        Gen_Expr(expr)
        Gen_Emit(", ")
        Gen_Expr(index)
        Gen_Emit(", ")
        Gen_Expr(value)
        Gen_Emit(")\n")
    }
}
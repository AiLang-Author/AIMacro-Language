// Library.AIMacroCodeGen3.ailang
// AILang Code Generator - Part 3: Call Extraction, Flattening
//
// Dependencies: XArrays, AIMacroCore, AIMacroParserCore, AIMacroCodeGen1, AIMacroCodeGen4

LibraryImport.XArrays
LibraryImport.TArrays
LibraryImport.AIMacroCore
LibraryImport.AIMacroParserCore
LibraryImport.AIMacroCodeGen1
LibraryImport.AIMacroCodeGen4

// =============================================================================
// EXTRACT ALL CALLS FROM CONDITION EXPRESSION
// Handles:
//   - Direct calls: GreaterThan(func(), x)
//   - Nested in binary ops: And(func1(), func2())
//   - Calls with call arguments: GreaterThan(XArray.XGet(arr, i), max)
//   - Index access: arr[i] becomes XArray.XGet which is a call
// =============================================================================
Function.Gen_ExtractConditionCalls {
    Input: node: Address
    Body: {
        IfCondition EqualTo(node, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        t = AST_Type(node)
        
        // If it's a CALL, extract calls from its arguments
        IfCondition EqualTo(t, Node.CALL) ThenBlock: {
            args = ArrayGet(node, 4)
            IfCondition NotEqual(args, 0) ThenBlock: {
                n = XArray.XSize(args)
                idx = 0
                WhileLoop LessThan(idx, n) {
                    arg = XArray.XGet(args, idx)
                    arg_type = AST_Type(arg)
                    
                    // If argument is a call, extract it to temp
                    IfCondition EqualTo(arg_type, Node.CALL) ThenBlock: {
                        Gen_ExtractConditionCalls(arg)
                        temp = Gen_TempName()
                        Gen_EmitIndent()
                        Gen_Emit(temp)
                        Gen_Emit(" = ")
                        Gen_CallExpr(arg)
                        Gen_Emit("\n")
                        XArray.XSet(args, idx, Gen_MakeIdent(temp))
                    } ElseBlock: {
                        IfCondition EqualTo(arg_type, Node.METHOD_CALL) ThenBlock: {
                            temp = Gen_TempName()
                            Gen_EmitIndent()
                            Gen_Emit(temp)
                            Gen_Emit(" = ")
                            Gen_MethodCallExpr(arg)
                            Gen_Emit("\n")
                            XArray.XSet(args, idx, Gen_MakeIdent(temp))
                        } ElseBlock: {
                            IfCondition EqualTo(arg_type, Node.INDEX_ACCESS) ThenBlock: {
                                // FLATTEN INDEX EXPRESSION FIRST
                                index_expr = ArrayGet(arg, 4)
                                index_has_call = Gen_HasCall(index_expr)
                                IfCondition EqualTo(index_has_call, 1) ThenBlock: {
                                    flat_index = Gen_FlattenExpr(index_expr)
                                    ArraySet(arg, 4, flat_index)
                                }
                                
                                temp = Gen_TempName()
                                Gen_EmitIndent()
                                Gen_Emit(temp)
                                Gen_Emit(" = ")
                                // FIXED: Emit SmartGet directly instead of calling Gen_IndexAccess
                                Gen_EmitSmartIndexAccess(arg)
                                Gen_Emit("\n")
                                XArray.XSet(args, idx, Gen_MakeIdent(temp))
                            } ElseBlock: {
                                Gen_ExtractConditionCalls(arg)
                            }
                        }
                    }
                    
                    idx = Add(idx, 1)
                }
            }
            ReturnValue(0)
        }
        
        // If it's a BINARY_OP, check both sides
        IfCondition EqualTo(t, Node.BINARY_OP) ThenBlock: {
            left = ArrayGet(node, 3)
            right = ArrayGet(node, 5)
            
            left_type = AST_Type(left)
            right_type = AST_Type(right)
            
            // Handle left side
            IfCondition EqualTo(left_type, Node.CALL) ThenBlock: {
                Gen_ExtractConditionCalls(left)
                temp = Gen_TempName()
                Gen_EmitIndent()
                Gen_Emit(temp)
                Gen_Emit(" = ")
                Gen_CallExpr(left)
                Gen_Emit("\n")
                ArraySet(node, 3, Gen_MakeIdent(temp))
            } ElseBlock: {
                IfCondition EqualTo(left_type, Node.METHOD_CALL) ThenBlock: {
                    temp = Gen_TempName()
                    Gen_EmitIndent()
                    Gen_Emit(temp)
                    Gen_Emit(" = ")
                    Gen_MethodCallExpr(left)
                    Gen_Emit("\n")
                    ArraySet(node, 3, Gen_MakeIdent(temp))
                } ElseBlock: {
                    IfCondition EqualTo(left_type, Node.INDEX_ACCESS) ThenBlock: {
                        // NEW: Flatten index expression first!
                        index_expr = ArrayGet(left, 4)
                        index_has_call = Gen_HasCall(index_expr)
                        IfCondition EqualTo(index_has_call, 1) ThenBlock: {
                            flat_index = Gen_FlattenExpr(index_expr)
                            ArraySet(left, 4, flat_index)
                        }
                        
                        temp = Gen_TempName()
                        Gen_EmitIndent()
                        Gen_Emit(temp)
                        Gen_Emit(" = ")
                        // FIXED: Emit SmartGet directly
                        Gen_EmitSmartIndexAccess(left)
                        Gen_Emit("\n")
                        ArraySet(node, 3, Gen_MakeIdent(temp))
                    } ElseBlock: {
                        Gen_ExtractConditionCalls(left)
                    }
                }
            }
            
            // Handle right side
            IfCondition EqualTo(right_type, Node.CALL) ThenBlock: {
                Gen_ExtractConditionCalls(right)
                temp = Gen_TempName()
                Gen_EmitIndent()
                Gen_Emit(temp)
                Gen_Emit(" = ")
                Gen_CallExpr(right)
                Gen_Emit("\n")
                ArraySet(node, 5, Gen_MakeIdent(temp))
            } ElseBlock: {
                IfCondition EqualTo(right_type, Node.METHOD_CALL) ThenBlock: {
                    temp = Gen_TempName()
                    Gen_EmitIndent()
                    Gen_Emit(temp)
                    Gen_Emit(" = ")
                    Gen_MethodCallExpr(right)
                    Gen_Emit("\n")
                    ArraySet(node, 5, Gen_MakeIdent(temp))
                } ElseBlock: {
                    IfCondition EqualTo(right_type, Node.INDEX_ACCESS) ThenBlock: {
                        // NEW: Flatten index expression first!
                        index_expr = ArrayGet(right, 4)
                        index_has_call = Gen_HasCall(index_expr)
                        IfCondition EqualTo(index_has_call, 1) ThenBlock: {
                            flat_index = Gen_FlattenExpr(index_expr)
                            ArraySet(right, 4, flat_index)
                        }
                        
                        temp = Gen_TempName()
                        Gen_EmitIndent()
                        Gen_Emit(temp)
                        Gen_Emit(" = ")
                        // FIXED: Emit SmartGet directly
                        Gen_EmitSmartIndexAccess(right)
                        Gen_Emit("\n")
                        ArraySet(node, 5, Gen_MakeIdent(temp))
                    } ElseBlock: {
                        Gen_ExtractConditionCalls(right)
                    }
                }
            }
            
            ReturnValue(0)
        }
        
        // If it's a UNARY_OP, check operand
        IfCondition EqualTo(t, Node.UNARY_OP) ThenBlock: {
            operand = ArrayGet(node, 4)
            operand_type = AST_Type(operand)
            
            IfCondition EqualTo(operand_type, Node.CALL) ThenBlock: {
                Gen_ExtractConditionCalls(operand)
                temp = Gen_TempName()
                Gen_EmitIndent()
                Gen_Emit(temp)
                Gen_Emit(" = ")
                Gen_CallExpr(operand)
                Gen_Emit("\n")
                ArraySet(node, 4, Gen_MakeIdent(temp))
            } ElseBlock: {
                IfCondition EqualTo(operand_type, Node.INDEX_ACCESS) ThenBlock: {
                    // NEW: Flatten index expression first!
                    index_expr = ArrayGet(operand, 4)
                    index_has_call = Gen_HasCall(index_expr)
                    IfCondition EqualTo(index_has_call, 1) ThenBlock: {
                        flat_index = Gen_FlattenExpr(index_expr)
                        ArraySet(operand, 4, flat_index)
                    }
                    
                    temp = Gen_TempName()
                    Gen_EmitIndent()
                    Gen_Emit(temp)
                    Gen_Emit(" = ")
                    // FIXED: Emit SmartGet directly
                    Gen_EmitSmartIndexAccess(operand)
                    Gen_Emit("\n")
                    ArraySet(node, 4, Gen_MakeIdent(temp))
                } ElseBlock: {
                    Gen_ExtractConditionCalls(operand)
                }
            }
            
            ReturnValue(0)
        }
        
        // INDEX_ACCESS at top level - just return, handled by caller
        IfCondition EqualTo(t, Node.INDEX_ACCESS) ThenBlock: {
            ReturnValue(0)
        }
    }
}

// =============================================================================
// NEW HELPER: Emit SmartGet index access directly
// This avoids the cross-module call to Gen_IndexAccess
// =============================================================================
Function.Gen_EmitSmartIndexAccess {
    Input: node: Address
    Body: {
        expr = ArrayGet(node, 3)
        index = ArrayGet(node, 4)
        
        // Check for dict access
        expr_type = AST_Type(expr)
        is_dict_access = 0
        
        IfCondition EqualTo(expr_type, Node.IDENT) ThenBlock: {
            var_name = ArrayGet(expr, 3)
            is_dict_access = Gen_IsDictVar(var_name)
        }
        
        // DICT ACCESS
        IfCondition EqualTo(is_dict_access, 1) ThenBlock: {
            Gen_Emit("THash.Get(")
            Gen_Expr(expr)
            Gen_Emit(", ")
            Gen_Expr(index)
            Gen_Emit(")")
            ReturnValue(0)
        }
        
        // Check for string access
        is_string_access = 0
        
        IfCondition EqualTo(expr_type, Node.IDENT) ThenBlock: {
            var_name = ArrayGet(expr, 3)
            is_str = Gen_IsStringVar(var_name)
            IfCondition EqualTo(is_str, 1) ThenBlock: {
                is_string_access = 1
            }
        }
        IfCondition EqualTo(expr_type, Node.STR_LIT) ThenBlock: {
            is_string_access = 1
        }
        
        // Check for negative index
        index_type = AST_Type(index)
        is_negative = 0
        neg_value = 0
        
        IfCondition EqualTo(index_type, Node.UNARY_OP) ThenBlock: {
            op = ArrayGet(index, 3)
            IfCondition EqualTo(op, Token.MINUS) ThenBlock: {
                operand = ArrayGet(index, 4)
                operand_type = AST_Type(operand)
                IfCondition EqualTo(operand_type, Node.NUM_LIT) ThenBlock: {
                    is_negative = 1
                    neg_value = ArrayGet(operand, 3)
                }
            }
        }
        
        // STRING INDEXING
        IfCondition EqualTo(is_string_access, 1) ThenBlock: {
            IfCondition EqualTo(is_negative, 1) ThenBlock: {
                Gen_Emit("AIMacro.Chr(GetByte(")
                Gen_Expr(expr)
                Gen_Emit(", Subtract(StringLength(")
                Gen_Expr(expr)
                Gen_Emit("), ")
                Gen_EmitNumber(neg_value)
                Gen_Emit(")))")
            } ElseBlock: {
                Gen_Emit("AIMacro.Chr(GetByte(")
                Gen_Expr(expr)
                Gen_Emit(", ")
                Gen_Expr(index)
                Gen_Emit("))")
            }
            ReturnValue(0)
        }
        
        // ARRAY INDEXING - ALWAYS use SmartGet (handles XArray & TArray)
        IfCondition EqualTo(is_negative, 1) ThenBlock: {
            Gen_Emit("DictGen_SmartGet(")
            Gen_Expr(expr)
            Gen_Emit(", Subtract(AIMacro.SmartSize(")
            Gen_Expr(expr)
            Gen_Emit("), ")
            Gen_EmitNumber(neg_value)
            Gen_Emit("))")
        } ElseBlock: {
            Gen_Emit("DictGen_SmartGet(")
            Gen_Expr(expr)
            Gen_Emit(", ")
            Gen_Expr(index)
            Gen_Emit(")")
        }
    }
}

// =============================================================================
// EXTRACT FUNCTION CALLS TO TEMP VARIABLES
// This is the key function - extracts nested calls BEFORE the statement
// =============================================================================
Function.Gen_ExtractCalls {
    Input: node: Address
    Body: {
        IfCondition EqualTo(node, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        t = AST_Type(node)
        
        // For binary ops, check both sides
        IfCondition EqualTo(t, Node.BINARY_OP) ThenBlock: {
            left = ArrayGet(node, 3)
            right = ArrayGet(node, 5)
            
            // Extract calls from left side
            left_t = AST_Type(left)
            IfCondition EqualTo(left_t, Node.CALL) ThenBlock: {
                // First extract any nested calls in this call's args
                Gen_ExtractCallArgs(left)
                temp = Gen_TempName()
                Gen_EmitIndent()
                Gen_Emit(temp)
                Gen_Emit(" = ")
                Gen_CallExpr(left)
                Gen_Emit("\n")
                ArraySet(node, 3, Gen_MakeIdent(temp))
            } ElseBlock: {
                // Handle INDEX_ACCESS on left
                IfCondition EqualTo(left_t, Node.INDEX_ACCESS) ThenBlock: {
                    temp = Gen_TempName()
                    Gen_EmitIndent()
                    Gen_Emit(temp)
                    Gen_Emit(" = ")
                    // FIXED: Use SmartGet directly
                    Gen_EmitSmartIndexAccess(left)
                    Gen_Emit("\n")
                    ArraySet(node, 3, Gen_MakeIdent(temp))
                } ElseBlock: {
                    // Recurse into nested binary ops
                    Gen_ExtractCalls(left)
                }
            }
            
            // Extract calls from right side
            right_t = AST_Type(right)
            IfCondition EqualTo(right_t, Node.CALL) ThenBlock: {
                Gen_ExtractCallArgs(right)
                temp = Gen_TempName()
                Gen_EmitIndent()
                Gen_Emit(temp)
                Gen_Emit(" = ")
                Gen_CallExpr(right)
                Gen_Emit("\n")
                ArraySet(node, 5, Gen_MakeIdent(temp))
            } ElseBlock: {
                // Handle INDEX_ACCESS on right
                IfCondition EqualTo(right_t, Node.INDEX_ACCESS) ThenBlock: {
                    temp = Gen_TempName()
                    Gen_EmitIndent()
                    Gen_Emit(temp)
                    Gen_Emit(" = ")
                    // FIXED: Use SmartGet directly
                    Gen_EmitSmartIndexAccess(right)
                    Gen_Emit("\n")
                    ArraySet(node, 5, Gen_MakeIdent(temp))
                } ElseBlock: {
                    Gen_ExtractCalls(right)
                }
            }
            
            ReturnValue(0)
        }
        
        // For unary ops
        IfCondition EqualTo(t, Node.UNARY_OP) ThenBlock: {
            operand = ArrayGet(node, 4)
            operand_t = AST_Type(operand)
            IfCondition EqualTo(operand_t, Node.CALL) ThenBlock: {
                temp = Gen_TempName()
                Gen_EmitIndent()
                Gen_Emit(temp)
                Gen_Emit(" = ")
                Gen_CallExpr(operand)
                Gen_Emit("\n")
                ArraySet(node, 4, Gen_MakeIdent(temp))
            } ElseBlock: {
                // Handle INDEX_ACCESS in unary ops
                IfCondition EqualTo(operand_t, Node.INDEX_ACCESS) ThenBlock: {
                    temp = Gen_TempName()
                    Gen_EmitIndent()
                    Gen_Emit(temp)
                    Gen_Emit(" = ")
                    // FIXED: Use SmartGet directly
                    Gen_EmitSmartIndexAccess(operand)
                    Gen_Emit("\n")
                    ArraySet(node, 4, Gen_MakeIdent(temp))
                } ElseBlock: {
                    Gen_ExtractCalls(operand)
                }
            }
            ReturnValue(0)
        }
        
        // If the node itself is INDEX_ACCESS, extract the index if it has calls
        IfCondition EqualTo(t, Node.INDEX_ACCESS) ThenBlock: {
            index_expr = ArrayGet(node, 4)
            index_t = AST_Type(index_expr)
            IfCondition EqualTo(index_t, Node.CALL) ThenBlock: {
                temp = Gen_TempName()
                Gen_EmitIndent()
                Gen_Emit(temp)
                Gen_Emit(" = ")
                Gen_CallExpr(index_expr)
                Gen_Emit("\n")
                ArraySet(node, 4, Gen_MakeIdent(temp))
            }
            ReturnValue(0)
        }
    }
}

// =============================================================================
// EXTRACT CALLS FROM FUNCTION ARGUMENTS
// Handles: result = add(multiply(2,3), multiply(4,5))
// Emits:   t0 = multiply(2,3)
//          t1 = multiply(4,5)
// Then the call becomes: add(t0, t1)
// =============================================================================
Function.Gen_ExtractCallArgs {
    Input: call_node: Address
    Body: {
        args = ArrayGet(call_node, 4)
        IfCondition EqualTo(args, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        n = XArray.XSize(args)
        i = 0
        WhileLoop LessThan(i, n) {
            arg = XArray.XGet(args, i)
            arg_type = AST_Type(arg)
            
            // If argument is a call, extract it
            IfCondition EqualTo(arg_type, Node.CALL) ThenBlock: {
                // Check if THIS call has nested calls in its args
                inner_args = ArrayGet(arg, 4)
                inner_has_calls = Gen_ArgsHaveCalls(inner_args)
                IfCondition EqualTo(inner_has_calls, 1) ThenBlock: {
                    // Recursively extract inner calls first
                    Gen_ExtractCallArgs(arg)
                }
                
                // Now extract this call to a temp
                temp = Gen_TempName()
                Gen_EmitIndent()
                Gen_Emit(temp)
                Gen_Emit(" = ")
                Gen_CallExpr(arg)
                Gen_Emit("\n")
                
                // Replace arg with identifier node
                XArray.XSet(args, i, Gen_MakeIdent(temp))
            } ElseBlock: {
                // If it's a binary/unary op with calls, extract those
                IfCondition EqualTo(arg_type, Node.BINARY_OP) ThenBlock: {
                    has = Gen_HasCall(arg)
                    IfCondition EqualTo(has, 1) ThenBlock: {
                        Gen_ExtractCalls(arg)
                    }
                }
                IfCondition EqualTo(arg_type, Node.UNARY_OP) ThenBlock: {
                    has = Gen_HasCall(arg)
                    IfCondition EqualTo(has, 1) ThenBlock: {
                        Gen_ExtractCalls(arg)
                    }
                }
            }
            
            i = Add(i, 1)
        }
    }
}

// =============================================================================
// NEW FUNCTION: Extract nested calls from any expression
// Returns the (possibly modified) expression after extracting calls to temps
// =============================================================================
Function.Gen_ExtractAllCalls {
    Input: node: Address
    Output: Address
    Body: {
        IfCondition EqualTo(node, 0) ThenBlock: {
            ReturnValue(node)
        }
        
        t = AST_Type(node)
        
        // For a CALL node, first extract calls from its arguments
        IfCondition EqualTo(t, Node.CALL) ThenBlock: {
            args = ArrayGet(node, 4)
            IfCondition NotEqual(args, 0) ThenBlock: {
                n = XArray.XSize(args)
                idx = 0
                WhileLoop LessThan(idx, n) {
                    arg = XArray.XGet(args, idx)
                    arg_type = AST_Type(arg)
                    
                    // If argument is a CALL, METHOD_CALL, or INDEX_ACCESS
                    // extract it to a temp variable
                    needs_extract = 0
                    IfCondition EqualTo(arg_type, Node.CALL) ThenBlock: {
                        needs_extract = 1
                    }
                    IfCondition EqualTo(arg_type, Node.METHOD_CALL) ThenBlock: {
                        needs_extract = 1
                    }
                    IfCondition EqualTo(arg_type, Node.INDEX_ACCESS) ThenBlock: {
                        needs_extract = 1
                    }
                    
                    IfCondition EqualTo(needs_extract, 1) ThenBlock: {
                        // Recursively extract from this arg first
                        extracted_arg = Gen_ExtractAllCalls(arg)
                        
                        // Now emit this call to a temp
                        temp = Gen_TempName()
                        Gen_EmitIndent()
                        Gen_Emit(temp)
                        Gen_Emit(" = ")
                        Gen_Expr(extracted_arg)
                        Gen_Emit("\n")
                        
                        // Replace the arg with an identifier
                        XArray.XSet(args, idx, Gen_MakeIdent(temp))
                    } ElseBlock: {
                        // If it's a BINARY_OP, recursively process it
                        IfCondition EqualTo(arg_type, Node.BINARY_OP) ThenBlock: {
                            new_arg = Gen_ExtractAllCalls(arg)
                            XArray.XSet(args, idx, new_arg)
                        }
                    }
                    
                    idx = Add(idx, 1)
                }
            }
            ReturnValue(node)
        }
        
        // For METHOD_CALL, same logic
        IfCondition EqualTo(t, Node.METHOD_CALL) ThenBlock: {
            // Extract from object if it's a call
            obj = ArrayGet(node, 3)
            obj_type = AST_Type(obj)
            IfCondition Or(EqualTo(obj_type, Node.CALL), Or(EqualTo(obj_type, Node.METHOD_CALL), EqualTo(obj_type, Node.INDEX_ACCESS))) ThenBlock: {
                extracted_obj = Gen_ExtractAllCalls(obj)
                temp = Gen_TempName()
                Gen_EmitIndent()
                Gen_Emit(temp)
                Gen_Emit(" = ")
                Gen_Expr(extracted_obj)
                Gen_Emit("\n")
                ArraySet(node, 3, Gen_MakeIdent(temp))
            }
            
            // Extract from arguments
            args = ArrayGet(node, 5)
            IfCondition NotEqual(args, 0) ThenBlock: {
                n = XArray.XSize(args)
                idx = 0
                WhileLoop LessThan(idx, n) {
                    arg = XArray.XGet(args, idx)
                    arg_type = AST_Type(arg)
                    
                    needs_extract = 0
                    IfCondition EqualTo(arg_type, Node.CALL) ThenBlock: { needs_extract = 1 }
                    IfCondition EqualTo(arg_type, Node.METHOD_CALL) ThenBlock: { needs_extract = 1 }
                    IfCondition EqualTo(arg_type, Node.INDEX_ACCESS) ThenBlock: { needs_extract = 1 }
                    
                    IfCondition EqualTo(needs_extract, 1) ThenBlock: {
                        extracted_arg = Gen_ExtractAllCalls(arg)
                        temp = Gen_TempName()
                        Gen_EmitIndent()
                        Gen_Emit(temp)
                        Gen_Emit(" = ")
                        Gen_Expr(extracted_arg)
                        Gen_Emit("\n")
                        XArray.XSet(args, idx, Gen_MakeIdent(temp))
                    } ElseBlock: {
                        IfCondition EqualTo(arg_type, Node.BINARY_OP) ThenBlock: {
                            new_arg = Gen_ExtractAllCalls(arg)
                            XArray.XSet(args, idx, new_arg)
                        }
                    }
                    
                    idx = Add(idx, 1)
                }
            }
            ReturnValue(node)
        }
        
        // For BINARY_OP, process both sides
        IfCondition EqualTo(t, Node.BINARY_OP) ThenBlock: {
            left = ArrayGet(node, 3)
            right = ArrayGet(node, 5)
            
            // Process left side
            left_type = AST_Type(left)
            IfCondition Or(EqualTo(left_type, Node.CALL), Or(EqualTo(left_type, Node.METHOD_CALL), EqualTo(left_type, Node.INDEX_ACCESS))) ThenBlock: {
                extracted_left = Gen_ExtractAllCalls(left)
                temp = Gen_TempName()
                Gen_EmitIndent()
                Gen_Emit(temp)
                Gen_Emit(" = ")
                Gen_Expr(extracted_left)
                Gen_Emit("\n")
                ArraySet(node, 3, Gen_MakeIdent(temp))
            } ElseBlock: {
                IfCondition EqualTo(left_type, Node.BINARY_OP) ThenBlock: {
                    new_left = Gen_ExtractAllCalls(left)
                    ArraySet(node, 3, new_left)
                }
            }
            
            // Process right side
            right_type = AST_Type(right)
            IfCondition Or(EqualTo(right_type, Node.CALL), Or(EqualTo(right_type, Node.METHOD_CALL), EqualTo(right_type, Node.INDEX_ACCESS))) ThenBlock: {
                extracted_right = Gen_ExtractAllCalls(right)
                temp = Gen_TempName()
                Gen_EmitIndent()
                Gen_Emit(temp)
                Gen_Emit(" = ")
                Gen_Expr(extracted_right)
                Gen_Emit("\n")
                ArraySet(node, 5, Gen_MakeIdent(temp))
            } ElseBlock: {
                IfCondition EqualTo(right_type, Node.BINARY_OP) ThenBlock: {
                    new_right = Gen_ExtractAllCalls(right)
                    ArraySet(node, 5, new_right)
                }
            }
            
            ReturnValue(node)
        }
        
        // For INDEX_ACCESS, process the index expression
        IfCondition EqualTo(t, Node.INDEX_ACCESS) ThenBlock: {
            index = ArrayGet(node, 4)
            index_type = AST_Type(index)
            IfCondition Or(EqualTo(index_type, Node.CALL), Or(EqualTo(index_type, Node.METHOD_CALL), EqualTo(index_type, Node.INDEX_ACCESS))) ThenBlock: {
                extracted_index = Gen_ExtractAllCalls(index)
                temp = Gen_TempName()
                Gen_EmitIndent()
                Gen_Emit(temp)
                Gen_Emit(" = ")
                Gen_Expr(extracted_index)
                Gen_Emit("\n")
                ArraySet(node, 4, Gen_MakeIdent(temp))
            }
            ReturnValue(node)
        }
        
        // For other node types, return as-is
        ReturnValue(node)
    }
}

// =============================================================================
// Helper: Flatten an expression by extracting ALL calls to temps
// This walks the expression tree depth-first, extracts calls to temps,
// and returns an identifier node (or literal) that can be used inline
// =============================================================================
// =============================================================================
// Helper: Flatten an expression by extracting ALL calls to temps
// This walks the expression tree depth-first, extracts calls to temps,
// and returns an identifier node (or literal) that can be used inline
// =============================================================================
Function.Gen_FlattenExpr {
    Input: node: Address
    Output: Address
    Body: {
        IfCondition EqualTo(node, 0) ThenBlock: {
            ReturnValue(node)
        }
        
        t = AST_Type(node)
        
        // Literals and identifiers - return as-is
        IfCondition EqualTo(t, Node.NUM_LIT) ThenBlock: {
            ReturnValue(node)
        }
        IfCondition EqualTo(t, Node.STR_LIT) ThenBlock: {
            ReturnValue(node)
        }
        IfCondition EqualTo(t, Node.BOOL_LIT) ThenBlock: {
            ReturnValue(node)
        }
        IfCondition EqualTo(t, Node.IDENT) ThenBlock: {
            ReturnValue(node)
        }
        
        // CALL - flatten args, then extract to temp
        IfCondition EqualTo(t, Node.CALL) ThenBlock: {
            // Check if this is a packed function call
            call_name = ArrayGet(node, 3)
            is_packed = Gen_IsPackedFunc(call_name)
            
            IfCondition EqualTo(is_packed, 1) ThenBlock: {
                // Handle packed call - emit packing, then call
                args = ArrayGet(node, 4)
                n = XArray.XSize(args)
                
                // Flatten args first
                idx = 0
                WhileLoop LessThan(idx, n) {
                    arg = XArray.XGet(args, idx)
                    flat_arg = Gen_FlattenExpr(arg)
                    XArray.XSet(args, idx, flat_arg)
                    idx = Add(idx, 1)
                }
                
                // Create pack array
                pack_name = Gen_TempName()
                
                // Emit: pack = TArray.TCreate(n)
                Gen_EmitIndent()
                Gen_Emit(pack_name)
                Gen_Emit(" = TArray.TCreate(")
                n_str = NumberToString(n)
                Gen_Emit(n_str)
                Gen_Emit(")\n")
                Deallocate(n_str, 0)
                
                // Emit: TArray.TPush(pack, arg) for each arg
                idx = 0
                WhileLoop LessThan(idx, n) {
                    Gen_EmitIndent()
                    Gen_Emit("TArray.TPush(")
                    Gen_Emit(pack_name)
                    Gen_Emit(", ")
                    arg = XArray.XGet(args, idx)
                    Gen_Expr(arg)
                    Gen_Emit(")\n")
                    idx = Add(idx, 1)
                }
                
                // Emit: result = func(pack)
                result_temp = Gen_TempName()
                Gen_EmitIndent()
                Gen_Emit(result_temp)
                Gen_Emit(" = ")
                Gen_Emit(call_name)
                Gen_Emit("(")
                Gen_Emit(pack_name)
                Gen_Emit(")\n")
                
                // Mark result as string if call returns string
                is_str_call = Gen_InvolvesString(node)
                IfCondition EqualTo(is_str_call, 1) ThenBlock: {
                    Gen_MarkStringVar(result_temp)
                }
                
                ReturnValue(Gen_MakeIdent(result_temp))
            }
            
            // Normal call - flatten args, then extract to temp
            args = ArrayGet(node, 4)
            IfCondition NotEqual(args, 0) ThenBlock: {
                n = XArray.XSize(args)
                idx = 0
                WhileLoop LessThan(idx, n) {
                    arg = XArray.XGet(args, idx)
                    flat_arg = Gen_FlattenExpr(arg)
                    XArray.XSet(args, idx, flat_arg)
                    idx = Add(idx, 1)
                }
            }
            
            // Emit this call to a temp
            temp = Gen_TempName()
            Gen_EmitIndent()
            Gen_Emit(temp)
            Gen_Emit(" = ")
            Gen_CallExpr(node)
            Gen_Emit("\n")
            
            // Mark temp as string if call returns string
            is_str_call = Gen_InvolvesString(node)
            IfCondition EqualTo(is_str_call, 1) ThenBlock: {
                Gen_MarkStringVar(temp)
            }
            
            ReturnValue(Gen_MakeIdent(temp))
        }
        
        // METHOD_CALL - flatten object and args, then extract to temp
        IfCondition EqualTo(t, Node.METHOD_CALL) ThenBlock: {
            obj = ArrayGet(node, 3)
            flat_obj = Gen_FlattenExpr(obj)
            ArraySet(node, 3, flat_obj)
            
            args = ArrayGet(node, 5)
            IfCondition NotEqual(args, 0) ThenBlock: {
                n = XArray.XSize(args)
                idx = 0
                WhileLoop LessThan(idx, n) {
                    arg = XArray.XGet(args, idx)
                    flat_arg = Gen_FlattenExpr(arg)
                    XArray.XSet(args, idx, flat_arg)
                    idx = Add(idx, 1)
                }
            }
            
            temp = Gen_TempName()
            Gen_EmitIndent()
            Gen_Emit(temp)
            Gen_Emit(" = ")
            Gen_MethodCallExpr(node)
            Gen_Emit("\n")
            
            // Mark temp as string if method returns string
            method = ArrayGet(node, 4)
            is_str_method = 0
            cmp = StringCompare(method, "upper")
            IfCondition EqualTo(cmp, 0) ThenBlock: { is_str_method = 1 }
            cmp = StringCompare(method, "lower")
            IfCondition EqualTo(cmp, 0) ThenBlock: { is_str_method = 1 }
            cmp = StringCompare(method, "strip")
            IfCondition EqualTo(cmp, 0) ThenBlock: { is_str_method = 1 }
            cmp = StringCompare(method, "replace")
            IfCondition EqualTo(cmp, 0) ThenBlock: { is_str_method = 1 }
            cmp = StringCompare(method, "join")
            IfCondition EqualTo(cmp, 0) ThenBlock: { is_str_method = 1 }
            cmp = StringCompare(method, "split")
            IfCondition EqualTo(cmp, 0) ThenBlock: { is_str_method = 1 }
            
            IfCondition EqualTo(is_str_method, 1) ThenBlock: {
                Gen_MarkStringVar(temp)
            }
            
            ReturnValue(Gen_MakeIdent(temp))
        }
        
        // INDEX_ACCESS - handle negative indices, then flatten
        IfCondition EqualTo(t, Node.INDEX_ACCESS) ThenBlock: {
            expr = ArrayGet(node, 3)
            index = ArrayGet(node, 4)
            
            // Check if this is dict indexing
            expr_type = AST_Type(expr)
            is_dict_access = 0
            IfCondition EqualTo(expr_type, Node.IDENT) ThenBlock: {
                var_name = ArrayGet(expr, 3)
                is_dict_access = Gen_IsDictVar(var_name)
            }
            
            // DICT INDEXING
            IfCondition EqualTo(is_dict_access, 1) ThenBlock: {
                flat_expr = Gen_FlattenExpr(expr)
                flat_index = Gen_FlattenExpr(index)
                
                temp = Gen_TempName()
                Gen_EmitIndent()
                Gen_Emit(temp)
                Gen_Emit(" = THash.Get(")
                Gen_Expr(flat_expr)
                Gen_Emit(", ")
                Gen_Expr(flat_index)
                Gen_Emit(")\n")
                
                ReturnValue(Gen_MakeIdent(temp))
            }
            
            // Check if this is string indexing
            is_string_index = 0
            IfCondition EqualTo(expr_type, Node.IDENT) ThenBlock: {
                var_name = ArrayGet(expr, 3)
                is_string_index = Gen_IsStringVar(var_name)
            }
            IfCondition EqualTo(expr_type, Node.STR_LIT) ThenBlock: {
                is_string_index = 1
            }
            
            // Check for negative index (UNARY_OP with MINUS on NUM_LIT)
            index_type = AST_Type(index)
            is_negative = 0
            neg_value = 0
            
            IfCondition EqualTo(index_type, Node.UNARY_OP) ThenBlock: {
                op = ArrayGet(index, 3)
                IfCondition EqualTo(op, Token.MINUS) ThenBlock: {
                    operand = ArrayGet(index, 4)
                    operand_type = AST_Type(operand)
                    IfCondition EqualTo(operand_type, Node.NUM_LIT) ThenBlock: {
                        is_negative = 1
                        neg_value = ArrayGet(operand, 3)
                    }
                }
            }
            
            flat_expr = Gen_FlattenExpr(expr)
            
            // STRING INDEXING WITH NEGATIVE INDEX
            IfCondition And(EqualTo(is_string_index, 1), EqualTo(is_negative, 1)) ThenBlock: {
                len_temp = Gen_TempName()
                Gen_EmitIndent()
                Gen_Emit(len_temp)
                Gen_Emit(" = StringLength(")
                Gen_Expr(flat_expr)
                Gen_Emit(")\n")
                
                idx_temp = Gen_TempName()
                Gen_EmitIndent()
                Gen_Emit(idx_temp)
                Gen_Emit(" = Subtract(")
                Gen_Emit(len_temp)
                Gen_Emit(", ")
                Gen_EmitNumber(neg_value)
                Gen_Emit(")\n")
                
                result_temp = Gen_TempName()
                Gen_MarkStringVar(result_temp)
                Gen_EmitIndent()
                Gen_Emit(result_temp)
                Gen_Emit(" = AIMacro.Chr(GetByte(")
                Gen_Expr(flat_expr)
                Gen_Emit(", ")
                Gen_Emit(idx_temp)
                Gen_Emit("))\n")
                
                ReturnValue(Gen_MakeIdent(result_temp))
            }
            
            // STRING INDEXING WITH POSITIVE INDEX
            IfCondition And(EqualTo(is_string_index, 1), EqualTo(is_negative, 0)) ThenBlock: {
                flat_index = Gen_FlattenExpr(index)
                
                result_temp = Gen_TempName()
                Gen_MarkStringVar(result_temp)
                Gen_EmitIndent()
                Gen_Emit(result_temp)
                Gen_Emit(" = AIMacro.Chr(GetByte(")
                Gen_Expr(flat_expr)
                Gen_Emit(", ")
                Gen_Expr(flat_index)
                Gen_Emit("))\n")
                
                ReturnValue(Gen_MakeIdent(result_temp))
            }
            
            // LIST INDEXING WITH NEGATIVE INDEX
            IfCondition EqualTo(is_negative, 1) ThenBlock: {
                len_temp = Gen_TempName()
                Gen_EmitIndent()
                Gen_Emit(len_temp)
                Gen_Emit(" = AIMacro.SmartSize(")
                Gen_Expr(flat_expr)
                Gen_Emit(")\n")
                
                idx_temp = Gen_TempName()
                Gen_EmitIndent()
                Gen_Emit(idx_temp)
                Gen_Emit(" = Subtract(")
                Gen_Emit(len_temp)
                Gen_Emit(", ")
                Gen_EmitNumber(neg_value)
                Gen_Emit(")\n")
                
                result_temp = Gen_TempName()
                Gen_EmitIndent()
                Gen_Emit(result_temp)
                Gen_Emit(" = DictGen_SmartGet(")
                Gen_Expr(flat_expr)
                Gen_Emit(", ")
                Gen_Emit(idx_temp)
                Gen_Emit(")\n")
                
                ReturnValue(Gen_MakeIdent(result_temp))
            } ElseBlock: {
                // LIST INDEXING WITH POSITIVE INDEX
                flat_index = Gen_FlattenExpr(index)
                
                temp = Gen_TempName()
                Gen_EmitIndent()
                Gen_Emit(temp)
                Gen_Emit(" = DictGen_SmartGet(")
                Gen_Expr(flat_expr)
                Gen_Emit(", ")
                Gen_Expr(flat_index)
                Gen_Emit(")\n")
                
                ReturnValue(Gen_MakeIdent(temp))
            }
        }
        
        // BINARY_OP - flatten both sides, then ALWAYS extract to temp
        IfCondition EqualTo(t, Node.BINARY_OP) ThenBlock: {
            left = ArrayGet(node, 3)
            op = ArrayGet(node, 4)
            right = ArrayGet(node, 5)
            
            flat_left = Gen_FlattenExpr(left)
            flat_right = Gen_FlattenExpr(right)
            
            // Check if this is a string concat
            left_is_str = Gen_InvolvesString(flat_left)
            right_is_str = Gen_InvolvesString(flat_right)
            is_string_op = Or(EqualTo(left_is_str, 1), EqualTo(right_is_str, 1))
            
            IfCondition And(EqualTo(op, Token.PLUS), EqualTo(is_string_op, 1)) ThenBlock: {
                // String concat - extract to temp
                temp = Gen_TempName()
                Gen_MarkStringVar(temp)
                Gen_EmitIndent()
                Gen_Emit(temp)
                Gen_Emit(" = String.Concat(")
                Gen_Expr(flat_left)
                Gen_Emit(", ")
                Gen_Expr(flat_right)
                Gen_Emit(")\n")
                ReturnValue(Gen_MakeIdent(temp))
            }
            
            // String repeat
            IfCondition And(EqualTo(op, Token.STAR), EqualTo(left_is_str, 1)) ThenBlock: {
                temp = Gen_TempName()
                Gen_MarkStringVar(temp)
                Gen_EmitIndent()
                Gen_Emit(temp)
                Gen_Emit(" = String.Repeat(")
                Gen_Expr(flat_left)
                Gen_Emit(", ")
                Gen_Expr(flat_right)
                Gen_Emit(")\n")
                ReturnValue(Gen_MakeIdent(temp))
            }

            // =========== NEW: STRING EQUALITY (== operator) ===========
            IfCondition EqualTo(op, Token.EQ) ThenBlock: {
                IfCondition EqualTo(is_string_op, 1) ThenBlock: {
                    temp = Gen_TempName()
                    Gen_EmitIndent()
                    Gen_Emit(temp)
                    Gen_Emit(" = EqualTo(StringCompare(")
                    Gen_Expr(flat_left)
                    Gen_Emit(", ")
                    Gen_Expr(flat_right)
                    Gen_Emit("), 0)\n")
                    ReturnValue(Gen_MakeIdent(temp))
                }
            }
            
            // =========== NEW: STRING INEQUALITY (!= operator) ===========
            IfCondition EqualTo(op, Token.NE) ThenBlock: {
                IfCondition EqualTo(is_string_op, 1) ThenBlock: {
                    temp = Gen_TempName()
                    Gen_EmitIndent()
                    Gen_Emit(temp)
                    Gen_Emit(" = NotEqual(StringCompare(")
                    Gen_Expr(flat_left)
                    Gen_Emit(", ")
                    Gen_Expr(flat_right)
                    Gen_Emit("), 0)\n")
                    ReturnValue(Gen_MakeIdent(temp))
                }
            }
            // =========== END NEW SECTIONS ===========
                    
            // ALL OTHER BINARY OPS - extract to temp
            temp = Gen_TempName()
            op_name = Gen_OpName(op)
            Gen_EmitIndent()
            Gen_Emit(temp)
            Gen_Emit(" = ")
            Gen_Emit(op_name)
            Gen_Emit("(")
            Gen_Expr(flat_left)
            Gen_Emit(", ")
            Gen_Expr(flat_right)
            Gen_Emit(")\n")
            
            ReturnValue(Gen_MakeIdent(temp))
        }
        
        // UNARY_OP - flatten operand, then extract to temp
        IfCondition EqualTo(t, Node.UNARY_OP) ThenBlock: {
            op = ArrayGet(node, 3)
            operand = ArrayGet(node, 4)
            flat_operand = Gen_FlattenExpr(operand)
            
            temp = Gen_TempName()
            Gen_EmitIndent()
            Gen_Emit(temp)
            Gen_Emit(" = ")
            
            IfCondition EqualTo(op, Token.NOT) ThenBlock: {
                Gen_Emit("Not(")
                Gen_Expr(flat_operand)
                Gen_Emit(")")
            } ElseBlock: {
                IfCondition EqualTo(op, Token.MINUS) ThenBlock: {
                    Gen_Emit("Subtract(0, ")
                    Gen_Expr(flat_operand)
                    Gen_Emit(")")
                }
            }
            Gen_Emit("\n")
            
            ReturnValue(Gen_MakeIdent(temp))
        }
        
        // LIST_LIT - create as temp
        IfCondition EqualTo(t, Node.LIST_LIT) ThenBlock: {
            ReturnValue(Gen_CreateListLiteral(node))
        }
        
        // Default - return as-is
        ReturnValue(node)
    }
}

// =============================================================================
// FLATTEN CALL ARGUMENTS (for CALL nodes)
// =============================================================================
Function.Gen_FlattenCallArgs {
    Input: node: Address
    Body: {
        args = ArrayGet(node, 4)
        IfCondition EqualTo(args, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        n = XArray.XSize(args)
        idx = 0
        WhileLoop LessThan(idx, n) {
            arg = XArray.XGet(args, idx)
            arg_type = AST_Type(arg)
            
            // Handle inline list literals
            IfCondition EqualTo(arg_type, Node.LIST_LIT) ThenBlock: {
                list_ident = Gen_CreateListLiteral(arg)
                XArray.XSet(args, idx, list_ident)
                idx = Add(idx, 1)
                ContinueLoop
            }
            
            // Flatten any argument with nested calls
            has_call = Gen_HasCall(arg)
            IfCondition EqualTo(has_call, 1) ThenBlock: {
                flat_arg = Gen_FlattenExpr(arg)
                XArray.XSet(args, idx, flat_arg)
            }
            
            idx = Add(idx, 1)
        }
    }
}

// =============================================================================
// FLATTEN METHOD CALL ARGUMENTS
// =============================================================================
Function.Gen_FlattenMethodArgs {
    Input: node: Address
    Body: {
        // Flatten object if needed
        obj = ArrayGet(node, 3)
        obj_type = AST_Type(obj)
        IfCondition Or(EqualTo(obj_type, Node.CALL), Or(EqualTo(obj_type, Node.METHOD_CALL), EqualTo(obj_type, Node.INDEX_ACCESS))) ThenBlock: {
            flat_obj = Gen_FlattenExpr(obj)
            ArraySet(node, 3, flat_obj)
        }
        
        // Flatten arguments
        args = ArrayGet(node, 5)
        IfCondition EqualTo(args, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        n = XArray.XSize(args)
        idx = 0
        WhileLoop LessThan(idx, n) {
            arg = XArray.XGet(args, idx)
            arg_type = AST_Type(arg)
            
            // Handle inline list literals
            IfCondition EqualTo(arg_type, Node.LIST_LIT) ThenBlock: {
                list_ident = Gen_CreateListLiteral(arg)
                XArray.XSet(args, idx, list_ident)
                idx = Add(idx, 1)
                ContinueLoop
            }
            
            // Flatten any argument with nested calls
            has_call = Gen_HasCall(arg)
            IfCondition EqualTo(has_call, 1) ThenBlock: {
                flat_arg = Gen_FlattenExpr(arg)
                XArray.XSet(args, idx, flat_arg)
            }
            
            idx = Add(idx, 1)
        }
    }
}

// =============================================================================
// CREATE LIST LITERAL AS TEMP VARIABLE
// =============================================================================
Function.Gen_CreateListLiteral {
    Input: list_node: Address
    Output: Address
    Body: {
        elems = ArrayGet(list_node, 3)
        n = XArray.XSize(elems)
        
        // Create temp for the list - USE TArray for user lists
        temp = Gen_TempName()
        
        // Emit: temp = TArray.TCreate(n)
        Gen_EmitIndent()
        Gen_Emit(temp)
        Gen_Emit(" = TArray.TCreate(")
        Gen_EmitNumber(n)
        Gen_Emit(")\n")
        
        // Emit pushes for each element
        i = 0
        WhileLoop LessThan(i, n) {
            elem = XArray.XGet(elems, i)
            
            // Flatten element if needed
            has_call = Gen_HasCall(elem)
            IfCondition EqualTo(has_call, 1) ThenBlock: {
                elem = Gen_FlattenExpr(elem)
            }
            
            Gen_EmitIndent()
            Gen_Emit("TArray.TPush(")
            Gen_Emit(temp)
            Gen_Emit(", ")
            Gen_Expr(elem)
            Gen_Emit(")\n")
            
            i = Add(i, 1)
        }
        
        // Return identifier node for the temp
        ReturnValue(Gen_MakeIdent(temp))
    }
}
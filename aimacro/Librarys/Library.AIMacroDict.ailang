// Library.AIMacroDict.ailang
// Runtime Dict Operations for AIMacro
// Provides Python-compatible dict methods that require complex logic
//
// Usage: LibraryImport.AIMacroDict

LibraryImport.THash
LibraryImport.TArrays

// =============================================================================
// GET WITH DEFAULT
// Python: d.get(key, default)
// Returns value if key exists, otherwise returns default
// =============================================================================
Function.DictGen_GetWithDefault {
    Input: dict: Address
    Input: key: Address
    Input: default_val: Integer
    Output: Integer
    Body: {
        // Check if key exists
        exists = THash.Contains(dict, key)
        IfCondition EqualTo(exists, 1) ThenBlock: {
            ReturnValue(THash.Get(dict, key))
        }
        ReturnValue(default_val)
    }
}

// =============================================================================
// POP
// Python: d.pop(key) - removes and returns value
// Raises KeyError if not found (we return 0)
// =============================================================================
Function.DictGen_Pop {
    Input: dict: Address
    Input: key: Address
    Output: Integer
    Body: {
        // Get value first
        value = THash.Get(dict, key)
        // Delete the key
        THash.Delete(dict, key)
        ReturnValue(value)
    }
}

// =============================================================================
// POP WITH DEFAULT
// Python: d.pop(key, default)
// =============================================================================
Function.DictGen_PopDefault {
    Input: dict: Address
    Input: key: Address
    Input: default_val: Integer
    Output: Integer
    Body: {
        exists = THash.Contains(dict, key)
        IfCondition EqualTo(exists, 1) ThenBlock: {
            value = THash.Get(dict, key)
            THash.Delete(dict, key)
            ReturnValue(value)
        }
        ReturnValue(default_val)
    }
}

// =============================================================================
// SETDEFAULT
// Python: d.setdefault(key, default)
// If key exists, return its value
// If key doesn't exist, set it to default and return default
// =============================================================================
Function.DictGen_SetDefault {
    Input: dict: Address
    Input: key: Address
    Input: default_val: Integer
    Output: Integer
    Body: {
        exists = THash.Contains(dict, key)
        IfCondition EqualTo(exists, 1) ThenBlock: {
            ReturnValue(THash.Get(dict, key))
        }
        THash.Set(dict, key, default_val)
        ReturnValue(default_val)
    }
}

// =============================================================================
// UPDATE
// Python: d.update(other)
// Copy all key-value pairs from other into d
// =============================================================================
Function.DictGen_Update {
    Input: dict: Address
    Input: other: Address
    Body: {
        // Get items from other dict
        items = THash.Items(other)
        n = TArray.TSize(items)
        
        i = 0
        WhileLoop LessThan(i, n) {
            pair = TArray.TGet(items, i)
            key = TArray.TGet(pair, 0)
            value = TArray.TGet(pair, 1)
            THash.Set(dict, key, value)
            i = Add(i, 1)
        }
        
        // Note: items TArray should be freed, but we don't have GC
        // In production, would need to destroy it
    }
}

// =============================================================================
// COPY
// Python: d.copy()
// Returns shallow copy of dictionary
// =============================================================================
Function.DictGen_Copy {
    Input: dict: Address
    Output: Address
    Body: {
        // Get size for capacity hint
        size = THash.Size(dict)
        capacity = Multiply(size, 2)
        IfCondition LessThan(capacity, 16) ThenBlock: {
            capacity = 16
        }
        
        // Create new dict
        new_dict = THash.Create(capacity)
        
        // Copy all items
        items = THash.Items(dict)
        n = TArray.TSize(items)
        
        i = 0
        WhileLoop LessThan(i, n) {
            pair = TArray.TGet(items, i)
            key = TArray.TGet(pair, 0)
            value = TArray.TGet(pair, 1)
            THash.Set(new_dict, key, value)
            i = Add(i, 1)
        }
        
        ReturnValue(new_dict)
    }
}

// =============================================================================
// FROMKEYS
// Python: dict.fromkeys(keys, value)
// Creates new dict with keys from iterable, all set to value
// =============================================================================
Function.DictGen_FromKeys {
    Input: keys: Address
    Input: value: Integer
    Output: Address
    Body: {
        n = TArray.TSize(keys)
        capacity = Multiply(n, 2)
        IfCondition LessThan(capacity, 16) ThenBlock: {
            capacity = 16
        }
        
        new_dict = THash.Create(capacity)
        
        i = 0
        WhileLoop LessThan(i, n) {
            key = TArray.TGet(keys, i)
            THash.Set(new_dict, key, value)
            i = Add(i, 1)
        }
        
        ReturnValue(new_dict)
    }
}

// =============================================================================
// SMART LEN FOR DICT
// Works with both THash and TArray for polymorphic len()
// =============================================================================
Function.DictGen_SmartLen {
    Input: container: Address
    Output: Integer
    Body: {
        IfCondition EqualTo(container, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        // Check if it's a THash
        is_hash = THash.IsHash(container)
        IfCondition EqualTo(is_hash, 1) ThenBlock: {
            ReturnValue(THash.Size(container))
        }
        
        // Check if it's a TArray
        is_array = TArray.TIsArray(container)
        IfCondition EqualTo(is_array, 1) ThenBlock: {
            ReturnValue(TArray.TSize(container))
        }
        
        // Assume it's a string
        ReturnValue(StringLength(container))
    }
}

// =============================================================================
// SMART CONTAINS
// Works with dict (key in dict) and list (item in list)
// =============================================================================
Function.DictGen_SmartContains {
    Input: container: Address
    Input: item: Address
    Output: Integer
    Body: {
        IfCondition EqualTo(container, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        // Check if it's a THash - use Contains
        is_hash = THash.IsHash(container)
        IfCondition EqualTo(is_hash, 1) ThenBlock: {
            ReturnValue(THash.Contains(container, item))
        }
        
        // Check if it's a TArray - use TContains
        is_array = TArray.TIsArray(container)
        IfCondition EqualTo(is_array, 1) ThenBlock: {
            ReturnValue(TArray.TContains(container, item))
        }
        
        // For strings, use StringIndexOf
        found = StringIndexOf(container, item, 0)
        IfCondition GreaterEqual(found, 0) ThenBlock: {
            ReturnValue(1)
        }
        ReturnValue(0)
    }
}

// =============================================================================
// TYPE CHECKING - Check if value is a dict
// =============================================================================
Function.DictGen_IsDict {
    Input: value: Address
    Output: Integer
    Body: {
        ReturnValue(THash.IsHash(value))
    }
}


// =============================================================================
// SMART GET - Runtime dispatch for dict/list access
// Handles both THash (dict) and TArray (list) containers
// =============================================================================
Function.DictGen_SmartGet {
    Input: container: Address
    Input: key: Address
    Output: Integer
    Body: {
        IfCondition EqualTo(container, 0) ThenBlock: {
            ReturnValue(-999999)
        }
        
        // Check if it's a THash (dict)
        is_hash = THash.IsHash(container)
        IfCondition EqualTo(is_hash, 1) ThenBlock: {
            ReturnValue(THash.Get(container, key))
        }
        
        // Check if it's a TArray (list)
        is_array = TArray.TIsArray(container)
        IfCondition EqualTo(is_array, 1) ThenBlock: {
            // Key should be an integer index
            ReturnValue(TArray.TGet(container, key))
        }
        
        // Fallback: try XArray
        ReturnValue(XArray.XGet(container, key))
    }
}

// =============================================================================
// SMART SET - Runtime dispatch for dict/list assignment
// Handles both THash (dict) and TArray (list) containers
// =============================================================================
Function.DictGen_SmartSet {
    Input: container: Address
    Input: key: Address
    Input: value: Integer
    Body: {
        IfCondition EqualTo(container, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        // Check if it's a THash (dict)
        is_hash = THash.IsHash(container)
        IfCondition EqualTo(is_hash, 1) ThenBlock: {
            THash.Set(container, key, value)
            ReturnValue(0)
        }
        
        // Check if it's a TArray (list)
        is_array = TArray.TIsArray(container)
        IfCondition EqualTo(is_array, 1) ThenBlock: {
            TArray.TSet(container, key, value)
            ReturnValue(0)
        }
        
        // Fallback: try XArray
        XArray.XSet(container, key, value)
    }
}

// =============================================================================
// SMART LEN - Runtime dispatch for len()
// Handles THash, TArray, XArray, and strings
// =============================================================================
Function.DictGen_SmartLen {
    Input: container: Address
    Output: Integer
    Body: {
        IfCondition EqualTo(container, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        // Check if it's a THash
        is_hash = THash.IsHash(container)
        IfCondition EqualTo(is_hash, 1) ThenBlock: {
            ReturnValue(THash.Size(container))
        }
        
        // Check if it's a TArray
        is_array = TArray.TIsArray(container)
        IfCondition EqualTo(is_array, 1) ThenBlock: {
            ReturnValue(TArray.TSize(container))
        }
        
        // Assume it's a string
        ReturnValue(StringLength(container))
    }
}

// =============================================================================
// LIBRARY INITIALIZATION
// =============================================================================
SubRoutine.InitializeAIMacroDictLibrary {
    PrintMessage("AIMacroDict Runtime Library Loaded\n")
}

RunTask(InitializeAIMacroDictLibrary)
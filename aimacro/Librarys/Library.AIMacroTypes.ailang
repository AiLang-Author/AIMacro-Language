// Library.AIMacroTypes.ailang
// Type checking functions for AIMacro
// Works with TArrays (typed arrays) for bulletproof list detection
// 
// Usage: LibraryImport.AIMacroTypes

LibraryImport.TArrays

// =============================================================================
// TYPE IDS - Use these with isinstance()
// =============================================================================
FixedPool.TypeID {
    "UNKNOWN": Initialize=0
    "INT": Initialize=1
    "STR": Initialize=2
    "LIST": Initialize=3
    "DICT": Initialize=4
    "BOOL": Initialize=5
    "NONE": Initialize=6
}

// =============================================================================
// MAGIC NUMBERS - Must match library implementations
// =============================================================================
FixedPool.TypeMagic {
    "TARRAY": Initialize=6022087695    
    "XARRAY": Initialize=0            
    "TSHASH": Initialize=7133198806    
    "HEAP_START": Initialize=1000000   
}

// =============================================================================
// ISLIST - Check if value is a TArray (typed list)
// Returns 1 if valid TArray, 0 otherwise
// =============================================================================
Function.Types.IsList {
    Input: value: Address
    Output: Integer
    Body: {
        // Use TArray's built-in check
        ReturnValue(TArray.TIsArray(value))
    }
}

// =============================================================================
// ISSTRING - Check if value is a string
// Strings are heap addresses that aren't TArrays and contain printable ASCII
// =============================================================================
Function.Types.IsString {
    Input: value: Address
    Output: Integer
    Body: {
        // Null is not a string
        IfCondition EqualTo(value, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        // Must be a heap address
        IfCondition LessThan(value, TypeMagic.HEAP_START) ThenBlock: {
            ReturnValue(0)
        }
        
        // Check it's NOT a TArray (lists have magic numbers)
        is_list = TArray.TIsArray(value)
        IfCondition EqualTo(is_list, 1) ThenBlock: {
            ReturnValue(0)
        }
        
        // Check first byte for string characteristics
        first = GetByte(value, 0)
        
        // Empty string (null terminator)
        IfCondition EqualTo(first, 0) ThenBlock: {
            ReturnValue(1)
        }
        
        // Printable ASCII (space through tilde)
        IfCondition And(GreaterEqual(first, 32), LessEqual(first, 126)) ThenBlock: {
            ReturnValue(1)
        }
        
        // Common whitespace
        IfCondition EqualTo(first, 9) ThenBlock: { ReturnValue(1) }   // Tab
        IfCondition EqualTo(first, 10) ThenBlock: { ReturnValue(1) }  // Newline
        IfCondition EqualTo(first, 13) ThenBlock: { ReturnValue(1) }  // CR
        
        ReturnValue(0)
    }
}

// =============================================================================
// ISINT - Check if value is an integer (not a heap address)
// =============================================================================
Function.Types.IsInt {
    Input: value: Address
    Output: Integer
    Body: {
        // Negative numbers are always integers
        IfCondition LessThan(value, 0) ThenBlock: {
            ReturnValue(1)
        }
        
        // Small positive numbers are integers
        IfCondition LessThan(value, TypeMagic.HEAP_START) ThenBlock: {
            ReturnValue(1)
        }
        
        // Large positive - check if it's a known heap structure
        is_list = TArray.TIsArray(value)
        IfCondition EqualTo(is_list, 1) ThenBlock: {
            ReturnValue(0)
        }
        
        // Check if it looks like a string
        first = GetByte(value, 0)
        IfCondition EqualTo(first, 0) ThenBlock: {
            ReturnValue(0)  // Empty string
        }
        IfCondition And(GreaterEqual(first, 32), LessEqual(first, 126)) ThenBlock: {
            ReturnValue(0)  // Printable = string
        }
        
        // Doesn't look like string or list - probably large integer
        ReturnValue(1)
    }
}

// =============================================================================
// ISNONE - Check if value is None (0)
// =============================================================================
Function.Types.IsNone {
    Input: value: Address
    Output: Integer
    Body: {
        IfCondition EqualTo(value, 0) ThenBlock: {
            ReturnValue(1)
        }
        ReturnValue(0)
    }
}

// =============================================================================
// ISBOOL - Check if value is boolean (0 or 1)
// Note: This overlaps with integers, use with care
// =============================================================================
Function.Types.IsBool {
    Input: value: Address
    Output: Integer
    Body: {
        IfCondition EqualTo(value, 0) ThenBlock: {
            ReturnValue(1)
        }
        IfCondition EqualTo(value, 1) ThenBlock: {
            ReturnValue(1)
        }
        ReturnValue(0)
    }
}

// =============================================================================
// ISDICT - Check if value is a typed hash table
// (Placeholder - implement when THash library is created)
// =============================================================================
Function.Types.IsDict {
    Input: value: Address
    Output: Integer
    Body: {
        // For now, no bulletproof dict detection
        // Would need a THash library with magic numbers
        ReturnValue(0)
    }
}

// =============================================================================
// ISINSTANCE - Main type checking function
// Usage: isinstance(value, type_id)
// Returns: 1 if type matches, 0 otherwise
// =============================================================================
Function.Types.IsInstance {
    Input: value: Address
    Input: type_id: Integer
    Output: Integer
    Body: {
        IfCondition EqualTo(type_id, TypeID.NONE) ThenBlock: {
            ReturnValue(Types.IsNone(value))
        }
        
        IfCondition EqualTo(type_id, TypeID.BOOL) ThenBlock: {
            ReturnValue(Types.IsBool(value))
        }
        
        IfCondition EqualTo(type_id, TypeID.INT) ThenBlock: {
            ReturnValue(Types.IsInt(value))
        }
        
        IfCondition EqualTo(type_id, TypeID.STR) ThenBlock: {
            ReturnValue(Types.IsString(value))
        }
        
        IfCondition EqualTo(type_id, TypeID.LIST) ThenBlock: {
            ReturnValue(Types.IsList(value))
        }
        
        IfCondition EqualTo(type_id, TypeID.DICT) ThenBlock: {
            ReturnValue(Types.IsDict(value))
        }
        
        // Unknown type ID
        ReturnValue(0)
    }
}

// =============================================================================
// TYPEOF - Return the type ID of a value
// =============================================================================
Function.Types.TypeOf {
    Input: value: Address
    Output: Integer
    Body: {
        // None first
        IfCondition EqualTo(value, 0) ThenBlock: {
            ReturnValue(TypeID.NONE)
        }
        
        // Small integers
        IfCondition LessThan(value, TypeMagic.HEAP_START) ThenBlock: {
            ReturnValue(TypeID.INT)
        }
        
        // Check for TArray (list)
        is_list = TArray.TIsArray(value)
        IfCondition EqualTo(is_list, 1) ThenBlock: {
            ReturnValue(TypeID.LIST)
        }
        
        // Check for string
        first = GetByte(value, 0)
        IfCondition EqualTo(first, 0) ThenBlock: {
            ReturnValue(TypeID.STR)
        }
        IfCondition And(GreaterEqual(first, 32), LessEqual(first, 126)) ThenBlock: {
            ReturnValue(TypeID.STR)
        }
        IfCondition Or(EqualTo(first, 9), Or(EqualTo(first, 10), EqualTo(first, 13))) ThenBlock: {
            ReturnValue(TypeID.STR)
        }
        
        // Unknown heap object - default to int (large number)
        ReturnValue(TypeID.INT)
    }
}

// =============================================================================
// TYPENAME - Get string name of type
// =============================================================================
Function.Types.TypeName {
    Input: type_id: Integer
    Output: Address
    Body: {
        IfCondition EqualTo(type_id, TypeID.UNKNOWN) ThenBlock: { ReturnValue("unknown") }
        IfCondition EqualTo(type_id, TypeID.INT) ThenBlock: { ReturnValue("int") }
        IfCondition EqualTo(type_id, TypeID.STR) ThenBlock: { ReturnValue("str") }
        IfCondition EqualTo(type_id, TypeID.LIST) ThenBlock: { ReturnValue("list") }
        IfCondition EqualTo(type_id, TypeID.DICT) ThenBlock: { ReturnValue("dict") }
        IfCondition EqualTo(type_id, TypeID.BOOL) ThenBlock: { ReturnValue("bool") }
        IfCondition EqualTo(type_id, TypeID.NONE) ThenBlock: { ReturnValue("NoneType") }
        ReturnValue("unknown")
    }
}

// =============================================================================
// ASSERT_TYPE - Debug helper: assert a value has expected type
// =============================================================================
Function.Types.AssertType {
    Input: value: Address
    Input: expected_type: Integer
    Input: var_name: Address
    Body: {
        actual_type = Types.TypeOf(value)
        IfCondition NotEqual(actual_type, expected_type) ThenBlock: {
            PrintMessage("TYPE ERROR: ")
            PrintString(var_name)
            PrintMessage(" expected ")
            PrintString(Types.TypeName(expected_type))
            PrintMessage(" but got ")
            PrintString(Types.TypeName(actual_type))
            PrintMessage("\n")
        }
    }
}

// =============================================================================
// LIBRARY INITIALIZATION
// =============================================================================
SubRoutine.InitializeAIMacroTypesLibrary {
    PrintMessage("AIMacroTypes Library Loaded\n")
}

RunTask(InitializeAIMacroTypesLibrary)
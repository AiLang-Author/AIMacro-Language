// Library.AIMacroCodeGenOOP.ailang
// OOP Code Generation for AIMacro Transpiler
// Handles Python class syntax -> Library.OOP calls
//
// Dependencies: XArrays, AIMacroCore, AIMacroParserCore, AIMacroCodeGen1

LibraryImport.XArrays
LibraryImport.AIMacroCore
LibraryImport.AIMacroParserCore
LibraryImport.AIMacroCodeGen1

// =============================================================================
// STATE MANAGEMENT
// =============================================================================

FixedPool.OOPGen {
    "initialized": Initialize=0
    "classes": Initialize=0            
    "current_class": Initialize=0       
    "current_method": Initialize=0      
    "discovered_fields": Initialize=0    
    "class_init_code": Initialize=0      
    "method_impl_code": Initialize=0    
    "temp_counter": Initialize=0        
    "has_classes": Initialize=0         
}


// =============================================================================
// REGISTER CLASS NAMES PRESCAN
// =============================================================================

Function.OOPGen_RegisterClassName {
    Input: name: Address
    Body: {
        OOPGen_Init()
        
        // Create a minimal class info entry with just the name
        class_info = XArray.XCreate(4)
        XArray.XPush(class_info, name)    // [0] = class name
        XArray.XPush(class_info, 0)       // [1] = parent (placeholder)
        XArray.XPush(class_info, 0)       // [2] = fields (placeholder)
        XArray.XPush(class_info, 0)       // [3] = methods (placeholder)
        
        XArray.XPush(OOPGen.classes, class_info)
    }
}

// =============================================================================
// INITIALIZATION
// =============================================================================

Function.OOPGen_Init {
    Body: {
        IfCondition EqualTo(OOPGen.initialized, 1) ThenBlock: {
            ReturnValue(0)
        }
        
        OOPGen.classes = XArray.XCreate(32)
        OOPGen.discovered_fields = XArray.XCreate(16)
        OOPGen.class_init_code = XArray.XCreate(128)
        OOPGen.method_impl_code = XArray.XCreate(256)
        OOPGen.temp_counter = 0
        OOPGen.has_classes = 0
        OOPGen.initialized = 1
        
        ReturnValue(1)
    }
}

Function.OOPGen_Reset {
    Body: {
        // Only reset if initialized
        IfCondition EqualTo(OOPGen.initialized, 1) ThenBlock: {
            // Clear class list
            IfCondition NotEqual(OOPGen.classes, 0) ThenBlock: {
                XArray.XClear(OOPGen.classes)
            }
            
            // Clear class init code
            IfCondition NotEqual(OOPGen.class_init_code, 0) ThenBlock: {
                XArray.XClear(OOPGen.class_init_code)
            }
            
            // Clear discovered fields
            IfCondition NotEqual(OOPGen.discovered_fields, 0) ThenBlock: {
                XArray.XClear(OOPGen.discovered_fields)
            }
            
            // Reset flags
            OOPGen.has_classes = 0
            OOPGen.current_class = 0
            OOPGen.current_method = 0
            OOPGen.temp_counter = 0
        }
    }
}

Function.OOPGen_Free {
    Body: {
        IfCondition NotEqual(OOPGen.classes, 0) ThenBlock: {
            XArray.XDestroy(OOPGen.classes)
            OOPGen.classes = 0
        }
        IfCondition NotEqual(OOPGen.discovered_fields, 0) ThenBlock: {
            XArray.XDestroy(OOPGen.discovered_fields)
            OOPGen.discovered_fields = 0
        }
        IfCondition NotEqual(OOPGen.class_init_code, 0) ThenBlock: {
            XArray.XDestroy(OOPGen.class_init_code)
            OOPGen.class_init_code = 0
        }
        IfCondition NotEqual(OOPGen.method_impl_code, 0) ThenBlock: {
            XArray.XDestroy(OOPGen.method_impl_code)
            OOPGen.method_impl_code = 0
        }
        OOPGen.initialized = 0
    }
}


// =============================================================================
// FLATTEN OOP EXPRESSIONS (extracts to temp variables)
// =============================================================================

Function.OOPGen_FlattenExpr {
    Input: node: Address
    Output: Address
    Body: {
        IfCondition EqualTo(node, 0) ThenBlock: {
            ReturnValue(node)
        }
        
        node_type = AST_Type(node)
        
        // Literals and identifiers - return as-is
        IfCondition EqualTo(node_type, Node.NUM_LIT) ThenBlock: {
            ReturnValue(node)
        }
        IfCondition EqualTo(node_type, Node.STR_LIT) ThenBlock: {
            ReturnValue(node)
        }
        IfCondition EqualTo(node_type, Node.BOOL_LIT) ThenBlock: {
            ReturnValue(node)
        }
        IfCondition EqualTo(node_type, Node.IDENT) ThenBlock: {
            ReturnValue(node)
        }
        
        // ATTRIBUTE: obj.attr -> temp = OOP.ObjectGet(obj, "attr")
        IfCondition EqualTo(node_type, Node.ATTRIBUTE) ThenBlock: {
            obj = AST_GetField(node, "object")
            attr = AST_GetField(node, "attr")
            
            // Flatten the object first if needed
            obj = OOPGen_FlattenExpr(obj)
            
            temp = Gen_TempName()
            Gen_EmitIndent()
            Gen_Emit(temp)
            Gen_Emit(" = OOP.ObjectGet(")
            OOPGen_Expr(obj)
            Gen_Emit(", \"")
            Gen_Emit(attr)
            Gen_Emit("\")\n")
            
            ReturnValue(Gen_MakeIdent(temp))
        }
        
        // METHOD_CALL: obj.method(args) -> temp = OOP.MethodCall(...)
        IfCondition EqualTo(node_type, Node.METHOD_CALL) ThenBlock: {
            obj = AST_GetField(node, "object")
            method = AST_GetField(node, "method")
            args = AST_GetField(node, "args")
            
            // Flatten object
            obj = OOPGen_FlattenExpr(obj)
            
            num_args = XArray.XSize(args)
            
            // Generate args array
            args_var = OOPGen_TempVar("args")
            
            Gen_EmitIndent()
            Gen_Emit(args_var)
            Gen_Emit(" = TArray.TCreate(")
            Gen_EmitNumber(num_args)
            Gen_Emit(")\n")
            
            // Push each argument (flattened)
            i = 0
            WhileLoop LessThan(i, num_args) {
                arg = XArray.XGet(args, i)
                arg = OOPGen_FlattenExpr(arg)
                
                Gen_EmitIndent()
                Gen_Emit("TArray.TPush(")
                Gen_Emit(args_var)
                Gen_Emit(", ")
                OOPGen_Expr(arg)
                Gen_Emit(")\n")
                
                i = Add(i, 1)
            }
            
            // Emit method call to temp
            temp = Gen_TempName()
            Gen_EmitIndent()
            Gen_Emit(temp)
            Gen_Emit(" = OOP.MethodCall(")
            OOPGen_Expr(obj)
            Gen_Emit(", \"")
            Gen_Emit(method)
            Gen_Emit("\", ")
            Gen_Emit(args_var)
            Gen_Emit(")\n")
            
            // Cleanup args
            Gen_EmitIndent()
            Gen_Emit("TArray.TDestroy(")
            Gen_Emit(args_var)
            Gen_Emit(")\n")
            
            ReturnValue(Gen_MakeIdent(temp))
        }
        
        // BINARY_OP - flatten both sides
        IfCondition EqualTo(node_type, Node.BINARY_OP) ThenBlock: {
            left = ArrayGet(node, 3)
            op = ArrayGet(node, 4)
            right = ArrayGet(node, 5)
            
            flat_left = OOPGen_FlattenExpr(left)
            flat_right = OOPGen_FlattenExpr(right)
            
            temp = Gen_TempName()
            Gen_EmitIndent()
            Gen_Emit(temp)
            Gen_Emit(" = ")
            Gen_Emit(Gen_OpName(op))
            Gen_Emit("(")
            OOPGen_Expr(flat_left)
            Gen_Emit(", ")
            OOPGen_Expr(flat_right)
            Gen_Emit(")\n")
            
            ReturnValue(Gen_MakeIdent(temp))
        }
        
        // CALL - use standard flattening
        IfCondition EqualTo(node_type, Node.CALL) ThenBlock: {
            ReturnValue(Gen_FlattenExpr(node))
        }
        
        // Default - return as-is
        ReturnValue(node)
    }
}


// =============================================================================
// TEMP VARIABLE GENERATION
// =============================================================================

Function.OOPGen_TempVar {
    Input: prefix: Address
    Output: Address
    Body: {
        // Generate: __oop_prefix_N
        result = StringConcat("__oop_", prefix)
        result = StringConcat(result, "_")
        num_str = NumberToString(OOPGen.temp_counter)
        result = StringConcat(result, num_str)
        OOPGen.temp_counter = Add(OOPGen.temp_counter, 1)
        Deallocate(num_str, 0)
        ReturnValue(result)
    }
}

// =============================================================================
// TYPE MAPPING
// =============================================================================

Function.OOPGen_MapType {
    Input: py_type: Address
    Output: Address
    Body: {
        IfCondition EqualTo(py_type, 0) ThenBlock: {
            ReturnValue("Address")
        }
        
        cmp = StringCompare(py_type, "int")
        IfCondition EqualTo(cmp, 0) ThenBlock: {
            ReturnValue("Integer")
        }
        
        cmp = StringCompare(py_type, "str")
        IfCondition EqualTo(cmp, 0) ThenBlock: {
            ReturnValue("Address")
        }
        
        cmp = StringCompare(py_type, "list")
        IfCondition EqualTo(cmp, 0) ThenBlock: {
            ReturnValue("Address")
        }
        
        cmp = StringCompare(py_type, "dict")
        IfCondition EqualTo(cmp, 0) ThenBlock: {
            ReturnValue("Address")
        }
        
        cmp = StringCompare(py_type, "bool")
        IfCondition EqualTo(cmp, 0) ThenBlock: {
            ReturnValue("Integer")
        }
        
        cmp = StringCompare(py_type, "None")
        IfCondition EqualTo(cmp, 0) ThenBlock: {
            ReturnValue("Integer")
        }
        
        // Default for unknown/custom types
        ReturnValue("Address")
    }
}

Function.OOPGen_MapFieldType {
    Input: py_type: Address
    Output: Address
    Body: {
        IfCondition EqualTo(py_type, 0) ThenBlock: {
            ReturnValue("Address")
        }
        
        cmp = StringCompare(py_type, "int")
        IfCondition EqualTo(cmp, 0) ThenBlock: {
            ReturnValue("Integer")
        }
        
        cmp = StringCompare(py_type, "Integer")
        IfCondition EqualTo(cmp, 0) ThenBlock: {
            ReturnValue("Integer")
        }
        
        cmp = StringCompare(py_type, "str")
        IfCondition EqualTo(cmp, 0) ThenBlock: {
            ReturnValue("String")
        }
        
        cmp = StringCompare(py_type, "String")
        IfCondition EqualTo(cmp, 0) ThenBlock: {
            ReturnValue("String")
        }
        
        cmp = StringCompare(py_type, "list")
        IfCondition EqualTo(cmp, 0) ThenBlock: {
            ReturnValue("Array")
        }
        
        cmp = StringCompare(py_type, "dict")
        IfCondition EqualTo(cmp, 0) ThenBlock: {
            ReturnValue("Hash")
        }
        
        ReturnValue("Address")
    }
}

// =============================================================================
// TYPE INFERENCE FROM EXPRESSIONS
// =============================================================================

Function.OOPGen_InferType {
    Input: expr: Address
    Output: Address
    Body: {
        IfCondition EqualTo(expr, 0) ThenBlock: {
            ReturnValue("Address")
        }
        
        expr_type = AST_Type(expr)
        
        // Number literal
        IfCondition EqualTo(expr_type, Node.NUM_LIT) ThenBlock: {
            ReturnValue("Integer")
        }
        
        // String literal
        IfCondition EqualTo(expr_type, Node.STR_LIT) ThenBlock: {
            ReturnValue("String")
        }
        
        // List literal
        IfCondition EqualTo(expr_type, Node.LIST_LIT) ThenBlock: {
            ReturnValue("Array")
        }
        
        // Dict literal
        IfCondition EqualTo(expr_type, Node.DICT_LIT) ThenBlock: {
            ReturnValue("Hash")
        }
        
        // Identifier - check if it's a known type
        IfCondition EqualTo(expr_type, Node.IDENT) ThenBlock: {
            // Could look up in symbol table, for now assume Address
            ReturnValue("Address")
        }
        
        // Binary op - usually Integer
        IfCondition EqualTo(expr_type, Node.BINARY_OP) ThenBlock: {
            ReturnValue("Integer")
        }
        
        // Default
        ReturnValue("Address")
    }
}

// =============================================================================
// CLASS DEFINITION GENERATION
// =============================================================================

Function.OOPGen_ClassDef {
    Input: node: Address
    Body: {
        // DEBUG START
        PrintMessage("[OOPGen_ClassDef] Start\n")
        
        OOPGen_Init()
        // DEBUG
        PrintMessage("[OOPGen_ClassDef] After Init\n")
        
        OOPGen.has_classes = 1
        
        class_name = AST_GetField(node, "name")
        // DEBUG
        PrintMessage("[OOPGen_ClassDef] Got class_name\n")
        
        bases = AST_GetField(node, "bases")
        // DEBUG
        PrintMessage("[OOPGen_ClassDef] Got bases\n")
        
        body = AST_GetField(node, "body")
        // DEBUG
        PrintMessage("[OOPGen_ClassDef] Got body\n")
        
        // Set current class context
        OOPGen.current_class = class_name
        // DEBUG
        PrintMessage("[OOPGen_ClassDef] Calling XArray.XClear\n")
        
        XArray.XClear(OOPGen.discovered_fields)
        // DEBUG
        PrintMessage("[OOPGen_ClassDef] After XClear\n")
        
        // Determine parent class (first base or 0)
        parent = 0
        // DEBUG
        PrintMessage("[OOPGen_ClassDef] Calling XArray.XSize on bases\n")
        
        num_bases = XArray.XSize(bases)
        // DEBUG
        PrintMessage("[OOPGen_ClassDef] num_bases done\n")
        
        IfCondition GreaterThan(num_bases, 0) ThenBlock: {
            parent = XArray.XGet(bases, 0)
        }
        
        // PASS 1: Find __init__ and discover fields
        // DEBUG
        PrintMessage("[OOPGen_ClassDef] PASS 1 - FindMethod\n")
        
        init_method = OOPGen_FindMethod(body, "__init__")
        // DEBUG
        PrintMessage("[OOPGen_ClassDef] FindMethod returned\n")
        
        IfCondition NotEqual(init_method, 0) ThenBlock: {
            // DEBUG
            PrintMessage("[OOPGen_ClassDef] Getting init body\n")
            
            init_body = AST_GetField(init_method, "body")
            // DEBUG
            PrintMessage("[OOPGen_ClassDef] Discovering fields\n")
            
            OOPGen_DiscoverFieldsFromBody(init_body)
            // DEBUG
            PrintMessage("[OOPGen_ClassDef] Fields done\n")
        }
        
        // PASS 2: Generate method implementations
        // DEBUG
        PrintMessage("[OOPGen_ClassDef] PASS 2 - Methods\n")
        
        num_items = XArray.XSize(body)
        i = 0
        WhileLoop LessThan(i, num_items) {
            item = XArray.XGet(body, i)
            item_type = AST_Type(item)
            
            IfCondition EqualTo(item_type, Node.METHOD_DEF) ThenBlock: {
                // DEBUG
                PrintMessage("[OOPGen_ClassDef] Generating method impl\n")
                
                OOPGen_MethodImpl(class_name, item)
            }
            i = Add(i, 1)
        }
        
        // PASS 3: Generate class registration (deferred)
        // DEBUG
        PrintMessage("[OOPGen_ClassDef] PASS 3 - Registration\n")
        
        OOPGen_EmitClassRegistration(class_name, parent, bases, body)
        // DEBUG
        PrintMessage("[OOPGen_ClassDef] Registration done\n")
        
        // Store class info for later reference
        class_info = XArray.XCreate(3)
        XArray.XPush(class_info, class_name)
        XArray.XPush(class_info, parent)
        XArray.XPush(class_info, OOPGen.discovered_fields)
        XArray.XPush(OOPGen.classes, class_info)
        
        // Reset context
        OOPGen.current_class = 0
        // DEBUG
        PrintMessage("[OOPGen_ClassDef] Done\n")
    }
}

// =============================================================================
// FIND METHOD IN CLASS BODY
// =============================================================================

Function.OOPGen_FindMethod {
    Input: body: Address
    Input: method_name: Address
    Output: Address
    Body: {
        num_items = XArray.XSize(body)
        i = 0
        WhileLoop LessThan(i, num_items) {
            item = XArray.XGet(body, i)
            item_type = AST_Type(item)
            
            IfCondition EqualTo(item_type, Node.METHOD_DEF) ThenBlock: {
                name = AST_GetField(item, "name")
                cmp = StringCompare(name, method_name)
                IfCondition EqualTo(cmp, 0) ThenBlock: {
                    ReturnValue(item)
                }
            }
            i = Add(i, 1)
        }
        ReturnValue(0)
    }
}

// =============================================================================
// FIELD DISCOVERY FROM __init__ BODY
// =============================================================================

Function.OOPGen_DiscoverFieldsFromBody {
    Input: body: Address
    Body: {
        num_stmts = XArray.XSize(body)
        i = 0
        WhileLoop LessThan(i, num_stmts) {
            stmt = XArray.XGet(body, i)
            stmt_type = AST_Type(stmt)
            
            // Look for attribute assignments: self.field = value
            IfCondition EqualTo(stmt_type, Node.ATTR_ASSIGN) ThenBlock: {
                obj = AST_GetField(stmt, "object")
                obj_type = AST_Type(obj)
                
                IfCondition EqualTo(obj_type, Node.IDENT) ThenBlock: {
                    obj_name = AST_GetField(obj, "name")
                    cmp = StringCompare(obj_name, "self")
                    IfCondition EqualTo(cmp, 0) ThenBlock: {
                        field_name = AST_GetField(stmt, "attr")
                        value = AST_GetField(stmt, "value")
                        field_type = OOPGen_InferType(value)
                        
                        // Check if field already discovered
                        already_found = OOPGen_HasField(field_name)
                        IfCondition EqualTo(already_found, 0) ThenBlock: {
                            // Store as [name, type] pair
                            field_info = XArray.XCreate(2)
                            XArray.XPush(field_info, field_name)
                            XArray.XPush(field_info, field_type)
                            XArray.XPush(OOPGen.discovered_fields, field_info)
                        }
                    }
                }
            }
            i = Add(i, 1)
        }
    }
}

Function.OOPGen_HasField {
    Input: field_name: Address
    Output: Integer
    Body: {
        num_fields = XArray.XSize(OOPGen.discovered_fields)
        i = 0
        WhileLoop LessThan(i, num_fields) {
            field_info = XArray.XGet(OOPGen.discovered_fields, i)
            existing_name = XArray.XGet(field_info, 0)
            cmp = StringCompare(existing_name, field_name)
            IfCondition EqualTo(cmp, 0) ThenBlock: {
                ReturnValue(1)
            }
            i = Add(i, 1)
        }
        ReturnValue(0)
    }
}

// =============================================================================
// METHOD IMPLEMENTATION GENERATION
// =============================================================================

Function.OOPGen_MethodImpl {
    Input: class_name: Address
    Input: method_node: Address
    Body: {
        method_name = AST_GetField(method_node, "name")
        params = AST_GetField(method_node, "params")
        body = AST_GetField(method_node, "body")
        return_type = AST_GetField(method_node, "return_type")
        
        OOPGen.current_method = method_name
        
        // Build function name: ClassName_methodName
        func_name = StringConcat(class_name, "_")
        func_name = StringConcat(func_name, method_name)
        
        // Start function definition
        Gen_Emit("Function.")
        Gen_Emit(func_name)
        Gen_Emit(" {\n")
        
        // Emit parameters
        num_params = XArray.XSize(params)
        i = 0
        WhileLoop LessThan(i, num_params) {
            param = XArray.XGet(params, i)
            
            // =============================================================
            // FIX: Params are simple arrays [name, type, default, name]
            // NOT AST nodes! Access directly via ArrayGet, not AST_GetField
            // =============================================================
            param_name = ArrayGet(param, 0)   // slot 0 = name
            param_type = ArrayGet(param, 1)   // slot 1 = type (may be 0)
            
            Gen_Emit("    Input: ")
            Gen_Emit(param_name)
            Gen_Emit(": ")
            
            // First param (self) is always Address
            IfCondition EqualTo(i, 0) ThenBlock: {
                Gen_Emit("Address")
            } ElseBlock: {
                IfCondition EqualTo(param_type, 0) ThenBlock: {
                    // No type annotation - default to Address
                    Gen_Emit("Address")
                } ElseBlock: {
                    mapped_type = OOPGen_MapType(param_type)
                    Gen_Emit(mapped_type)
                }
            }
            Gen_Emit("\n")
            
            i = Add(i, 1)
        }
        
        // Emit return type
        Gen_Emit("    Output: ")
        IfCondition EqualTo(return_type, 0) ThenBlock: {
            // Default: Integer for __init__, Address otherwise
            cmp = StringCompare(method_name, "__init__")
            IfCondition EqualTo(cmp, 0) ThenBlock: {
                Gen_Emit("Integer")
            } ElseBlock: {
                Gen_Emit("Address")
            }
        } ElseBlock: {
            mapped_ret = OOPGen_MapType(return_type)
            Gen_Emit(mapped_ret)
        }
        Gen_Emit("\n")
        
        // Emit body
        Gen_Emit("    Body: {\n")
        
        // Save and set indent
        old_indent = Gen.indent
        Gen.indent = 2
        
       // Generate method body with OOP-aware transformations
        OOPGen_MethodBody(body)
        
        // Check if last statement was a return
        num_stmts = XArray.XSize(body)
        has_return = 0
        IfCondition GreaterThan(num_stmts, 0) ThenBlock: {
            last_stmt = XArray.XGet(body, Subtract(num_stmts, 1))
            last_type = AST_Type(last_stmt)
            IfCondition EqualTo(last_type, Node.RETURN_STMT) ThenBlock: {
                has_return = 1
            }
        }
        
        // Add implicit return if method doesn't have explicit return
        IfCondition EqualTo(has_return, 0) ThenBlock: {
            cmp = StringCompare(method_name, "__init__")
            IfCondition EqualTo(cmp, 0) ThenBlock: {
                // __init__ returns 1 (success)
                Gen_EmitIndent()
                Gen_Emit("ReturnValue(1)\n")
            } ElseBlock: {
                // Other methods return 0
                Gen_EmitIndent()
                Gen_Emit("ReturnValue(0)\n")
            }
        }
        
        // Restore indent and close
        Gen.indent = old_indent
        Gen_Emit("    }\n")
        Gen_Emit("}\n\n")
        
        OOPGen.current_method = 0
    }
}

// =============================================================================
// METHOD BODY GENERATION (OOP-aware)
// =============================================================================

Function.OOPGen_MethodBody {
    Input: body: Address
    Body: {
        num_stmts = XArray.XSize(body)
        i = 0
        WhileLoop LessThan(i, num_stmts) {
            stmt = XArray.XGet(body, i)
            OOPGen_Statement(stmt)
            i = Add(i, 1)
        }
    }
}

Function.OOPGen_Statement {
    Input: stmt: Address
    Body: {
        stmt_type = AST_Type(stmt)
        
        // Attribute assignment: self.field = value
        IfCondition EqualTo(stmt_type, Node.ATTR_ASSIGN) ThenBlock: {
            OOPGen_AttrAssign(stmt)
            ReturnValue(0)
        }
        
        // Return statement
        IfCondition EqualTo(stmt_type, Node.RETURN_STMT) ThenBlock: {
            OOPGen_Return(stmt)
            ReturnValue(0)
        }
        
        // Expression statement (might be method call)
        IfCondition EqualTo(stmt_type, Node.EXPR_STMT) ThenBlock: {
            expr = AST_GetField(stmt, "expr")
            Gen_EmitIndent()
            OOPGen_Expr(expr)
            Gen_Emit("\n")
            ReturnValue(0)
        }
        
        // Assignment
        IfCondition EqualTo(stmt_type, Node.ASSIGNMENT) ThenBlock: {
            OOPGen_Assign(stmt)
            ReturnValue(0)
        }
        
        // If statement
        IfCondition EqualTo(stmt_type, Node.IF_STMT) ThenBlock: {
            OOPGen_If(stmt)
            ReturnValue(0)
        }
        
        // While loop
        IfCondition EqualTo(stmt_type, Node.WHILE_STMT) ThenBlock: {
            OOPGen_While(stmt)
            ReturnValue(0)
        }
        
        // For loop
        IfCondition EqualTo(stmt_type, Node.FOR_STMT) ThenBlock: {
            OOPGen_For(stmt)
            ReturnValue(0)
        }
        
        // Fall through to standard codegen
        Gen_Node(stmt)
    }
}

// =============================================================================
// ATTRIBUTE ASSIGNMENT: self.field = value
// =============================================================================

Function.OOPGen_AttrAssign {
    Input: stmt: Address
    Body: {
        obj = AST_GetField(stmt, "object")
        attr = AST_GetField(stmt, "attr")
        value = AST_GetField(stmt, "value")
        
        // Check if value needs flattening - use OOP-aware flattening
        value_type = AST_Type(value)
        needs_flatten = Gen_HasCall(value)
        
        // OOP nodes always need flattening
        IfCondition EqualTo(value_type, Node.ATTRIBUTE) ThenBlock: {
            needs_flatten = 1
        }
        IfCondition EqualTo(value_type, Node.METHOD_CALL) ThenBlock: {
            needs_flatten = 1
        }
        IfCondition EqualTo(value_type, Node.BINARY_OP) ThenBlock: {
            needs_flatten = 1
        }
        
        IfCondition EqualTo(needs_flatten, 1) ThenBlock: {
            value = OOPGen_FlattenExpr(value)
        }
        
        Gen_EmitIndent()
        Gen_Emit("OOP.ObjectSet(")
        OOPGen_Expr(obj)
        Gen_Emit(", \"")
        Gen_Emit(attr)
        Gen_Emit("\", ")
        OOPGen_Expr(value)
        Gen_Emit(")\n")
    }
}

// =============================================================================
// RETURN STATEMENT
// =============================================================================

Function.OOPGen_Return {
    Input: stmt: Address
    Body: {
        value = AST_GetField(stmt, "value")
        
        IfCondition EqualTo(value, 0) ThenBlock: {
            Gen_EmitIndent()
            Gen_Emit("ReturnValue(0)\n")
            ReturnValue(0)
        }
        
        // Check if value needs flattening
        value_type = AST_Type(value)
        needs_flatten = Gen_HasCall(value)
        
        // OOP nodes always need flattening
        IfCondition EqualTo(value_type, Node.ATTRIBUTE) ThenBlock: {
            needs_flatten = 1
        }
        IfCondition EqualTo(value_type, Node.METHOD_CALL) ThenBlock: {
            needs_flatten = 1
        }
        IfCondition EqualTo(value_type, Node.BINARY_OP) ThenBlock: {
            needs_flatten = 1
        }
        
        IfCondition EqualTo(needs_flatten, 1) ThenBlock: {
            value = OOPGen_FlattenExpr(value)
        }
        
        Gen_EmitIndent()
        Gen_Emit("ReturnValue(")
        OOPGen_Expr(value)
        Gen_Emit(")\n")
    }
}

// =============================================================================
// ASSIGNMENT (may involve attributes on RHS)
// =============================================================================

Function.OOPGen_Assign {
    Input: stmt: Address
    Body: {
        target = AST_GetField(stmt, "target")
        value = AST_GetField(stmt, "value")
        
        // Flatten complex value expressions
        value_has_call = Gen_HasCall(value)
        IfCondition EqualTo(value_has_call, 1) ThenBlock: {
            value = Gen_FlattenExpr(value)
        }
        
        Gen_EmitIndent()
        Gen_EmitIdent(target)
        Gen_Emit(" = ")
        OOPGen_Expr(value)
        Gen_Emit("\n")
    }
}

// =============================================================================
// EXPRESSION GENERATION (OOP-aware)
// =============================================================================

Function.OOPGen_Expr {
    Input: expr: Address
    Body: {
        expr_type = AST_Type(expr)
        
        // Attribute access: obj.attr
        IfCondition EqualTo(expr_type, Node.ATTRIBUTE) ThenBlock: {
            OOPGen_AttrAccess(expr)
            ReturnValue(0)
        }
        
        // Method call: obj.method(args)
        IfCondition EqualTo(expr_type, Node.METHOD_CALL) ThenBlock: {
            OOPGen_MethodCall(expr)
            ReturnValue(0)
        }
        
        // Super call: super().method(args)
        IfCondition EqualTo(expr_type, Node.SUPER_CALL) ThenBlock: {
            OOPGen_SuperCall(expr)
            ReturnValue(0)
        }
        
        // isinstance() special case
        IfCondition EqualTo(expr_type, Node.CALL) ThenBlock: {
            func = AST_GetField(expr, "func")
            IfCondition EqualTo(AST_Type(func), Node.IDENT) ThenBlock: {
                func_name = AST_GetField(func, "name")
                cmp = StringCompare(func_name, "isinstance")
                IfCondition EqualTo(cmp, 0) ThenBlock: {
                    OOPGen_IsInstance(expr)
                    ReturnValue(0)
                }
            }
        }
        
        // Fall through to standard expression generation
        Gen_Expr(expr)
    }
}

// =============================================================================
// ATTRIBUTE ACCESS: obj.attr -> OOP.ObjectGet(obj, "attr")
// =============================================================================

Function.OOPGen_AttrAccess {
    Input: expr: Address
    Body: {
        obj = AST_GetField(expr, "object")
        attr = AST_GetField(expr, "attr")
        
        Gen_Emit("OOP.ObjectGet(")
        OOPGen_Expr(obj)
        Gen_Emit(", \"")
        Gen_Emit(attr)
        Gen_Emit("\")")
    }
}

// =============================================================================
// METHOD CALL: obj.method(args) -> OOP.MethodCall(obj, "method", args_array)
// =============================================================================

Function.OOPGen_MethodCall {
    Input: expr: Address
    Body: {
        obj = AST_GetField(expr, "object")
        method = AST_GetField(expr, "method")
        args = AST_GetField(expr, "args")
        
        num_args = XArray.XSize(args)
        
        // Generate args array
        args_var = OOPGen_TempVar("args")
        
        Gen_Emit(args_var)
        Gen_Emit(" = TArray.TCreate(")
        Gen_EmitNumber(num_args)
        Gen_Emit(")\n")
        
        // Push each argument
        i = 0
        WhileLoop LessThan(i, num_args) {
            arg = XArray.XGet(args, i)
            
            // Flatten complex args
            arg_has_call = Gen_HasCall(arg)
            IfCondition EqualTo(arg_has_call, 1) ThenBlock: {
                arg = Gen_FlattenExpr(arg)
            }
            
            Gen_EmitIndent()
            Gen_Emit("TArray.TPush(")
            Gen_Emit(args_var)
            Gen_Emit(", ")
            OOPGen_Expr(arg)
            Gen_Emit(")\n")
            
            i = Add(i, 1)
        }
        
        // Emit the method call
        Gen_EmitIndent()
        Gen_Emit("OOP.MethodCall(")
        OOPGen_Expr(obj)
        Gen_Emit(", \"")
        Gen_Emit(method)
        Gen_Emit("\", ")
        Gen_Emit(args_var)
        Gen_Emit(")")
        
        // Cleanup args array (emit as separate statement after)
        // Note: caller may need to handle this differently for assignments
    }
}

// =============================================================================
// SUPER CALL: super().method(args)
// =============================================================================

Function.OOPGen_SuperCall {
    Input: expr: Address
    Body: {
        method = AST_GetField(expr, "method")
        args = AST_GetField(expr, "args")
        
        num_args = XArray.XSize(args)
        
        // Generate args array
        args_var = OOPGen_TempVar("super_args")
        
        Gen_Emit(args_var)
        Gen_Emit(" = TArray.TCreate(")
        Gen_EmitNumber(num_args)
        Gen_Emit(")\n")
        
        // Push arguments
        i = 0
        WhileLoop LessThan(i, num_args) {
            arg = XArray.XGet(args, i)
            Gen_EmitIndent()
            Gen_Emit("TArray.TPush(")
            Gen_Emit(args_var)
            Gen_Emit(", ")
            OOPGen_Expr(arg)
            Gen_Emit(")\n")
            i = Add(i, 1)
        }
        
        // Emit super call
        Gen_EmitIndent()
        Gen_Emit("OOP.SuperCall(self, \"")
        Gen_Emit(OOPGen.current_class)
        Gen_Emit("\", \"")
        Gen_Emit(method)
        Gen_Emit("\", ")
        Gen_Emit(args_var)
        Gen_Emit(")")
    }
}

// =============================================================================
// ISINSTANCE: isinstance(obj, ClassName)
// =============================================================================

Function.OOPGen_IsInstance {
    Input: expr: Address
    Body: {
        args = AST_GetField(expr, "args")
        
        // isinstance(obj, Class) -> OOP.ObjectIsInstance(obj, "Class")
        obj_arg = XArray.XGet(args, 0)
        class_arg = XArray.XGet(args, 1)
        
        Gen_Emit("OOP.ObjectIsInstance(")
        OOPGen_Expr(obj_arg)
        Gen_Emit(", \"")
        
        // Class name - could be identifier
        class_type = AST_Type(class_arg)
        IfCondition EqualTo(class_type, Node.IDENT) ThenBlock: {
            class_name = AST_GetField(class_arg, "name")
            Gen_Emit(class_name)
        } ElseBlock: {
            OOPGen_Expr(class_arg)
        }
        
        Gen_Emit("\")")
    }
}

// =============================================================================
// CLASS REGISTRATION CODE GENERATION
// =============================================================================

Function.OOPGen_EmitClassRegistration {
    Input: class_name: Address
    Input: parent: Address
    Input: bases: Address
    Input: body: Address
    Body: {
        // Generate: OOP.ClassDefine("ClassName", parent_or_0)
        reg = StringConcat("    OOP.ClassDefine(\"", class_name)
        reg = StringConcat(reg, "\", ")
        IfCondition EqualTo(parent, 0) ThenBlock: {
            reg = StringConcat(reg, "0")
        } ElseBlock: {
            reg = StringConcat(reg, "\"")
            reg = StringConcat(reg, parent)
            reg = StringConcat(reg, "\"")
        }
        reg = StringConcat(reg, ")\n")
        XArray.XPush(OOPGen.class_init_code, reg)
        
        // Handle additional bases as mixins
        num_bases = XArray.XSize(bases)
        IfCondition GreaterThan(num_bases, 1) ThenBlock: {
            j = 1
            WhileLoop LessThan(j, num_bases) {
                mixin = XArray.XGet(bases, j)
                mixin_code = StringConcat("    OOP.ClassMixin(\"", class_name)
                mixin_code = StringConcat(mixin_code, "\", \"")
                mixin_code = StringConcat(mixin_code, mixin)
                mixin_code = StringConcat(mixin_code, "\")\n")
                XArray.XPush(OOPGen.class_init_code, mixin_code)
                j = Add(j, 1)
            }
        }
        
        // Emit field definitions
        num_fields = XArray.XSize(OOPGen.discovered_fields)
        k = 0
        WhileLoop LessThan(k, num_fields) {
            field_info = XArray.XGet(OOPGen.discovered_fields, k)
            field_name = XArray.XGet(field_info, 0)
            field_type = XArray.XGet(field_info, 1)
            
            field_code = StringConcat("    OOP.ClassField(\"", class_name)
            field_code = StringConcat(field_code, "\", \"")
            field_code = StringConcat(field_code, field_name)
            field_code = StringConcat(field_code, "\", \"")
            field_type_mapped = OOPGen_MapFieldType(field_type)
            field_code = StringConcat(field_code, field_type_mapped)
            field_code = StringConcat(field_code, "\")\n")
            XArray.XPush(OOPGen.class_init_code, field_code)
            
            k = Add(k, 1)
        }
        
        // Emit method registrations
        num_items = XArray.XSize(body)
        m = 0
        WhileLoop LessThan(m, num_items) {
            item = XArray.XGet(body, m)
            item_type = AST_Type(item)
            
            IfCondition EqualTo(item_type, Node.METHOD_DEF) ThenBlock: {
                method_name = AST_GetField(item, "name")
                func_name = StringConcat(class_name, "_")
                func_name = StringConcat(func_name, method_name)
                
                method_code = StringConcat("    OOP.ClassMethod(\"", class_name)
                method_code = StringConcat(method_code, "\", \"")
                method_code = StringConcat(method_code, method_name)
                method_code = StringConcat(method_code, "\", AddressOf(")
                method_code = StringConcat(method_code, func_name)
                method_code = StringConcat(method_code, "))\n")
                XArray.XPush(OOPGen.class_init_code, method_code)
            }
            m = Add(m, 1)
        }
        
        // Blank line after class
        XArray.XPush(OOPGen.class_init_code, "\n")
    }
}

// =============================================================================
// INSTANCE CREATION: ClassName(args)
// =============================================================================

Function.OOPGen_InstanceCreation {
    Input: class_name: Address
    Input: args: Address
    Output: Address  // Returns temp var holding instance
    Body: {
        num_args = XArray.XSize(args)
        
        // Generate args array
        args_var = OOPGen_TempVar("init_args")
        instance_var = OOPGen_TempVar("inst")
        
        Gen_EmitIndent()
        Gen_Emit(args_var)
        Gen_Emit(" = TArray.TCreate(")
        Gen_EmitNumber(num_args)
        Gen_Emit(")\n")
        
        // Push each argument
        i = 0
        WhileLoop LessThan(i, num_args) {
            arg = XArray.XGet(args, i)
            
            arg_has_call = Gen_HasCall(arg)
            IfCondition EqualTo(arg_has_call, 1) ThenBlock: {
                arg = Gen_FlattenExpr(arg)
            }
            
            Gen_EmitIndent()
            Gen_Emit("TArray.TPush(")
            Gen_Emit(args_var)
            Gen_Emit(", ")
            OOPGen_Expr(arg)
            Gen_Emit(")\n")
            
            i = Add(i, 1)
        }
        
        // Create instance
        Gen_EmitIndent()
        Gen_Emit(instance_var)
        Gen_Emit(" = OOP.ObjectNewInit(\"")
        Gen_Emit(class_name)
        Gen_Emit("\", ")
        Gen_Emit(args_var)
        Gen_Emit(")\n")
        
        // Cleanup args
        Gen_EmitIndent()
        Gen_Emit("TArray.TDestroy(")
        Gen_Emit(args_var)
        Gen_Emit(")\n")
        
        ReturnValue(instance_var)
    }
}

// =============================================================================
// CHECK IF IDENTIFIER IS A KNOWN CLASS
// =============================================================================

Function.OOPGen_IsClassName {
    Input: name: Address
    Output: Integer
    Body: {
        // GUARD: Return 0 if OOP system not initialized
        IfCondition EqualTo(OOPGen.initialized, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        num_classes = XArray.XSize(OOPGen.classes)
        i = 0
        WhileLoop LessThan(i, num_classes) {
            class_info = XArray.XGet(OOPGen.classes, i)
            class_name = XArray.XGet(class_info, 0)
            cmp = StringCompare(class_name, name)
            IfCondition EqualTo(cmp, 0) ThenBlock: {
                ReturnValue(1)
            }
            i = Add(i, 1)
        }
        ReturnValue(0)
    }
}

// =============================================================================
// EMIT CLASS INITIALIZATION SUBROUTINE
// =============================================================================

Function.OOPGen_EmitClassInitSubroutine {
    Body: {
        // GUARD: Check initialization first
        IfCondition EqualTo(OOPGen.initialized, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        IfCondition EqualTo(OOPGen.has_classes, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        Gen_Emit("Function.__OOP_ClassInit {\n")
        Gen_Emit("    Output: Integer\n")
        Gen_Emit("    Body: {\n")
        
        num_lines = XArray.XSize(OOPGen.class_init_code)
        i = 0
        WhileLoop LessThan(i, num_lines) {
            line = XArray.XGet(OOPGen.class_init_code, i)
            Gen_Emit("    ")  // Extra indent since we're inside Body
            Gen_Emit(line)
            i = Add(i, 1)
        }
        
        Gen_Emit("        ReturnValue(1)\n")
        Gen_Emit("    }\n")
        Gen_Emit("}\n\n")
    }
}


// =============================================================================
// CONTROL FLOW (with OOP expression support)
// =============================================================================

Function.OOPGen_If {
    Input: stmt: Address
    Body: {
        condition = AST_GetField(stmt, "condition")
        then_body = AST_GetField(stmt, "then")
        else_body = AST_GetField(stmt, "else")
        
        // Flatten condition if needed
        cond_has_call = Gen_HasCall(condition)
        IfCondition EqualTo(cond_has_call, 1) ThenBlock: {
            condition = Gen_FlattenExpr(condition)
        }
        
        Gen_EmitIndent()
        Gen_Emit("IfCondition ")
        OOPGen_Condition(condition)
        Gen_Emit(" ThenBlock: {\n")
        
        Gen.indent = Add(Gen.indent, 1)
        OOPGen_MethodBody(then_body)
        Gen.indent = Subtract(Gen.indent, 1)
        
        IfCondition NotEqual(else_body, 0) ThenBlock: {
            Gen_EmitIndent()
            Gen_Emit("} ElseBlock: {\n")
            Gen.indent = Add(Gen.indent, 1)
            OOPGen_MethodBody(else_body)
            Gen.indent = Subtract(Gen.indent, 1)
        }
        
        Gen_EmitIndent()
        Gen_Emit("}\n")
    }
}

Function.OOPGen_While {
    Input: stmt: Address
    Body: {
        condition = AST_GetField(stmt, "condition")
        body = AST_GetField(stmt, "body")
        
        Gen_EmitIndent()
        Gen_Emit("WhileLoop ")
        OOPGen_Condition(condition)
        Gen_Emit(" {\n")
        
        Gen.indent = Add(Gen.indent, 1)
        OOPGen_MethodBody(body)
        Gen.indent = Subtract(Gen.indent, 1)
        
        Gen_EmitIndent()
        Gen_Emit("}\n")
    }
}

Function.OOPGen_For {
    Input: stmt: Address
    Body: {
        // Delegate to standard for loop generation
        // but with OOP-aware body processing
        Gen_For(stmt)
    }
}

Function.OOPGen_Condition {
    Input: expr: Address
    Body: {
        // Generate condition expression with OOP support
        expr_type = AST_Type(expr)
        
        // Comparison operators
        IfCondition EqualTo(expr_type, Node.BINARY_OP) ThenBlock: {
            left = AST_GetField(expr, "left")
            op = AST_GetField(expr, "op")
            right = AST_GetField(expr, "right")
            
            // Map operator
            cmp = StringCompare(op, "==")
            IfCondition EqualTo(cmp, 0) ThenBlock: {
                Gen_Emit("EqualTo(")
                OOPGen_Expr(left)
                Gen_Emit(", ")
                OOPGen_Expr(right)
                Gen_Emit(")")
                ReturnValue(0)
            }
            
            cmp = StringCompare(op, "!=")
            IfCondition EqualTo(cmp, 0) ThenBlock: {
                Gen_Emit("NotEqual(")
                OOPGen_Expr(left)
                Gen_Emit(", ")
                OOPGen_Expr(right)
                Gen_Emit(")")
                ReturnValue(0)
            }
            
            cmp = StringCompare(op, "<")
            IfCondition EqualTo(cmp, 0) ThenBlock: {
                Gen_Emit("LessThan(")
                OOPGen_Expr(left)
                Gen_Emit(", ")
                OOPGen_Expr(right)
                Gen_Emit(")")
                ReturnValue(0)
            }
            
            cmp = StringCompare(op, ">")
            IfCondition EqualTo(cmp, 0) ThenBlock: {
                Gen_Emit("GreaterThan(")
                OOPGen_Expr(left)
                Gen_Emit(", ")
                OOPGen_Expr(right)
                Gen_Emit(")")
                ReturnValue(0)
            }
            
            cmp = StringCompare(op, "<=")
            IfCondition EqualTo(cmp, 0) ThenBlock: {
                Gen_Emit("LessEqual(")
                OOPGen_Expr(left)
                Gen_Emit(", ")
                OOPGen_Expr(right)
                Gen_Emit(")")
                ReturnValue(0)
            }
            
            cmp = StringCompare(op, ">=")
            IfCondition EqualTo(cmp, 0) ThenBlock: {
                Gen_Emit("GreaterEqual(")
                OOPGen_Expr(left)
                Gen_Emit(", ")
                OOPGen_Expr(right)
                Gen_Emit(")")
                ReturnValue(0)
            }
        }
        
        // Default: treat as expression
        OOPGen_Expr(expr)
    }
}

// =============================================================================
// LIBRARY INITIALIZATION
// =============================================================================

SubRoutine.InitializeAIMacroCodeGenOOP {
    PrintMessage("AIMacroCodeGenOOP Library Loaded\n")
}

RunTask(InitializeAIMacroCodeGenOOP)

// =============================================================================
// END Library.AIMacroCodeGenOOP.ailang
// =============================================================================
// Library.AIMacroString.ailang
// String utilities for AIMacro - All string operations in one place
// No more scattered string functions everywhere
//
// Dependencies: XArrays (only for Split/Join)
// Usage: LibraryImport.AIMacroString

LibraryImport.XArrays

// =============================================================================
// STRING REPEAT - Python's "string" * count
// =============================================================================
Function.String.Repeat {
    Input: str: Address
    Input: count: Integer
    Output: Address
    Body: {
        IfCondition LessEqual(count, 0) ThenBlock: {
            result = Allocate(1)
            SetByte(result, 0, 0)
            ReturnValue(result)
        }
        
        IfCondition EqualTo(str, 0) ThenBlock: {
            result = Allocate(1)
            SetByte(result, 0, 0)
            ReturnValue(result)
        }
        
        str_len = StringLength(str)
        IfCondition EqualTo(str_len, 0) ThenBlock: {
            result = Allocate(1)
            SetByte(result, 0, 0)
            ReturnValue(result)
        }
        
        total_len = Multiply(str_len, count)
        result = Allocate(Add(total_len, 1))
        
        pos = 0
        i = 0
        WhileLoop LessThan(i, count) {
            j = 0
            WhileLoop LessThan(j, str_len) {
                c = GetByte(str, j)
                SetByte(result, pos, c)
                pos = Add(pos, 1)
                j = Add(j, 1)
            }
            i = Add(i, 1)
        }
        
        SetByte(result, total_len, 0)
        ReturnValue(result)
    }
}

// =============================================================================
// CASE CONVERSION
// =============================================================================
Function.String.Upper {
    Input: text: Address
    Output: Address
    Body: {
        IfCondition EqualTo(text, 0) ThenBlock: {
            ReturnValue(0)
        }
        ReturnValue(StringToUpper(text))
    }
}

Function.String.Lower {
    Input: text: Address
    Output: Address
    Body: {
        IfCondition EqualTo(text, 0) ThenBlock: {
            ReturnValue(0)
        }
        ReturnValue(StringToLower(text))
    }
}

// =============================================================================
// TRIM / STRIP - Remove whitespace from ends
// =============================================================================
Function.String.Strip {
    Input: str: Address
    Output: Address
    Body: {
        IfCondition EqualTo(str, 0) ThenBlock: {
            result = Allocate(1)
            SetByte(result, 0, 0)
            ReturnValue(result)
        }
        
        len = StringLength(str)
        IfCondition EqualTo(len, 0) ThenBlock: {
            result = Allocate(1)
            SetByte(result, 0, 0)
            ReturnValue(result)
        }
        
        // Find start (skip leading whitespace)
        start = 0
        WhileLoop LessThan(start, len) {
            c = GetByte(str, start)
            // Space=32, Tab=9, Newline=10, CR=13
            is_ws = 0
            IfCondition EqualTo(c, 32) ThenBlock: { is_ws = 1 }
            IfCondition EqualTo(c, 9) ThenBlock: { is_ws = 1 }
            IfCondition EqualTo(c, 10) ThenBlock: { is_ws = 1 }
            IfCondition EqualTo(c, 13) ThenBlock: { is_ws = 1 }
            IfCondition EqualTo(is_ws, 0) ThenBlock: {
                BreakLoop
            }
            start = Add(start, 1)
        }
        
        // Find end (skip trailing whitespace)
        end_pos = Subtract(len, 1)
        WhileLoop GreaterEqual(end_pos, start) {
            c = GetByte(str, end_pos)
            is_ws = 0
            IfCondition EqualTo(c, 32) ThenBlock: { is_ws = 1 }
            IfCondition EqualTo(c, 9) ThenBlock: { is_ws = 1 }
            IfCondition EqualTo(c, 10) ThenBlock: { is_ws = 1 }
            IfCondition EqualTo(c, 13) ThenBlock: { is_ws = 1 }
            IfCondition EqualTo(is_ws, 0) ThenBlock: {
                BreakLoop
            }
            end_pos = Subtract(end_pos, 1)
        }
        
        new_len = Add(Subtract(end_pos, start), 1)
        IfCondition LessEqual(new_len, 0) ThenBlock: {
            result = Allocate(1)
            SetByte(result, 0, 0)
            ReturnValue(result)
        }
        
        result = Allocate(Add(new_len, 1))
        i = 0
        WhileLoop LessThan(i, new_len) {
            c = GetByte(str, Add(start, i))
            SetByte(result, i, c)
            i = Add(i, 1)
        }
        SetByte(result, new_len, 0)
        
        ReturnValue(result)
    }
}

Function.String.LStrip {
    Input: str: Address
    Output: Address
    Body: {
        IfCondition EqualTo(str, 0) ThenBlock: {
            result = Allocate(1)
            SetByte(result, 0, 0)
            ReturnValue(result)
        }
        
        len = StringLength(str)
        start = 0
        WhileLoop LessThan(start, len) {
            c = GetByte(str, start)
            is_ws = 0
            IfCondition EqualTo(c, 32) ThenBlock: { is_ws = 1 }
            IfCondition EqualTo(c, 9) ThenBlock: { is_ws = 1 }
            IfCondition EqualTo(c, 10) ThenBlock: { is_ws = 1 }
            IfCondition EqualTo(c, 13) ThenBlock: { is_ws = 1 }
            IfCondition EqualTo(is_ws, 0) ThenBlock: {
                BreakLoop
            }
            start = Add(start, 1)
        }
        
        new_len = Subtract(len, start)
        result = Allocate(Add(new_len, 1))
        i = 0
        WhileLoop LessThan(i, new_len) {
            c = GetByte(str, Add(start, i))
            SetByte(result, i, c)
            i = Add(i, 1)
        }
        SetByte(result, new_len, 0)
        ReturnValue(result)
    }
}

Function.String.RStrip {
    Input: str: Address
    Output: Address
    Body: {
        IfCondition EqualTo(str, 0) ThenBlock: {
            result = Allocate(1)
            SetByte(result, 0, 0)
            ReturnValue(result)
        }
        
        len = StringLength(str)
        end_pos = Subtract(len, 1)
        WhileLoop GreaterEqual(end_pos, 0) {
            c = GetByte(str, end_pos)
            is_ws = 0
            IfCondition EqualTo(c, 32) ThenBlock: { is_ws = 1 }
            IfCondition EqualTo(c, 9) ThenBlock: { is_ws = 1 }
            IfCondition EqualTo(c, 10) ThenBlock: { is_ws = 1 }
            IfCondition EqualTo(c, 13) ThenBlock: { is_ws = 1 }
            IfCondition EqualTo(is_ws, 0) ThenBlock: {
                BreakLoop
            }
            end_pos = Subtract(end_pos, 1)
        }
        
        new_len = Add(end_pos, 1)
        IfCondition LessEqual(new_len, 0) ThenBlock: {
            result = Allocate(1)
            SetByte(result, 0, 0)
            ReturnValue(result)
        }
        
        result = Allocate(Add(new_len, 1))
        i = 0
        WhileLoop LessThan(i, new_len) {
            c = GetByte(str, i)
            SetByte(result, i, c)
            i = Add(i, 1)
        }
        SetByte(result, new_len, 0)
        ReturnValue(result)
    }
}

// =============================================================================
// STARTS WITH / ENDS WITH
// =============================================================================
Function.String.StartsWith {
    Input: str: Address
    Input: prefix: Address
    Output: Integer
    Body: {
        IfCondition Or(EqualTo(str, 0), EqualTo(prefix, 0)) ThenBlock: {
            ReturnValue(0)
        }
        
        str_len = StringLength(str)
        prefix_len = StringLength(prefix)
        
        IfCondition LessThan(str_len, prefix_len) ThenBlock: {
            ReturnValue(0)
        }
        
        i = 0
        WhileLoop LessThan(i, prefix_len) {
            c1 = GetByte(str, i)
            c2 = GetByte(prefix, i)
            IfCondition NotEqual(c1, c2) ThenBlock: {
                ReturnValue(0)
            }
            i = Add(i, 1)
        }
        
        ReturnValue(1)
    }
}

Function.String.EndsWith {
    Input: str: Address
    Input: suffix: Address
    Output: Integer
    Body: {
        IfCondition Or(EqualTo(str, 0), EqualTo(suffix, 0)) ThenBlock: {
            ReturnValue(0)
        }
        
        str_len = StringLength(str)
        suffix_len = StringLength(suffix)
        
        IfCondition LessThan(str_len, suffix_len) ThenBlock: {
            ReturnValue(0)
        }
        
        start = Subtract(str_len, suffix_len)
        i = 0
        WhileLoop LessThan(i, suffix_len) {
            c1 = GetByte(str, Add(start, i))
            c2 = GetByte(suffix, i)
            IfCondition NotEqual(c1, c2) ThenBlock: {
                ReturnValue(0)
            }
            i = Add(i, 1)
        }
        
        ReturnValue(1)
    }
}

// =============================================================================
// CONTAINS
// =============================================================================
Function.String.Contains {
    Input: str: Address
    Input: substr: Address
    Output: Integer
    Body: {
        IfCondition Or(EqualTo(str, 0), EqualTo(substr, 0)) ThenBlock: {
            ReturnValue(0)
        }
        
        pos = StringIndexOf(str, substr, 0)
        IfCondition GreaterEqual(pos, 0) ThenBlock: {
            ReturnValue(1)
        }
        ReturnValue(0)
    }
}

// =============================================================================
// REPLACE
// =============================================================================
Function.String.Replace {
    Input: str: Address
    Input: old_sub: Address
    Input: new_sub: Address
    Output: Address
    Body: {
        IfCondition EqualTo(str, 0) ThenBlock: {
            result = Allocate(1)
            SetByte(result, 0, 0)
            ReturnValue(result)
        }
        
        str_len = StringLength(str)
        old_len = StringLength(old_sub)
        new_len = StringLength(new_sub)
        
        IfCondition EqualTo(old_len, 0) ThenBlock: {
            // Can't replace empty string, return copy
            result = Allocate(Add(str_len, 1))
            i = 0
            WhileLoop LessThan(i, str_len) {
                c = GetByte(str, i)
                SetByte(result, i, c)
                i = Add(i, 1)
            }
            SetByte(result, str_len, 0)
            ReturnValue(result)
        }
        
        // Count occurrences first to size result
        count = 0
        pos = 0
        WhileLoop LessThan(pos, str_len) {
            found = StringIndexOf(str, old_sub, pos)
            IfCondition LessThan(found, 0) ThenBlock: {
                BreakLoop
            }
            count = Add(count, 1)
            pos = Add(found, old_len)
        }
        
        // Calculate result size
        size_diff = Subtract(new_len, old_len)
        result_len = Add(str_len, Multiply(count, size_diff))
        result = Allocate(Add(result_len, 1))
        
        // Build result
        src_pos = 0
        dst_pos = 0
        WhileLoop LessThan(src_pos, str_len) {
            found = StringIndexOf(str, old_sub, src_pos)
            
            IfCondition LessThan(found, 0) ThenBlock: {
                // Copy rest of string
                WhileLoop LessThan(src_pos, str_len) {
                    c = GetByte(str, src_pos)
                    SetByte(result, dst_pos, c)
                    src_pos = Add(src_pos, 1)
                    dst_pos = Add(dst_pos, 1)
                }
                BreakLoop
            }
            
            // Copy up to match
            WhileLoop LessThan(src_pos, found) {
                c = GetByte(str, src_pos)
                SetByte(result, dst_pos, c)
                src_pos = Add(src_pos, 1)
                dst_pos = Add(dst_pos, 1)
            }
            
            // Copy replacement
            j = 0
            WhileLoop LessThan(j, new_len) {
                c = GetByte(new_sub, j)
                SetByte(result, dst_pos, c)
                dst_pos = Add(dst_pos, 1)
                j = Add(j, 1)
            }
            
            src_pos = Add(found, old_len)
        }
        
        SetByte(result, dst_pos, 0)
        ReturnValue(result)
    }
}

// =============================================================================
// SPLIT - Split string by delimiter into XArray
// =============================================================================
Function.String.Split {
    Input: text: Address
    Input: delimiter: Address
    Output: Address
    Body: {
        results = XArray.XCreate(8)
        
        IfCondition EqualTo(text, 0) ThenBlock: {
            ReturnValue(results)
        }
        
        text_len = StringLength(text)
        delim_len = StringLength(delimiter)
        
        // Edge case: empty input
        IfCondition EqualTo(text_len, 0) ThenBlock: {
            empty = Allocate(1)
            SetByte(empty, 0, 0)
            XArray.XPush(results, empty)
            ReturnValue(results)
        }
        
        // Edge case: empty delimiter - return whole string
        IfCondition EqualTo(delim_len, 0) ThenBlock: {
            copy = Allocate(Add(text_len, 1))
            i = 0
            WhileLoop LessThan(i, text_len) {
                c = GetByte(text, i)
                SetByte(copy, i, c)
                i = Add(i, 1)
            }
            SetByte(copy, text_len, 0)
            XArray.XPush(results, copy)
            ReturnValue(results)
        }
        
        last_pos = 0
        current_pos = 0
        
        WhileLoop LessThan(current_pos, text_len) {
            found_pos = StringIndexOf(text, delimiter, current_pos)
            
            IfCondition LessThan(found_pos, 0) ThenBlock: {
                BreakLoop
            }
            
            // Extract segment from last_pos to found_pos
            seg_len = Subtract(found_pos, last_pos)
            segment = Allocate(Add(seg_len, 1))
            j = 0
            WhileLoop LessThan(j, seg_len) {
                c = GetByte(text, Add(last_pos, j))
                SetByte(segment, j, c)
                j = Add(j, 1)
            }
            SetByte(segment, seg_len, 0)
            XArray.XPush(results, segment)
            
            last_pos = Add(found_pos, delim_len)
            current_pos = last_pos
        }
        
        // Add final segment
        final_len = Subtract(text_len, last_pos)
        final_seg = Allocate(Add(final_len, 1))
        j = 0
        WhileLoop LessThan(j, final_len) {
            c = GetByte(text, Add(last_pos, j))
            SetByte(final_seg, j, c)
            j = Add(j, 1)
        }
        SetByte(final_seg, final_len, 0)
        XArray.XPush(results, final_seg)
        
        ReturnValue(results)
    }
}

// =============================================================================
// JOIN - Join XArray of strings with separator
// =============================================================================
Function.String.Join {
    Input: separator: Address
    Input: parts: Address
    Output: Address
    Body: {
        IfCondition EqualTo(parts, 0) ThenBlock: {
            result = Allocate(1)
            SetByte(result, 0, 0)
            ReturnValue(result)
        }
        
        num_parts = XArray.XSize(parts)
        IfCondition EqualTo(num_parts, 0) ThenBlock: {
            result = Allocate(1)
            SetByte(result, 0, 0)
            ReturnValue(result)
        }
        
        sep_len = 0
        IfCondition NotEqual(separator, 0) ThenBlock: {
            sep_len = StringLength(separator)
        }
        
        // Calculate total length
        total_len = 0
        i = 0
        WhileLoop LessThan(i, num_parts) {
            part = XArray.XGet(parts, i)
            IfCondition NotEqual(part, 0) ThenBlock: {
                total_len = Add(total_len, StringLength(part))
            }
            i = Add(i, 1)
        }
        // Add separator lengths
        IfCondition GreaterThan(num_parts, 1) ThenBlock: {
            total_len = Add(total_len, Multiply(sep_len, Subtract(num_parts, 1)))
        }
        
        result = Allocate(Add(total_len, 1))
        pos = 0
        
        i = 0
        WhileLoop LessThan(i, num_parts) {
            // Add separator before all but first
            IfCondition GreaterThan(i, 0) ThenBlock: {
                j = 0
                WhileLoop LessThan(j, sep_len) {
                    c = GetByte(separator, j)
                    SetByte(result, pos, c)
                    pos = Add(pos, 1)
                    j = Add(j, 1)
                }
            }
            
            // Add part
            part = XArray.XGet(parts, i)
            IfCondition NotEqual(part, 0) ThenBlock: {
                part_len = StringLength(part)
                j = 0
                WhileLoop LessThan(j, part_len) {
                    c = GetByte(part, j)
                    SetByte(result, pos, c)
                    pos = Add(pos, 1)
                    j = Add(j, 1)
                }
            }
            
            i = Add(i, 1)
        }
        
        SetByte(result, pos, 0)
        ReturnValue(result)
    }
}

// =============================================================================
// REVERSE
// =============================================================================
Function.String.Reverse {
    Input: str: Address
    Output: Address
    Body: {
        IfCondition EqualTo(str, 0) ThenBlock: {
            result = Allocate(1)
            SetByte(result, 0, 0)
            ReturnValue(result)
        }
        
        len = StringLength(str)
        result = Allocate(Add(len, 1))
        
        i = 0
        WhileLoop LessThan(i, len) {
            c = GetByte(str, Subtract(Subtract(len, 1), i))
            SetByte(result, i, c)
            i = Add(i, 1)
        }
        SetByte(result, len, 0)
        
        ReturnValue(result)
    }
}

// =============================================================================
// PAD LEFT / PAD RIGHT
// =============================================================================
Function.String.PadLeft {
    Input: str: Address
    Input: width: Integer
    Input: pad_char: Integer
    Output: Address
    Body: {
        str_len = 0
        IfCondition NotEqual(str, 0) ThenBlock: {
            str_len = StringLength(str)
        }
        
        IfCondition GreaterEqual(str_len, width) ThenBlock: {
            // Already wide enough, return copy
            result = Allocate(Add(str_len, 1))
            i = 0
            WhileLoop LessThan(i, str_len) {
                c = GetByte(str, i)
                SetByte(result, i, c)
                i = Add(i, 1)
            }
            SetByte(result, str_len, 0)
            ReturnValue(result)
        }
        
        pad_count = Subtract(width, str_len)
        result = Allocate(Add(width, 1))
        
        // Add padding
        i = 0
        WhileLoop LessThan(i, pad_count) {
            SetByte(result, i, pad_char)
            i = Add(i, 1)
        }
        
        // Add string
        j = 0
        WhileLoop LessThan(j, str_len) {
            c = GetByte(str, j)
            SetByte(result, Add(pad_count, j), c)
            j = Add(j, 1)
        }
        
        SetByte(result, width, 0)
        ReturnValue(result)
    }
}

Function.String.PadRight {
    Input: str: Address
    Input: width: Integer
    Input: pad_char: Integer
    Output: Address
    Body: {
        str_len = 0
        IfCondition NotEqual(str, 0) ThenBlock: {
            str_len = StringLength(str)
        }
        
        IfCondition GreaterEqual(str_len, width) ThenBlock: {
            result = Allocate(Add(str_len, 1))
            i = 0
            WhileLoop LessThan(i, str_len) {
                c = GetByte(str, i)
                SetByte(result, i, c)
                i = Add(i, 1)
            }
            SetByte(result, str_len, 0)
            ReturnValue(result)
        }
        
        result = Allocate(Add(width, 1))
        
        // Add string
        i = 0
        WhileLoop LessThan(i, str_len) {
            c = GetByte(str, i)
            SetByte(result, i, c)
            i = Add(i, 1)
        }
        
        // Add padding
        WhileLoop LessThan(i, width) {
            SetByte(result, i, pad_char)
            i = Add(i, 1)
        }
        
        SetByte(result, width, 0)
        ReturnValue(result)
    }
}

// =============================================================================
// COUNT - Count occurrences of substring
// =============================================================================
Function.String.Count {
    Input: str: Address
    Input: substr: Address
    Output: Integer
    Body: {
        IfCondition Or(EqualTo(str, 0), EqualTo(substr, 0)) ThenBlock: {
            ReturnValue(0)
        }
        
        str_len = StringLength(str)
        sub_len = StringLength(substr)
        
        IfCondition EqualTo(sub_len, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        count = 0
        pos = 0
        WhileLoop LessThan(pos, str_len) {
            found = StringIndexOf(str, substr, pos)
            IfCondition LessThan(found, 0) ThenBlock: {
                BreakLoop
            }
            count = Add(count, 1)
            pos = Add(found, sub_len)
        }
        
        ReturnValue(count)
    }
}

// =============================================================================
// CONVERSION WRAPPERS
// =============================================================================
Function.String.FromInt {
    Input: value: Integer
    Output: Address
    Body: {
        ReturnValue(NumberToString(value))
    }
}

Function.String.ToInt {
    Input: str: Address
    Output: Integer
    Body: {
        IfCondition EqualTo(str, 0) ThenBlock: {
            ReturnValue(0)
        }
        ReturnValue(StringToNumber(str))
    }
}

// =============================================================================
// LENGTH - Wrapper for consistency
// =============================================================================
Function.String.Length {
    Input: str: Address
    Output: Integer
    Body: {
        IfCondition EqualTo(str, 0) ThenBlock: {
            ReturnValue(0)
        }
        ReturnValue(StringLength(str))
    }
}

// =============================================================================
// CHAR AT - Get single character as integer
// =============================================================================
Function.String.CharAt {
    Input: str: Address
    Input: index: Integer
    Output: Integer
    Body: {
        IfCondition EqualTo(str, 0) ThenBlock: {
            ReturnValue(0)
        }
        len = StringLength(str)
        IfCondition GreaterEqual(index, len) ThenBlock: {
            ReturnValue(0)
        }
        IfCondition LessThan(index, 0) ThenBlock: {
            ReturnValue(0)
        }
        c = GetByte(str, index)
        ReturnValue(c)
    }
}

// =============================================================================
// SUBSTRING - Wrapper for consistency
// =============================================================================
Function.String.Substring {
    Input: str: Address
    Input: start: Integer
    Input: end_pos: Integer
    Output: Address
    Body: {
        IfCondition EqualTo(str, 0) ThenBlock: {
            result = Allocate(1)
            SetByte(result, 0, 0)
            ReturnValue(result)
        }
        ReturnValue(StringSubstring(str, start, end_pos))
    }
}

// =============================================================================
// FIND / INDEX - Wrapper for consistency
// =============================================================================
Function.String.Find {
    Input: str: Address
    Input: substr: Address
    Output: Integer
    Body: {
        IfCondition Or(EqualTo(str, 0), EqualTo(substr, 0)) ThenBlock: {
            ReturnValue(-1)
        }
        ReturnValue(StringIndexOf(str, substr, 0))
    }
}

Function.String.FindFrom {
    Input: str: Address
    Input: substr: Address
    Input: start: Integer
    Output: Integer
    Body: {
        IfCondition Or(EqualTo(str, 0), EqualTo(substr, 0)) ThenBlock: {
            ReturnValue(-1)
        }
        ReturnValue(StringIndexOf(str, substr, start))
    }
}

// =============================================================================
// IS DIGIT / IS ALPHA / IS ALNUM
// =============================================================================
Function.String.IsDigit {
    Input: str: Address
    Output: Integer
    Body: {
        IfCondition EqualTo(str, 0) ThenBlock: {
            ReturnValue(0)
        }
        len = StringLength(str)
        IfCondition EqualTo(len, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        i = 0
        WhileLoop LessThan(i, len) {
            c = GetByte(str, i)
            IfCondition Or(LessThan(c, 48), GreaterThan(c, 57)) ThenBlock: {
                ReturnValue(0)
            }
            i = Add(i, 1)
        }
        ReturnValue(1)
    }
}

Function.String.IsAlpha {
    Input: str: Address
    Output: Integer
    Body: {
        IfCondition EqualTo(str, 0) ThenBlock: {
            ReturnValue(0)
        }
        len = StringLength(str)
        IfCondition EqualTo(len, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        i = 0
        WhileLoop LessThan(i, len) {
            c = GetByte(str, i)
            is_upper = And(GreaterEqual(c, 65), LessEqual(c, 90))
            is_lower = And(GreaterEqual(c, 97), LessEqual(c, 122))
            IfCondition And(EqualTo(is_upper, 0), EqualTo(is_lower, 0)) ThenBlock: {
                ReturnValue(0)
            }
            i = Add(i, 1)
        }
        ReturnValue(1)
    }
}

Function.String.IsAlnum {
    Input: str: Address
    Output: Integer
    Body: {
        IfCondition EqualTo(str, 0) ThenBlock: {
            ReturnValue(0)
        }
        len = StringLength(str)
        IfCondition EqualTo(len, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        i = 0
        WhileLoop LessThan(i, len) {
            c = GetByte(str, i)
            is_digit = And(GreaterEqual(c, 48), LessEqual(c, 57))
            is_upper = And(GreaterEqual(c, 65), LessEqual(c, 90))
            is_lower = And(GreaterEqual(c, 97), LessEqual(c, 122))
            IfCondition And(EqualTo(is_digit, 0), And(EqualTo(is_upper, 0), EqualTo(is_lower, 0))) ThenBlock: {
                ReturnValue(0)
            }
            i = Add(i, 1)
        }
        ReturnValue(1)
    }
}

// =============================================================================
// FEATURE: STRING CONCATENATION
// =============================================================================
// 
// Two parts:
// 1. Add String.Concat to Library.AIMacroString.ailang
// 2. Update Gen_BinaryOp in Library.AIMacroCodeGen.ailang
//
// =============================================================================


// =============================================================================
// PART 1: Add to Library.AIMacroString.ailang
// =============================================================================

// Concatenate two strings - returns newly allocated string
Function.String.Concat {
    Input: str1: Address
    Input: str2: Address
    Output: Address
    Body: {
        // Handle nulls
        IfCondition EqualTo(str1, 0) ThenBlock: {
            IfCondition EqualTo(str2, 0) ThenBlock: {
                result = Allocate(1)
                SetByte(result, 0, 0)
                ReturnValue(result)
            }
            // Return copy of str2
            len2 = StringLength(str2)
            result = Allocate(Add(len2, 1))
            i = 0
            WhileLoop LessThan(i, len2) {
                c = GetByte(str2, i)
                SetByte(result, i, c)
                i = Add(i, 1)
            }
            SetByte(result, len2, 0)
            ReturnValue(result)
        }
        
        IfCondition EqualTo(str2, 0) ThenBlock: {
            // Return copy of str1
            len1 = StringLength(str1)
            result = Allocate(Add(len1, 1))
            i = 0
            WhileLoop LessThan(i, len1) {
                c = GetByte(str1, i)
                SetByte(result, i, c)
                i = Add(i, 1)
            }
            SetByte(result, len1, 0)
            ReturnValue(result)
        }
        
        len1 = StringLength(str1)
        len2 = StringLength(str2)
        total = Add(len1, len2)
        
        result = Allocate(Add(total, 1))
        
        // Copy str1
        i = 0
        WhileLoop LessThan(i, len1) {
            c = GetByte(str1, i)
            SetByte(result, i, c)
            i = Add(i, 1)
        }
        
        // Copy str2
        j = 0
        WhileLoop LessThan(j, len2) {
            c = GetByte(str2, j)
            SetByte(result, Add(len1, j), c)
            j = Add(j, 1)
        }
        
        SetByte(result, total, 0)
        ReturnValue(result)
    }
}

// Concatenate three strings
Function.String.Concat3 {
    Input: str1: Address
    Input: str2: Address
    Input: str3: Address
    Output: Address
    Body: {
        temp = String.Concat(str1, str2)
        result = String.Concat(temp, str3)
        // Note: temp leaks here - would need GC or manual free
        // For now, accept the leak for simplicity
        ReturnValue(result)
    }
}

// Concatenate four strings
Function.String.Concat4 {
    Input: str1: Address
    Input: str2: Address
    Input: str3: Address
    Input: str4: Address
    Output: Address
    Body: {
        temp1 = String.Concat(str1, str2)
        temp2 = String.Concat(temp1, str3)
        result = String.Concat(temp2, str4)
        ReturnValue(result)
    }
}
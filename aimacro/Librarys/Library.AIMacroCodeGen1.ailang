// Library.AIMacroCodeGen1.ailang
// AILang Code Generator - Part 1: State, Init, Helpers, Output
//
// Dependencies: XArrays, AIMacroCore, AIMacroParserCore

LibraryImport.XArrays
LibraryImport.TArrays
LibraryImport.AIMacroCore
LibraryImport.AIMacroParserCore

// =============================================================================
// CODE GENERATOR STATE
// =============================================================================
FixedPool.Gen {
    "output": Initialize=0, CanChange=True   
    "indent": Initialize=0, CanChange=True    
    "temp_counter": Initialize=0, CanChange=True
    "param_names": Initialize=0, CanChange=True
     "string_vars": Initialize=0, CanChange=True 
       "list_vars": Initialize=0, CanChange=True
}

// =============================================================================
// INITIALIZATION
// =============================================================================
Function.Gen_Init {
    Body: {
        Gen.output = XArray.XCreate(256)
        Gen.indent = 0
        Gen.temp_counter = 0
        Gen.param_names = XArray.XCreate(16)
        Gen.string_vars = XArray.XCreate(32)
        Gen.list_vars = XArray.XCreate(32)
    }
}

Function.Gen_Free {
    Body: {
        IfCondition NotEqual(Gen.output, 0) ThenBlock: {
            n = XArray.XSize(Gen.output)
            i = 0
            WhileLoop LessThan(i, n) {
                s = XArray.XGet(Gen.output, i)
                IfCondition NotEqual(s, 0) ThenBlock: {
                    Deallocate(s, 0)
                }
                i = Add(i, 1)
            }
            XArray.XDestroy(Gen.output)
        }
        IfCondition NotEqual(Gen.param_names, 0) ThenBlock: {
            XArray.XDestroy(Gen.param_names)
        }
        IfCondition NotEqual(Gen.string_vars, 0) ThenBlock: {
            XArray.XDestroy(Gen.string_vars)
        }
        IfCondition NotEqual(Gen.list_vars, 0) ThenBlock: {
            XArray.XDestroy(Gen.list_vars)
        }
    }
}

// =============================================================================
// TEMP NAME GENERATION - Clean names, reset per function
// =============================================================================
Function.Gen_IsStringVar {
    Input: name: Address
    Output: Integer
    Body: {
        IfCondition EqualTo(name, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        sz = XArray.XSize(Gen.string_vars)
        idx = 0
        WhileLoop LessThan(idx, sz) {
            varname = XArray.XGet(Gen.string_vars, idx)
            cmp = StringCompare(name, varname)
            IfCondition EqualTo(cmp, 0) ThenBlock: {
                ReturnValue(1)
            }
            idx = Add(idx, 1)
        }
        ReturnValue(0)
    }
}

Function.Gen_MarkStringVar {
    Input: name: Address
    Body: {
        IfCondition EqualTo(name, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        // Check if already tracked
        already = Gen_IsStringVar(name)
        IfCondition EqualTo(already, 1) ThenBlock: {
            ReturnValue(0)
        }
        
        // Copy the name and add to list
        len = StringLength(name)
        copy = Allocate(Add(len, 1))
        i = 0
        WhileLoop LessThan(i, len) {
            c = GetByte(name, i)
            SetByte(copy, i, c)
            i = Add(i, 1)
        }
        SetByte(copy, len, 0)
        
        XArray.XPush(Gen.string_vars, copy)
    }
}

// =============================================================================
// LIST VARIABLE TRACKING
// =============================================================================
Function.Gen_IsListVar {
    Input: name: Address
    Output: Integer
    Body: {
        IfCondition EqualTo(name, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        sz = XArray.XSize(Gen.list_vars)
        idx = 0
        WhileLoop LessThan(idx, sz) {
            varname = XArray.XGet(Gen.list_vars, idx)
            cmp = StringCompare(name, varname)
            IfCondition EqualTo(cmp, 0) ThenBlock: {
                ReturnValue(1)
            }
            idx = Add(idx, 1)
        }
        ReturnValue(0)
    }
}

Function.Gen_MarkListVar {
    Input: name: Address
    Body: {
        IfCondition EqualTo(name, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        // Check if already tracked
        already = Gen_IsListVar(name)
        IfCondition EqualTo(already, 1) ThenBlock: {
            ReturnValue(0)
        }
        
        // Copy the name and add to list
        len = StringLength(name)
        copy = Allocate(Add(len, 1))
        i = 0
        WhileLoop LessThan(i, len) {
            c = GetByte(name, i)
            SetByte(copy, i, c)
            i = Add(i, 1)
        }
        SetByte(copy, len, 0)
        
        XArray.XPush(Gen.list_vars, copy)
    }
}

Function.Gen_TempName {
    Output: Address
    Body: {
        prefix = "t"
        num_str = NumberToString(Gen.temp_counter)
        num_len = StringLength(num_str)
        Gen.temp_counter = Add(Gen.temp_counter, 1)
        
        total_len = Add(1, num_len)
        result = Allocate(Add(total_len, 1))
        
        SetByte(result, 0, 116)  // 't'
        
        j = 0
        WhileLoop LessThan(j, num_len) {
            c = GetByte(num_str, j)
            SetByte(result, Add(1, j), c)
            j = Add(j, 1)
        }
        
        SetByte(result, total_len, 0)
        Deallocate(num_str, 0)
        
        ReturnValue(result)
    }
}

// =============================================================================
// PARAMETER NAME HELPERS
// =============================================================================
Function.Gen_IsParam {
    Input: name: Address
    Output: Integer
    Body: {
        sz = XArray.XSize(Gen.param_names)
        idx = 0
        WhileLoop LessThan(idx, sz) {
            pname = XArray.XGet(Gen.param_names, idx)
            cmp = StringCompare(name, pname)
            IfCondition EqualTo(cmp, 0) ThenBlock: {
                ReturnValue(1)
            }
            idx = Add(idx, 1)
        }
        ReturnValue(0)
    }
}

Function.Gen_EmitIdent {
    Input: name: Address
    Body: {
        is_param = Gen_IsParam(name)
        IfCondition EqualTo(is_param, 1) ThenBlock: {
            Gen_Emit("p_")
        }
        Gen_Emit(name)
    }
}

// =============================================================================
// OUTPUT HELPERS
// =============================================================================
Function.Gen_Emit {
    Input: str: Address
    Body: {
        len = StringLength(str)
        size = Add(len, 1)
        copy = Allocate(size)
        i = 0
        WhileLoop LessThan(i, len) {
            c = GetByte(str, i)
            SetByte(copy, i, c)
            i = Add(i, 1)
        }
        SetByte(copy, len, 0)
        XArray.XPush(Gen.output, copy)
    }
}

Function.Gen_EmitIndent {
    Body: {
        i = 0
        WhileLoop LessThan(i, Gen.indent) {
            Gen_Emit("    ")
            i = Add(i, 1)
        }
    }
}

Function.Gen_EmitLine {
    Input: str: Address
    Body: {
        Gen_EmitIndent()
        Gen_Emit(str)
        Gen_Emit("\n")
    }
}

Function.Gen_EmitNumber {
    Input: num: Integer
    Body: {
        str = NumberToString(num)
        Gen_Emit(str)
        Deallocate(str, 0)
    }
}

// =============================================================================
// GET OPERATOR NAME
// =============================================================================

Function.Gen_OpName {
    Input: op: Integer
    Output: Address
    Body: {
        IfCondition EqualTo(op, Token.PLUS) ThenBlock: { ReturnValue("Add") }
        IfCondition EqualTo(op, Token.MINUS) ThenBlock: { ReturnValue("Subtract") }
        IfCondition EqualTo(op, Token.STAR) ThenBlock: { ReturnValue("Multiply") }
        IfCondition EqualTo(op, Token.SLASH) ThenBlock: { ReturnValue("Divide") }
        IfCondition EqualTo(op, Token.PERCENT) ThenBlock: { ReturnValue("Modulo") }
        IfCondition EqualTo(op, Token.POWER) ThenBlock: { ReturnValue("Math.Power") }
        IfCondition EqualTo(op, Token.FLOOR_DIV) ThenBlock: { ReturnValue("Math.FloorDiv") }
        IfCondition EqualTo(op, Token.EQ) ThenBlock: { ReturnValue("EqualTo") }
        IfCondition EqualTo(op, Token.NE) ThenBlock: { ReturnValue("NotEqual") }
        IfCondition EqualTo(op, Token.LT) ThenBlock: { ReturnValue("LessThan") }
        IfCondition EqualTo(op, Token.LE) ThenBlock: { ReturnValue("LessEqual") }
        IfCondition EqualTo(op, Token.GT) ThenBlock: { ReturnValue("GreaterThan") }
        IfCondition EqualTo(op, Token.GE) ThenBlock: { ReturnValue("GreaterEqual") }
        IfCondition EqualTo(op, Token.AND) ThenBlock: { ReturnValue("And") }
        IfCondition EqualTo(op, Token.OR) ThenBlock: { ReturnValue("Or") }
        IfCondition EqualTo(op, Token.NOT) ThenBlock: { ReturnValue("Not") }
        ReturnValue("Unknown")
    }
}

// =============================================================================
// CHECK IF EXPRESSION CONTAINS A FUNCTION CALL
// INDEX_ACCESS counts because it generates XArray.XGet() which is a call
// =============================================================================
Function.Gen_HasCall {
    Input: node: Address
    Output: Integer
    Body: {
        IfCondition EqualTo(node, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        t = AST_Type(node)
        
        IfCondition EqualTo(t, Node.CALL) ThenBlock: {
            ReturnValue(1)
        }
        IfCondition EqualTo(t, Node.METHOD_CALL) ThenBlock: {
            ReturnValue(1)
        }
        IfCondition EqualTo(t, Node.INDEX_ACCESS) ThenBlock: {
            ReturnValue(1)
        }
        
        IfCondition EqualTo(t, Node.BINARY_OP) ThenBlock: {
            left = ArrayGet(node, 3)
            right = ArrayGet(node, 5)
            left_has = Gen_HasCall(left)
            IfCondition EqualTo(left_has, 1) ThenBlock: {
                ReturnValue(1)
            }
            right_has = Gen_HasCall(right)
            ReturnValue(right_has)
        }
        
        IfCondition EqualTo(t, Node.UNARY_OP) ThenBlock: {
            operand = ArrayGet(node, 4)
            ReturnValue(Gen_HasCall(operand))
        }
        
        IfCondition EqualTo(t, Node.INDEX_ACCESS) ThenBlock: {
            expr = ArrayGet(node, 3)
            index = ArrayGet(node, 4)
            expr_has = Gen_HasCall(expr)
            IfCondition EqualTo(expr_has, 1) ThenBlock: {
                ReturnValue(1)
            }
            ReturnValue(Gen_HasCall(index))
        }
        
        ReturnValue(0)
    }
}

// =============================================================================
// CREATE IDENTIFIER NODE
// =============================================================================
Function.Gen_MakeIdent {
    Input: name: Address
    Output: Address
    Body: {
        node = ArrayCreate(4)
        ArraySet(node, 0, Node.IDENT)
        ArraySet(node, 1, 0)
        ArraySet(node, 2, 0)
        ArraySet(node, 3, name)
        ReturnValue(node)
    }
}

// =============================================================================
// EMIT ESCAPED STRING
// =============================================================================
Function.Gen_EmitEscaped {
    Input: str: Address
    Body: {
        IfCondition EqualTo(str, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        len = StringLength(str)
        i = 0
        WhileLoop LessThan(i, len) {
            c = GetByte(str, i)
            
            IfCondition EqualTo(c, 10) ThenBlock: {
                Gen_Emit("\\n")
            } ElseBlock: {
                IfCondition EqualTo(c, 9) ThenBlock: {
                    Gen_Emit("\\t")
                } ElseBlock: {
                    IfCondition EqualTo(c, 34) ThenBlock: {
                        Gen_Emit("\\\"")
                    } ElseBlock: {
                        IfCondition EqualTo(c, 92) ThenBlock: {
                            Gen_Emit("\\\\")
                        } ElseBlock: {
                            buf = Allocate(2)
                            SetByte(buf, 0, c)
                            SetByte(buf, 1, 0)
                            Gen_Emit(buf)
                            Deallocate(buf, 2)
                        }
                    }
                }
            }
            
            i = Add(i, 1)
        }
    }
}

// =============================================================================
// CHECK IF ARGUMENT LIST HAS CALLS
// =============================================================================
Function.Gen_ArgsHaveCalls {
    Input: args: Address
    Output: Integer
    Body: {
        IfCondition EqualTo(args, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        n = XArray.XSize(args)
        i = 0
        WhileLoop LessThan(i, n) {
            arg = XArray.XGet(args, i)
            has = Gen_HasCall(arg)
            IfCondition EqualTo(has, 1) ThenBlock: {
                ReturnValue(1)
            }
            i = Add(i, 1)
        }
        ReturnValue(0)
    }
}

// =============================================================================
// GET OUTPUT AS STRING
// =============================================================================
Function.Gen_GetOutput {
    Output: Address
    Body: {
        total = 0
        n = XArray.XSize(Gen.output)
        i = 0
        WhileLoop LessThan(i, n) {
            s = XArray.XGet(Gen.output, i)
            IfCondition NotEqual(s, 0) ThenBlock: {
                total = Add(total, StringLength(s))
            }
            i = Add(i, 1)
        }
        
        result = Allocate(Add(total, 1))
        pos = 0
        
        i = 0
        WhileLoop LessThan(i, n) {
            s = XArray.XGet(Gen.output, i)
            IfCondition NotEqual(s, 0) ThenBlock: {
                len = StringLength(s)
                j = 0
                WhileLoop LessThan(j, len) {
                    c = GetByte(s, j)
                    SetByte(result, pos, c)
                    pos = Add(pos, 1)
                    j = Add(j, 1)
                }
            }
            i = Add(i, 1)
        }
        
        SetByte(result, pos, 0)
        ReturnValue(result)
    }
}
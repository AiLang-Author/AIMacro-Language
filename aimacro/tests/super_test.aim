# =============================================================================
# AIMACRO SUPER TEST - THE ULTIMATE COMPREHENSIVE TEST SUITE
# Combines all test files into one definitive test
# =============================================================================

# =============================================================================
# TEST INFRASTRUCTURE
# =============================================================================

def assert_eq(actual: int, expected: int, name: str) -> int:
    if actual == expected:
        print("  PASS:", name)
        return 1
    else:
        print("  FAIL:", name, "| Expected:", expected, "Got:", actual)
        return 0
    end
end

def assert_str_eq(actual: str, expected: str, name: str) -> int:
    if actual == expected:
        print("  PASS:", name)
        return 1
    else:
        print("  FAIL:", name, "| Expected:", expected, "Got:", actual)
        return 0
    end
end

def assert_true(cond: int, name: str) -> int:
    return assert_eq(cond, 1, name)
end

def assert_false(cond: int, name: str) -> int:
    return assert_eq(cond, 0, name)
end

# =============================================================================
# SECTION 1: INTEGER LITERALS & BASIC TYPES
# =============================================================================

def test_integer_literals():
    print("")
    print("=== SECTION 1: Integer Literals ===")
    p = 0
    
    a = 0
    p = p + assert_eq(a, 0, "zero")
    
    b = 42
    p = p + assert_eq(b, 42, "positive")
    
    c = -100
    p = p + assert_eq(c, -100, "negative")
    
    d = 999999999
    p = p + assert_eq(d, 999999999, "large number")
    
    print("Integer literals:", p, "/ 4")
    return p
end

def test_boolean_literals():
    print("")
    print("=== SECTION 2: Boolean Literals ===")
    p = 0
    
    t = True
    f = False
    p = p + assert_true(t, "True literal")
    p = p + assert_false(f, "False literal")
    
    print("Boolean literals:", p, "/ 2")
    return p
end

# =============================================================================
# SECTION 2: ARITHMETIC OPERATIONS
# =============================================================================

def test_arithmetic():
    print("")
    print("=== SECTION 3: Arithmetic ===")
    p = 0
    
    p = p + assert_eq(1 + 1, 2, "addition")
    p = p + assert_eq(10 - 3, 7, "subtraction")
    p = p + assert_eq(4 * 5, 20, "multiplication")
    p = p + assert_eq(20 / 4, 5, "division")
    p = p + assert_eq(17 % 5, 2, "modulo")
    p = p + assert_eq(2 ** 3, 8, "power")
    p = p + assert_eq(7 // 2, 3, "floor division")
    
    p = p + assert_eq(-5 + 10, 5, "negative operand")
    p = p + assert_eq(5 - 10, -5, "negative result")
    p = p + assert_eq(-10 * 3, -30, "negative multiply")
    
    p = p + assert_eq(2 + 3 * 4, 14, "precedence: mul before add")
    p = p + assert_eq((2 + 3) * 4, 20, "parentheses override")
    p = p + assert_eq(10 - 2 - 3, 5, "left associative")
    p = p + assert_eq(((1 + 2) * (3 + 4)) - 5, 16, "complex expression")
    
    x = 10
    y = 3
    p = p + assert_eq(x + y, 13, "variables in expr")
    p = p + assert_eq(x * y + 1, 31, "mixed var expr")
    
    print("Arithmetic:", p, "/ 16")
    return p
end

def test_augmented_assignment():
    print("")
    print("=== SECTION 4: Augmented Assignment ===")
    p = 0
    
    x = 10
    x += 5
    p = p + assert_eq(x, 15, "+= operator")
    
    x -= 3
    p = p + assert_eq(x, 12, "-= operator")
    
    x *= 2
    p = p + assert_eq(x, 24, "*= operator")
    
    x /= 4
    p = p + assert_eq(x, 6, "/= operator")
    
    x %= 4
    p = p + assert_eq(x, 2, "%= operator")
    
    # Chain test
    y = 1
    y += 2
    y *= 3
    y -= 1
    p = p + assert_eq(y, 8, "augmented chain")
    
    print("Augmented assignment:", p, "/ 6")
    return p
end

# =============================================================================
# SECTION 3: COMPARISON OPERATORS
# =============================================================================

def test_comparisons():
    print("")
    print("=== SECTION 5: Comparisons ===")
    p = 0
    
    p = p + assert_true(5 > 3, "greater than true")
    p = p + assert_false(3 > 5, "greater than false")
    p = p + assert_true(3 < 5, "less than true")
    p = p + assert_false(5 < 3, "less than false")
    p = p + assert_true(5 >= 5, "greater equal (equal)")
    p = p + assert_true(6 >= 5, "greater equal (greater)")
    p = p + assert_true(5 <= 5, "less equal (equal)")
    p = p + assert_true(4 <= 5, "less equal (less)")
    p = p + assert_true(5 == 5, "equal true")
    p = p + assert_false(5 == 6, "equal false")
    p = p + assert_true(5 != 6, "not equal true")
    p = p + assert_false(5 != 5, "not equal false")
    
    print("Comparisons:", p, "/ 12")
    return p
end

def test_string_comparisons():
    print("")
    print("=== SECTION 6: String Comparisons ===")
    p = 0
    
    s1 = "hello"
    s2 = "hello"
    s3 = "world"
    s4 = "hel" + "lo"
    
    p = p + assert_true(s1 == s2, "string equal same")
    p = p + assert_false(s1 == s3, "string equal diff")
    p = p + assert_true(s1 != s3, "string not equal")
    p = p + assert_true(s1 == s4, "dynamic string equal")
    
    print("String comparisons:", p, "/ 4")
    return p
end

# =============================================================================
# SECTION 4: LOGICAL OPERATORS
# =============================================================================

def test_logical():
    print("")
    print("=== SECTION 7: Logical Operators ===")
    p = 0
    
    p = p + assert_true(1 and 1, "and: T and T")
    p = p + assert_false(1 and 0, "and: T and F")
    p = p + assert_false(0 and 1, "and: F and T")
    p = p + assert_false(0 and 0, "and: F and F")
    
    p = p + assert_true(1 or 1, "or: T or T")
    p = p + assert_true(1 or 0, "or: T or F")
    p = p + assert_true(0 or 1, "or: F or T")
    p = p + assert_false(0 or 0, "or: F or F")
    
    p = p + assert_true(not 0, "not: not F")
    p = p + assert_false(not 1, "not: not T")
    
    p = p + assert_true((1 and 1) or 0, "combined: (T and T) or F")
    p = p + assert_true(not (0 and 1), "combined: not (F and T)")
    p = p + assert_true(1 and not 0, "T and not F")
    
    # Not precedence edge cases
    x = 50
    if not (x > 100):
        p = p + 1
        print("  PASS: not with parens")
    else:
        print("  FAIL: not with parens")
    end
    
    print("Logical operators:", p, "/ 14")
    return p
end

# =============================================================================
# SECTION 5: IF-ELIF-ELSE
# =============================================================================

def test_conditionals():
    print("")
    print("=== SECTION 8: Conditionals ===")
    p = 0
    
    result = 0
    if 1:
        result = 1
    end
    p = p + assert_eq(result, 1, "if true executes")
    
    result = 0
    if 0:
        result = 1
    end
    p = p + assert_eq(result, 0, "if false skips")
    
    result = 0
    if 0:
        result = 1
    else:
        result = 2
    end
    p = p + assert_eq(result, 2, "else branch")
    
    x = 2
    result = 0
    if x == 1:
        result = 10
    elif x == 2:
        result = 20
    elif x == 3:
        result = 30
    else:
        result = 40
    end
    p = p + assert_eq(result, 20, "elif branch")
    
    x = 1
    result = 0
    if x == 1:
        result = 10
    elif x == 1:
        result = 20
    end
    p = p + assert_eq(result, 10, "first match wins")
    
    # Nested if
    a = 1
    b = 1
    result = 0
    if a:
        if b:
            result = 11
        else:
            result = 10
        end
    else:
        result = 0
    end
    p = p + assert_eq(result, 11, "nested if")
    
    # Deeply nested if
    x = 500
    result = 0
    if x > 0:
        if x > 10:
            if x > 100:
                if x > 1000:
                    result = 4
                else:
                    result = 3
                end
            else:
                result = 2
            end
        else:
            result = 1
        end
    else:
        result = 0
    end
    p = p + assert_eq(result, 3, "deeply nested if")
    
    print("Conditionals:", p, "/ 7")
    return p
end

def test_long_elif_chain():
    print("")
    print("=== SECTION 9: Long Elif Chain ===")
    p = 0
    
    for test_val in range(1, 12):
        x = test_val
        result = ""
        if x == 1:
            result = "one"
        elif x == 2:
            result = "two"
        elif x == 3:
            result = "three"
        elif x == 4:
            result = "four"
        elif x == 5:
            result = "five"
        elif x == 6:
            result = "six"
        elif x == 7:
            result = "seven"
        elif x == 8:
            result = "eight"
        elif x == 9:
            result = "nine"
        elif x == 10:
            result = "ten"
        else:
            result = "other"
        end
        
        if test_val == 7:
            p = p + assert_eq(result, "seven", "elif chain x=7")
        end
        if test_val == 11:
            p = p + assert_eq(result, "other", "elif chain x=11 (else)")
        end
    end
    
    print("Long elif chain:", p, "/ 2")
    return p
end

# =============================================================================
# SECTION 6: WHILE LOOPS
# =============================================================================

def test_while_loops():
    print("")
    print("=== SECTION 10: While Loops ===")
    p = 0
    
    count = 0
    i = 0
    while i < 5:
        count = count + 1
        i = i + 1
    end
    p = p + assert_eq(count, 5, "while count to 5")
    
    count = 0
    i = 10
    while i < 5:
        count = count + 1
        i = i + 1
    end
    p = p + assert_eq(count, 0, "while zero iterations")
    
    total = 0
    i = 1
    while i <= 10:
        total = total + i
        i = i + 1
    end
    p = p + assert_eq(total, 55, "while sum 1-10")
    
    # Nested while
    total = 0
    i = 0
    while i < 3:
        j = 0
        while j < 4:
            total = total + 1
            j = j + 1
        end
        i = i + 1
    end
    p = p + assert_eq(total, 12, "nested while 3x4")
    
    # While with and condition
    x = 0
    while x < 10 and x != 5:
        x = x + 1
    end
    p = p + assert_eq(x, 5, "while with and")
    
    # While with break
    count = 0
    while 1 == 1:
        count = count + 1
        if count == 5:
            break
        end
    end
    p = p + assert_eq(count, 5, "while with break")
    
    # Countdown
    n = 10
    count = 0
    while n > 0:
        count = count + 1
        n = n - 1
    end
    p = p + assert_eq(count, 10, "while decrement")
    
    print("While loops:", p, "/ 7")
    return p
end

# =============================================================================
# SECTION 7: FOR LOOPS
# =============================================================================

def test_for_loops():
    print("")
    print("=== SECTION 11: For Loops ===")
    p = 0
    
    total = 0
    for i in range(5):
        total = total + 1
    end
    p = p + assert_eq(total, 5, "for range(5)")
    
    total = 0
    for i in range(2, 6):
        total = total + i
    end
    p = p + assert_eq(total, 14, "for range(2,6)")
    
    total = 0
    for i in range(0, 10, 2):
        total = total + i
    end
    p = p + assert_eq(total, 20, "for range step=2")
    
    # Zero iterations
    count = 0
    for i in range(0):
        count = count + 1
    end
    p = p + assert_eq(count, 0, "for range(0)")
    
    # Single iteration
    count = 0
    for i in range(1):
        count = count + 1
    end
    p = p + assert_eq(count, 1, "for range(1)")
    
    # Nested for
    total = 0
    for i in range(3):
        for j in range(4):
            total = total + 1
        end
    end
    p = p + assert_eq(total, 12, "nested for 3x4")
    
    # Deeply nested loops
    count = 0
    for a in range(2):
        for b in range(2):
            for c in range(2):
                for d in range(2):
                    count = count + 1
                end
            end
        end
    end
    p = p + assert_eq(count, 16, "deeply nested 2^4")
    
    # Variable captured
    last = 0
    for i in range(5):
        last = i
    end
    p = p + assert_eq(last, 4, "for var capture")
    
    print("For loops:", p, "/ 8")
    return p
end

def test_for_in_list():
    print("")
    print("=== SECTION 12: For In List ===")
    p = 0
    
    nums = [10, 20, 30]
    total = 0
    for x in nums:
        total = total + x
    end
    p = p + assert_eq(total, 60, "for in list sum")
    
    nums = [1, 2, 3, 4, 5]
    doubled = []
    for x in nums:
        doubled.append(x * 2)
    end
    p = p + assert_eq(len(doubled), 5, "for in list append")
    p = p + assert_eq(doubled[0], 2, "doubled[0]")
    p = p + assert_eq(doubled[4], 10, "doubled[4]")
    
    print("For in list:", p, "/ 4")
    return p
end

# =============================================================================
# SECTION 8: BREAK AND CONTINUE
# =============================================================================

def test_break_continue():
    print("")
    print("=== SECTION 13: Break and Continue ===")
    p = 0
    
    # Break in for
    count = 0
    for i in range(10):
        if i == 3:
            break
        end
        count = count + 1
    end
    p = p + assert_eq(count, 3, "break in for")
    
    # Break in while
    count = 0
    while 1 == 1:
        count = count + 1
        if count == 5:
            break
        end
    end
    p = p + assert_eq(count, 5, "break in while")
    
    # Break in nested (only breaks inner)
    outer_count = 0
    for i in range(5):
        for j in range(5):
            if j == 2:
                break
            end
        end
        outer_count = outer_count + 1
    end
    p = p + assert_eq(outer_count, 5, "break in nested")
    
    # Continue in for
    total = 0
    for i in range(10):
        if i % 2 == 0:
            continue
        end
        total = total + i
    end
    p = p + assert_eq(total, 25, "continue in for (odd sum)")
    
    # Continue in while
    total = 0
    i = 0
    while i < 10:
        i = i + 1
        if i % 2 == 0:
            continue
        end
        total = total + i
    end
    p = p + assert_eq(total, 25, "continue in while")
    
    # Return in loop
    result = return_from_loop()
    p = p + assert_eq(result, 5, "return in loop")
    
    # Return in nested loop
    result = return_from_nested_loop()
    p = p + assert_eq(result, 505, "return in nested loop")
    
    print("Break and continue:", p, "/ 7")
    return p
end

def return_from_loop():
    for i in range(100):
        if i == 5:
            return i
        end
    end
    return -1
end

def return_from_nested_loop():
    for i in range(10):
        for j in range(10):
            if i * j == 25:
                return i * 100 + j
            end
        end
    end
    return -1
end

# =============================================================================
# SECTION 9: FUNCTIONS
# =============================================================================

def helper_double(x):
    return x * 2
end

def helper_add(a, b):
    return a + b
end

def helper_add3(a, b, c):
    return a + b + c
end

def helper_factorial(n):
    if n <= 1:
        return 1
    end
    return n * helper_factorial(n - 1)
end

def helper_fib(n):
    if n <= 1:
        return n
    end
    return helper_fib(n - 1) + helper_fib(n - 2)
end

def helper_many_params(a, b, c, d, e, f, g, h):
    return a + b + c + d + e + f + g + h
end

def helper_no_params():
    return 42
end

def helper_modify_param(x):
    x = x + 1
    x = x * 2
    return x
end

def test_functions():
    print("")
    print("=== SECTION 14: Functions ===")
    p = 0
    
    p = p + assert_eq(helper_double(5), 10, "basic function")
    p = p + assert_eq(helper_add(15, 27), 42, "two params")
    p = p + assert_eq(helper_add3(1, 2, 3), 6, "three params")
    p = p + assert_eq(helper_many_params(1, 2, 3, 4, 5, 6, 7, 8), 36, "eight params")
    p = p + assert_eq(helper_no_params(), 42, "no params")
    p = p + assert_eq(helper_modify_param(5), 12, "param modification")
    
    p = p + assert_eq(helper_factorial(5), 120, "factorial(5)")
    p = p + assert_eq(helper_factorial(0), 1, "factorial(0)")
    p = p + assert_eq(helper_fib(10), 55, "fib(10)")
    
    p = p + assert_eq(helper_double(helper_double(3)), 12, "nested calls")
    p = p + assert_eq(helper_double(2) + helper_double(3), 10, "calls in expr")
    p = p + assert_eq(helper_add(helper_add(1, 2), helper_add(3, 4)), 10, "triple nested")
    
    # Deep nesting
    result = helper_add(helper_add(helper_add(1, 2), helper_add(3, 4)), helper_add(helper_add(5, 6), helper_add(7, 8)))
    p = p + assert_eq(result, 36, "deeply nested calls")
    
    print("Functions:", p, "/ 13")
    return p
end

def test_recursion():
    print("")
    print("=== SECTION 15: Recursion ===")
    p = 0
    
    p = p + assert_eq(helper_factorial(10), 3628800, "factorial(10)")
    p = p + assert_eq(count_down_recursive(50), 50, "recursion depth 50")
    
    # GCD
    p = p + assert_eq(gcd(48, 18), 6, "gcd(48,18)")
    p = p + assert_eq(gcd(100, 25), 25, "gcd(100,25)")
    
    print("Recursion:", p, "/ 4")
    return p
end

def count_down_recursive(n):
    if n <= 0:
        return 0
    end
    return 1 + count_down_recursive(n - 1)
end

def gcd(a, b):
    while b != 0:
        temp = b
        b = a % b
        a = temp
    end
    return a
end

# =============================================================================
# SECTION 10: LISTS
# =============================================================================

def test_lists():
    print("")
    print("=== SECTION 16: Lists ===")
    p = 0
    
    nums = [1, 2, 3, 4, 5]
    p = p + assert_eq(len(nums), 5, "list len")
    p = p + assert_eq(nums[0], 1, "index [0]")
    p = p + assert_eq(nums[2], 3, "index [2]")
    p = p + assert_eq(nums[4], 5, "index [4]")
    p = p + assert_eq(nums[-1], 5, "index [-1]")
    
    nums[0] = 100
    p = p + assert_eq(nums[0], 100, "index assign")
    
    items = [10, 20]
    items.append(30)
    p = p + assert_eq(len(items), 3, "append len")
    p = p + assert_eq(items[2], 30, "append value")
    
    last = items.pop()
    p = p + assert_eq(last, 30, "pop returns value")
    p = p + assert_eq(len(items), 2, "pop reduces len")
    
    empty = []
    p = p + assert_eq(len(empty), 0, "empty list len")
    empty.append(1)
    p = p + assert_eq(len(empty), 1, "append to empty")
    
    # Build list in loop
    arr = []
    for i in range(5):
        arr.append(i * 10)
    end
    p = p + assert_eq(len(arr), 5, "built list len")
    p = p + assert_eq(arr[3], 30, "built list value")
    
    print("Lists:", p, "/ 14")
    return p
end

def test_list_operations():
    print("")
    print("=== SECTION 17: List Operations ===")
    p = 0
    
    nums = [5, 2, 8, 1, 9, 3]
    s = sorted(nums)
    p = p + assert_eq(s[0], 1, "sorted[0]")
    p = p + assert_eq(s[5], 9, "sorted[5]")
    
    nums = [1, 2, 3]
    r = reversed(nums)
    p = p + assert_eq(r[0], 3, "reversed[0]")
    p = p + assert_eq(r[2], 1, "reversed[2]")
    
    original = [7, 8, 9]
    copied = original.copy()
    p = p + assert_eq(copied[0], 7, "copy[0]")
    copied[0] = 100
    p = p + assert_eq(original[0], 7, "copy independence")
    
    nums = [1, 2, 3, 4, 5]
    p = p + assert_eq(sum(nums), 15, "sum")
    
    p = p + assert_eq(min(3, 7), 3, "min(3,7)")
    p = p + assert_eq(max(3, 7), 7, "max(3,7)")
    
    # List as function param
    arr = [1, 2, 3, 4, 5]
    s = list_sum(arr)
    p = p + assert_eq(s, 15, "list as param")
    
    # Modify list in function
    list_double_first(arr)
    p = p + assert_eq(arr[0], 2, "modify list in func")
    
    print("List operations:", p, "/ 11")
    return p
end

def list_sum(arr):
    total = 0
    for i in range(len(arr)):
        total = total + arr[i]
    end
    return total
end

def list_double_first(arr):
    arr[0] = arr[0] * 2
end

# =============================================================================
# SECTION 11: STRINGS
# =============================================================================

def test_strings():
    print("")
    print("=== SECTION 18: Strings ===")
    p = 0
    
    s = "hello"
    p = p + assert_eq(len(s), 5, "string len")
    p = p + assert_eq(len(""), 0, "empty string len")
    
    a = "Hello"
    b = "World"
    c = a + " " + b
    p = p + assert_eq(len(c), 11, "concat len")
    
    stars = "*" * 10
    p = p + assert_eq(len(stars), 10, "repeat len")
    
    # str() conversion
    n = 42
    s = str(n)
    p = p + assert_eq(len(s), 2, "str(42) len")
    
    s = str(-100)
    p = p + assert_eq(len(s), 4, "str(-100) len")
    
    # int() from string
    x = int("123")
    p = p + assert_eq(x, 123, "int from string")
    
    x = int("0")
    p = p + assert_eq(x, 0, "int('0')")
    
    # Long concat chain
    result = "a" + "b" + "c" + "d" + "e" + "f" + "g" + "h"
    p = p + assert_eq(len(result), 8, "long concat")
    
    # Concat in loop
    result = ""
    for i in range(5):
        result = result + str(i) + "-"
    end
    p = p + assert_eq(len(result), 10, "concat in loop")
    
    print("Strings:", p, "/ 10")
    return p
end

def test_string_methods():
    print("")
    print("=== SECTION 19: String Methods ===")
    p = 0
    
    s = "  Hello World  "
    stripped = s.strip()
    p = p + assert_eq(len(stripped), 11, "strip")
    
    word = "MixedCase"
    p = p + assert_str_eq(word.upper(), "MIXEDCASE", "upper")
    p = p + assert_str_eq(word.lower(), "mixedcase", "lower")
    
    text = "hello world"
    pos = text.find("world")
    p = p + assert_eq(pos, 6, "find")
    
    if text.startswith("hello"):
        p = p + 1
        print("  PASS: startswith")
    else:
        print("  FAIL: startswith")
    end
    
    if text.endswith("world"):
        p = p + 1
        print("  PASS: endswith")
    else:
        print("  FAIL: endswith")
    end
    
    original = "hello world"
    replaced = original.replace("world", "AIMacro")
    p = p + assert_eq(len(replaced), 13, "replace")
    
    banana = "banana"
    count = banana.count("a")
    p = p + assert_eq(count, 3, "count")
    
    print("String methods:", p, "/ 8")
    return p
end

# =============================================================================
# SECTION 12: DICTIONARIES
# =============================================================================

def test_dicts():
    print("")
    print("=== SECTION 20: Dictionaries ===")
    p = 0
    
    d = {"name": "Alice", "age": 30}
    p = p + assert_eq(d["name"], "Alice", "dict access string")
    p = p + assert_eq(d["age"], 30, "dict access int")
    
    d["score"] = 95
    p = p + assert_eq(d["score"], 95, "dict add key")
    p = p + assert_eq(len(d), 3, "dict len after add")
    
    d["age"] = 31
    p = p + assert_eq(d["age"], 31, "dict update")
    p = p + assert_eq(len(d), 3, "dict len after update")
    
    empty = {}
    p = p + assert_eq(len(empty), 0, "empty dict len")
    empty["first"] = 100
    p = p + assert_eq(len(empty), 1, "dict len after first add")
    
    # 'in' operator
    scores = {"alice": 95, "bob": 87}
    if "alice" in scores:
        p = p + 1
        print("  PASS: key in dict")
    else:
        print("  FAIL: key in dict")
    end
    
    if "charlie" not in scores:
        p = p + 1
        print("  PASS: key not in dict")
    else:
        print("  FAIL: key not in dict")
    end
    
    # Dict methods
    d = {"a": 1, "b": 2, "c": 3}
    keys = d.keys()
    p = p + assert_eq(len(keys), 3, "keys len")
    
    vals = d.values()
    p = p + assert_eq(len(vals), 3, "values len")
    
    items = d.items()
    p = p + assert_eq(len(items), 3, "items len")
    
    d.clear()
    p = p + assert_eq(len(d), 0, "clear")
    
    print("Dictionaries:", p, "/ 14")
    return p
end

# =============================================================================
# SECTION 13: TYPE SYSTEM
# =============================================================================

def test_types():
    print("")
    print("=== SECTION 21: Type System ===")
    p = 0
    
    p = p + assert_true(isinstance(42, int), "isinstance int")
    p = p + assert_true(isinstance("hello", str), "isinstance str")
    p = p + assert_true(isinstance([1,2,3], list), "isinstance list")
    
    p = p + assert_false(isinstance(42, str), "int not str")
    p = p + assert_false(isinstance("hi", int), "str not int")
    p = p + assert_false(isinstance(42, list), "int not list")
    
    nums = [3, 1, 2]
    s = sorted(nums)
    p = p + assert_true(isinstance(s, list), "sorted is list")
    
    print("Type system:", p, "/ 7")
    return p
end

# =============================================================================
# SECTION 14: BUILTINS
# =============================================================================

def test_builtins():
    print("")
    print("=== SECTION 22: Builtins ===")
    p = 0
    
    p = p + assert_eq(abs(-5), 5, "abs(-5)")
    p = p + assert_eq(abs(5), 5, "abs(5)")
    p = p + assert_eq(abs(0), 0, "abs(0)")
    
    p = p + assert_eq(min(10, 20), 10, "min")
    p = p + assert_eq(max(10, 20), 20, "max")
    
    p = p + assert_eq(len([1,2,3]), 3, "len list")
    p = p + assert_eq(len("abc"), 3, "len string")
    
    p = p + assert_eq(bool(0), 0, "bool(0)")
    p = p + assert_eq(bool(1), 1, "bool(1)")
    p = p + assert_eq(bool(42), 1, "bool(42)")
    
    p = p + assert_eq(int(42), 42, "int(42)")
    
    print("Builtins:", p, "/ 11")
    return p
end

# =============================================================================
# SECTION 15: ALGORITHMS
# =============================================================================

def is_prime(n):
    if n < 2:
        return 0
    end
    if n == 2:
        return 1
    end
    if n % 2 == 0:
        return 0
    end
    i = 3
    while i * i <= n:
        if n % i == 0:
            return 0
        end
        i = i + 2
    end
    return 1
end

def integer_sqrt(n):
    if n < 2:
        return n
    end
    x = n
    y = (x + 1) / 2
    while y < x:
        x = y
        y = (x + n / x) / 2
    end
    return x
end

def sum_digits(n):
    total = 0
    while n > 0:
        total = total + n % 10
        n = n / 10
    end
    return total
end

def reverse_number(n):
    rev = 0
    while n > 0:
        rev = rev * 10 + n % 10
        n = n / 10
    end
    return rev
end

def test_algorithms():
    print("")
    print("=== SECTION 23: Algorithms ===")
    p = 0
    
    p = p + assert_true(is_prime(2), "is_prime(2)")
    p = p + assert_true(is_prime(17), "is_prime(17)")
    p = p + assert_false(is_prime(15), "is_prime(15)")
    p = p + assert_false(is_prime(1), "is_prime(1)")
    
    p = p + assert_eq(integer_sqrt(144), 12, "sqrt(144)")
    p = p + assert_eq(integer_sqrt(100), 10, "sqrt(100)")
    
    p = p + assert_eq(sum_digits(12345), 15, "sum_digits")
    p = p + assert_eq(reverse_number(12345), 54321, "reverse_number")
    
    p = p + assert_eq(gcd(48, 18), 6, "gcd")
    
    # Bubble sort
    arr = [64, 34, 25, 12, 22, 11, 90]
    n = len(arr)
    for i in range(n - 1):
        for j in range(n - 1 - i):
            if arr[j] > arr[j + 1]:
                temp = arr[j]
                arr[j] = arr[j + 1]
                arr[j + 1] = temp
            end
        end
    end
    p = p + assert_eq(arr[0], 11, "bubble sort first")
    p = p + assert_eq(arr[6], 90, "bubble sort last")
    
    print("Algorithms:", p, "/ 11")
    return p
end

# =============================================================================
# SECTION 16: EDGE CASES
# =============================================================================

def empty_function():
    return 0
end

def function_with_only_assignment():
    x = 5
    return x
end

def test_edge_cases():
    print("")
    print("=== SECTION 24: Edge Cases ===")
    p = 0
    
    p = p + assert_eq(empty_function(), 0, "empty function")
    p = p + assert_eq(function_with_only_assignment(), 5, "only assignment")
    
    # Zero handling
    p = p + assert_eq(0 * 100, 0, "zero multiply")
    p = p + assert_eq(100 / 1, 100, "divide by 1")
    
    # Large numbers
    big = 1000000
    p = p + assert_eq(big + big, 2000000, "large add")
    p = p + assert_eq(big * 2, 2000000, "large multiply")
    
    # Empty string
    empty = ""
    p = p + assert_eq(len(empty), 0, "empty string")
    
    # Multiple return paths
    p = p + assert_eq(multiple_return_paths(3, -1), -3, "multiple returns")
    p = p + assert_eq(multiple_return_paths(-1, -1), -1, "multiple returns 2")
    p = p + assert_eq(multiple_return_paths(3, 4), 7, "multiple returns 3")
    
    print("Edge cases:", p, "/ 10")
    return p
end

def multiple_return_paths(x, y):
    if x < 0:
        if y < 0:
            return -1
        end
        return -2
    end
    if y < 0:
        return -3
    end
    return x + y
end

# =============================================================================
# SECTION 17: PRACTICAL PROGRAMS
# =============================================================================

def mean(arr):
    if len(arr) == 0:
        return 0
    end
    total = 0
    i = 0
    while i < len(arr):
        total = total + arr[i]
        i = i + 1
    end
    return total / len(arr)
end

def filter_greater_than(arr, threshold):
    result = []
    i = 0
    while i < len(arr):
        if arr[i] > threshold:
            result.append(arr[i])
        end
        i = i + 1
    end
    return result
end

def map_double(arr):
    result = []
    i = 0
    while i < len(arr):
        result.append(arr[i] * 2)
        i = i + 1
    end
    return result
end

def list_reverse(arr):
    result = []
    i = len(arr) - 1
    while i >= 0:
        result.append(arr[i])
        i = i - 1
    end
    return result
end

def test_practical():
    print("")
    print("=== SECTION 25: Practical Programs ===")
    p = 0
    
    data = [10, 20, 30, 40, 50]
    p = p + assert_eq(mean(data), 30, "mean")
    
    nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
    filtered = filter_greater_than(nums, 5)
    p = p + assert_eq(len(filtered), 5, "filter len")
    p = p + assert_eq(filtered[0], 6, "filter first")
    
    doubled = map_double([1, 2, 3])
    p = p + assert_eq(doubled[0], 2, "map first")
    p = p + assert_eq(doubled[2], 6, "map last")
    
    rev = list_reverse([1, 2, 3, 4, 5])
    p = p + assert_eq(rev[0], 5, "reverse first")
    p = p + assert_eq(rev[4], 1, "reverse last")
    
    print("Practical programs:", p, "/ 7")
    return p
end

# =============================================================================
# MAIN - RUN ALL TESTS
# =============================================================================

def main():
    print("")
    print("################################################################")
    print("#                                                              #")
    print("#        AIMACRO SUPER TEST - ULTIMATE TEST SUITE             #")
    print("#                                                              #")
    print("################################################################")
    
    total = 0
    passed = 0
    
    p = test_integer_literals()
    passed = passed + p
    total = total + 4
    
    p = test_boolean_literals()
    passed = passed + p
    total = total + 2
    
    p = test_arithmetic()
    passed = passed + p
    total = total + 16
    
    p = test_augmented_assignment()
    passed = passed + p
    total = total + 6
    
    p = test_comparisons()
    passed = passed + p
    total = total + 12
    
    p = test_string_comparisons()
    passed = passed + p
    total = total + 4
    
    p = test_logical()
    passed = passed + p
    total = total + 14
    
    p = test_conditionals()
    passed = passed + p
    total = total + 7
    
    p = test_long_elif_chain()
    passed = passed + p
    total = total + 2
    
    p = test_while_loops()
    passed = passed + p
    total = total + 7
    
    p = test_for_loops()
    passed = passed + p
    total = total + 8
    
    p = test_for_in_list()
    passed = passed + p
    total = total + 4
    
    p = test_break_continue()
    passed = passed + p
    total = total + 7
    
    p = test_functions()
    passed = passed + p
    total = total + 13
    
    p = test_recursion()
    passed = passed + p
    total = total + 4
    
    p = test_lists()
    passed = passed + p
    total = total + 14
    
    p = test_list_operations()
    passed = passed + p
    total = total + 11
    
    p = test_strings()
    passed = passed + p
    total = total + 10
    
    p = test_string_methods()
    passed = passed + p
    total = total + 8
    
    p = test_dicts()
    passed = passed + p
    total = total + 14
    
    p = test_types()
    passed = passed + p
    total = total + 7
    
    p = test_builtins()
    passed = passed + p
    total = total + 11
    
    p = test_algorithms()
    passed = passed + p
    total = total + 11
    
    p = test_edge_cases()
    passed = passed + p
    total = total + 10
    
    p = test_practical()
    passed = passed + p
    total = total + 7
    
    print("")
    print("################################################################")
    print("#                      FINAL RESULTS                          #")
    print("################################################################")
    print("")
    print("Total Tests:", total)
    print("Passed:", passed)
    failed = total - passed
    print("Failed:", failed)
    print("")
    
    if passed == total:
        print("*******************************************************")
        print("*                                                     *")
        print("*     ALL", total, "TESTS PASSED - TRANSPILER VERIFIED!    *")
        print("*                                                     *")
        print("*******************************************************")
    else:
        pct = (passed * 100) / total
        print("Pass Rate:", pct, "%")
        print("")
        print("*** SOME TESTS FAILED - REVIEW OUTPUT ABOVE ***")
    end
    
    print("")
    print("################################################################")
end
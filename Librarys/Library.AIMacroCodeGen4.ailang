// Library.AIMacroCodeGen4.ailang
// AILang Code Generator - Part 4: Expressions, Calls, Methods, Mappings
//
// Dependencies: XArrays, AIMacroCore, AIMacroParserCore, AIMacroCodeGen1, AIMacroCodeGen3

LibraryImport.XArrays
LibraryImport.TArrays
LibraryImport.AIMacroTypes
LibraryImport.AIMacroCore
LibraryImport.AIMacroParserCore
LibraryImport.AIMacroTypeAnnotations
LibraryImport.AIMacroCodeGen1
LibraryImport.AIMacroCodeGen3
LibraryImport.AIMacroCodeGenOOP

// =============================================================================
// EXPRESSION GENERATION
// =============================================================================
Function.Gen_Expr {
    Input: node: Address
    Body: {
        IfCondition EqualTo(node, 0) ThenBlock: {
            Gen_Emit("0")
            ReturnValue(0)
        }
        
        t = AST_Type(node)
        
        IfCondition EqualTo(t, Node.NUM_LIT) ThenBlock: {
            val = ArrayGet(node, 3)
            Gen_EmitNumber(val)
            ReturnValue(0)
        }
        
        IfCondition EqualTo(t, Node.STR_LIT) ThenBlock: {
            str = ArrayGet(node, 3)
            Gen_Emit("\"")
            Gen_EmitEscaped(str)
            Gen_Emit("\"")
            ReturnValue(0)
        }
        
        IfCondition EqualTo(t, Node.BOOL_LIT) ThenBlock: {
            val = ArrayGet(node, 3)
            IfCondition EqualTo(val, 1) ThenBlock: {
                Gen_Emit("1")
            } ElseBlock: {
                Gen_Emit("0")
            }
            ReturnValue(0)
        }
        
        IfCondition EqualTo(t, Node.IDENT) ThenBlock: {
            name = ArrayGet(node, 3)
            Gen_EmitIdent(name)
            ReturnValue(0)
        }
        
        IfCondition EqualTo(t, Node.BINARY_OP) ThenBlock: {
            Gen_BinaryOp(node)
            ReturnValue(0)
        }
        
        IfCondition EqualTo(t, Node.STR_EQ) ThenBlock: {
            left = ArrayGet(node, 3)
            right = ArrayGet(node, 5)
            Gen_Emit("EqualTo(StringCompare(")
            Gen_Expr(left)
            Gen_Emit(", ")
            Gen_Expr(right)
            Gen_Emit("), 0)")
            ReturnValue(0)
        }

        IfCondition EqualTo(t, Node.STR_NE) ThenBlock: {
            left = ArrayGet(node, 3)
            right = ArrayGet(node, 5)
            Gen_Emit("NotEqual(StringCompare(")
            Gen_Expr(left)
            Gen_Emit(", ")
            Gen_Expr(right)
            Gen_Emit("), 0)")
            ReturnValue(0)
        }

        IfCondition EqualTo(t, Node.UNARY_OP) ThenBlock: {
            Gen_UnaryOp(node)
            ReturnValue(0)
        }
        
        IfCondition EqualTo(t, Node.CALL) ThenBlock: {
            Gen_CallExpr(node)
            ReturnValue(0)
        }
        
        IfCondition EqualTo(t, Node.METHOD_CALL) ThenBlock: {
            Gen_MethodCallExpr(node)
            ReturnValue(0)
        }
        
        // =========== OOP ADDITIONS ===========

        // Handle ATTRIBUTE access: obj.field -> OOP.ObjectGet(obj, "field")
        IfCondition EqualTo(t, Node.ATTRIBUTE) ThenBlock: {
            OOPGen_AttrAccess(node)
            ReturnValue(0)
        }

        // Handle SUPER_CALL: super().method() -> OOP.SuperCall(...)
        IfCondition EqualTo(t, Node.SUPER_CALL) ThenBlock: {
            OOPGen_SuperCall(node)
            ReturnValue(0)
        }

        // =========== END OOP ADDITIONS ===========

        IfCondition EqualTo(t, Node.INDEX_ACCESS) ThenBlock: {
            Gen_IndexAccess(node)
            ReturnValue(0)
        }
        
        IfCondition EqualTo(t, Node.LIST_LIT) ThenBlock: {
            elems = ArrayGet(node, 3)
            n = XArray.XSize(elems)
            Gen_Emit("XArray.XCreate(")
            Gen_EmitNumber(n)
            Gen_Emit(")")
            ReturnValue(0)
        }
        
        IfCondition EqualTo(t, Node.DICT_LIT) ThenBlock: {
            Gen_Emit("XSHash.XCreate(16)")
            ReturnValue(0)
        }
        
        IfCondition EqualTo(t, Node.SLICE_ACCESS) ThenBlock: {
            Gen_SliceAccess(node)
            ReturnValue(0)
        }

        Gen_Emit("0")
    }
}

// =============================================================================
// STEP 1: Add a helper to recursively flatten string concat chains
// This extracts nested string + operations to temp variables
// =============================================================================

Function.Gen_FlattenStringConcat {
    Input: node: Address
    Output: Address
    Body: {
        // Returns: either the original node (if no flattening needed)
        //          or a new IDENT node pointing to a temp variable
        
        IfCondition EqualTo(node, 0) ThenBlock: {
            ReturnValue(node)
        }
        
        t = AST_Type(node)
        
        // Only process BINARY_OP nodes
        IfCondition NotEqual(t, Node.BINARY_OP) ThenBlock: {
            ReturnValue(node)
        }
        
        op = ArrayGet(node, 4)
        
        // Only process + operations
        IfCondition NotEqual(op, Token.PLUS) ThenBlock: {
            ReturnValue(node)
        }
        
        left = ArrayGet(node, 3)
        right = ArrayGet(node, 5)
        
        // Check if this is a string operation
        left_is_str = Gen_InvolvesString(left)
        right_is_str = Gen_InvolvesString(right)
        
        IfCondition And(EqualTo(left_is_str, 0), EqualTo(right_is_str, 0)) ThenBlock: {
            // Not a string operation
            ReturnValue(node)
        }
        
        // This IS a string concat. First, recursively flatten children
        left_type = AST_Type(left)
        IfCondition EqualTo(left_type, Node.BINARY_OP) ThenBlock: {
            left_op = ArrayGet(left, 4)
            IfCondition EqualTo(left_op, Token.PLUS) ThenBlock: {
                // Left child is also a + op, flatten it first
                new_left = Gen_FlattenStringConcat(left)
                ArraySet(node, 3, new_left)
                left = new_left
            }
        }
        
        right_type = AST_Type(right)
        IfCondition EqualTo(right_type, Node.BINARY_OP) ThenBlock: {
            right_op = ArrayGet(right, 4)
            IfCondition EqualTo(right_op, Token.PLUS) ThenBlock: {
                // Right child is also a + op, flatten it first
                new_right = Gen_FlattenStringConcat(right)
                ArraySet(node, 5, new_right)
                right = new_right
            }
        }
        
        // Now emit THIS node as a temp assignment
        temp = Gen_TempName()
        Gen_MarkStringVar(temp)
        
        // Check if left needs extraction (is a call-like node)
        left_type = AST_Type(left)
        IfCondition Or(EqualTo(left_type, Node.CALL), Or(EqualTo(left_type, Node.METHOD_CALL), EqualTo(left_type, Node.INDEX_ACCESS))) ThenBlock: {
            left_temp = Gen_TempName()
            Gen_MarkStringVar(left_temp)
            Gen_EmitIndent()
            Gen_Emit(left_temp)
            Gen_Emit(" = ")
            Gen_Expr(left)
            Gen_Emit("\n")
            left = Gen_MakeIdent(left_temp)
        }
        
        // Check if right needs extraction
        right_type = AST_Type(right)
        IfCondition Or(EqualTo(right_type, Node.CALL), Or(EqualTo(right_type, Node.METHOD_CALL), EqualTo(right_type, Node.INDEX_ACCESS))) ThenBlock: {
            right_temp = Gen_TempName()
            Gen_MarkStringVar(right_temp)
            Gen_EmitIndent()
            Gen_Emit(right_temp)
            Gen_Emit(" = ")
            Gen_Expr(right)
            Gen_Emit("\n")
            right = Gen_MakeIdent(right_temp)
        }
        
        Gen_EmitIndent()
        Gen_Emit(temp)
        Gen_Emit(" = String.Concat(")
        Gen_Expr(left)
        Gen_Emit(", ")
        Gen_Expr(right)
        Gen_Emit(")\n")
        
        // Return an identifier node pointing to the temp
        ReturnValue(Gen_MakeIdent(temp))
    }
}


// =============================================================================
// CHECK IF EXPRESSION INVOLVES STRINGS
// Recursively checks if an expression contains string literals or string operations
// This is needed because "a" + " " + "b" creates nested BINARY_OPs
// =============================================================================
Function.Gen_InvolvesString {
    Input: node: Address
    Output: Integer
    Body: {
        IfCondition EqualTo(node, 0) ThenBlock: {
            PrintMessage("[InvolvesString] node is NULL -> 0\n")
            ReturnValue(0)
        }
        
        t = AST_Type(node)
        
        PrintMessage("[InvolvesString] Checking node type ")
        PrintNumber(t)
        
        // Direct string literal
        IfCondition EqualTo(t, Node.STR_LIT) ThenBlock: {
            PrintMessage(" (STR_LIT) -> 1\n")
            ReturnValue(1)
        }
        
        // Check if it's an identifier that we know holds a string
IfCondition EqualTo(t, Node.IDENT) ThenBlock: {
    var_name = ArrayGet(node, 3)
    PrintMessage(" (IDENT) name='")
    PrintString(var_name)
    PrintMessage("' -> checking IsStringVar\n")
    
    // Check if it's a known string variable
    is_str = Gen_IsStringVar(var_name)
    IfCondition EqualTo(is_str, 1) ThenBlock: {
        PrintMessage("[InvolvesString] IsStringVar returned 1\n")
        ReturnValue(1)
    }
    
    // Check if it's a typed parameter with str type
    is_str = TypeAnno_IsString(var_name)
    IfCondition EqualTo(is_str, 1) ThenBlock: {
        PrintMessage("[InvolvesString] TypeAnno_IsString returned 1\n")
        ReturnValue(1)
    }
    
    PrintMessage("[InvolvesString] Not a string\n")
    ReturnValue(0)
}
        
        // Check if it's a call to a string function
        IfCondition EqualTo(t, Node.CALL) ThenBlock: {
            call_name = ArrayGet(node, 3)
            PrintMessage(" (CALL) func='")
            PrintString(call_name)
            PrintMessage("'\n")
            
            // Check for String.* functions
            cmp = StringCompare(call_name, "String.Concat")
            IfCondition EqualTo(cmp, 0) ThenBlock: {
                PrintMessage("[InvolvesString] String.Concat -> 1\n")
                ReturnValue(1)
            }
            
            cmp = StringCompare(call_name, "str")
            IfCondition EqualTo(cmp, 0) ThenBlock: {
                PrintMessage("[InvolvesString] str() -> 1\n")
                ReturnValue(1)
            }
            
            cmp = StringCompare(call_name, "input")
            IfCondition EqualTo(cmp, 0) ThenBlock: {
                PrintMessage("[InvolvesString] input() -> 1\n")
                ReturnValue(1)
            }
            
            cmp = StringCompare(call_name, "chr")
            IfCondition EqualTo(cmp, 0) ThenBlock: {
                PrintMessage("[InvolvesString] chr() -> 1\n")
                ReturnValue(1)
            }
            
            cmp = StringCompare(call_name, "NumberToString")
            IfCondition EqualTo(cmp, 0) ThenBlock: {
                PrintMessage("[InvolvesString] NumberToString -> 1\n")
                ReturnValue(1)
            }
            
            PrintMessage("[InvolvesString] CALL not recognized as string -> 0\n")
            ReturnValue(0)
        }
        
        // Check for string methods that return strings
        IfCondition EqualTo(t, Node.METHOD_CALL) ThenBlock: {
            method = ArrayGet(node, 4)
            PrintMessage(" (METHOD_CALL) method='")
            PrintString(method)
            PrintMessage("'\n")
            
            cmp = StringCompare(method, "upper")
            IfCondition EqualTo(cmp, 0) ThenBlock: { ReturnValue(1) }
            cmp = StringCompare(method, "lower")
            IfCondition EqualTo(cmp, 0) ThenBlock: { ReturnValue(1) }
            cmp = StringCompare(method, "strip")
            IfCondition EqualTo(cmp, 0) ThenBlock: { ReturnValue(1) }
            cmp = StringCompare(method, "replace")
            IfCondition EqualTo(cmp, 0) ThenBlock: { ReturnValue(1) }
            cmp = StringCompare(method, "join")
            IfCondition EqualTo(cmp, 0) ThenBlock: { ReturnValue(1) }
            
            PrintMessage("[InvolvesString] METHOD_CALL not string method -> 0\n")
            ReturnValue(0)
        }
        
        // For binary ops, check both sides recursively
        IfCondition EqualTo(t, Node.BINARY_OP) ThenBlock: {
            PrintMessage(" (BINARY_OP) -> checking children\n")
            left = ArrayGet(node, 3)
            right = ArrayGet(node, 5)
            
            left_is_str = Gen_InvolvesString(left)
            IfCondition EqualTo(left_is_str, 1) ThenBlock: {
                PrintMessage("[InvolvesString] BINARY_OP left is string -> 1\n")
                ReturnValue(1)
            }
            
            right_is_str = Gen_InvolvesString(right)
            IfCondition EqualTo(right_is_str, 1) ThenBlock: {
                PrintMessage("[InvolvesString] BINARY_OP right is string -> 1\n")
                ReturnValue(1)
            }
            
            PrintMessage("[InvolvesString] BINARY_OP neither side is string -> 0\n")
            ReturnValue(0)
        }
        
        // For unary ops, check operand
        IfCondition EqualTo(t, Node.UNARY_OP) ThenBlock: {
            PrintMessage(" (UNARY_OP) -> checking operand\n")
            operand = ArrayGet(node, 4)
            ReturnValue(Gen_InvolvesString(operand))
        }
        
        // Index access on a string variable
        IfCondition EqualTo(t, Node.INDEX_ACCESS) ThenBlock: {
            PrintMessage(" (INDEX_ACCESS)\n")
            expr = ArrayGet(node, 3)
            expr_type = AST_Type(expr)
            IfCondition EqualTo(expr_type, Node.IDENT) ThenBlock: {
                var_name = ArrayGet(expr, 3)
                is_str = Gen_IsStringVar(var_name)
                PrintMessage("[InvolvesString] INDEX_ACCESS on '")
                PrintString(var_name)
                PrintMessage("' isString=")
                PrintNumber(is_str)
                PrintMessage("\n")
            }
            ReturnValue(0)
        }
        
        PrintMessage(" (type ")
        PrintNumber(t)
        PrintMessage(") -> 0 (default)\n")
        ReturnValue(0)
    }
}


Function.Gen_GetStringStatus {
    Input: node: Address
    Output: Integer
    Body: {
        // Returns:
        //   1  = definitely a string
        //   0  = definitely NOT a string (number literal, boolean)
        //  -1  = unknown (parameter, function call result, etc.)
        
        IfCondition EqualTo(node, 0) ThenBlock: {
            ReturnValue(-1)
        }
        
        t = AST_Type(node)
        
        // String literal - definitely a string
        IfCondition EqualTo(t, Node.STR_LIT) ThenBlock: {
            ReturnValue(1)
        }
        
        // Number literal - definitely NOT a string
        IfCondition EqualTo(t, Node.NUM_LIT) ThenBlock: {
            ReturnValue(0)
        }
        
        // Boolean literal - definitely NOT a string
        IfCondition EqualTo(t, Node.BOOL_LIT) ThenBlock: {
            ReturnValue(0)
        }
        
        // Identifier - check if tracked as string var
        IfCondition EqualTo(t, Node.IDENT) ThenBlock: {
            var_name = ArrayGet(node, 3)
            
            // Check if it's a parameter (parameters have unknown type)
            is_param = Gen_IsParam(var_name)
            IfCondition EqualTo(is_param, 1) ThenBlock: {
                ReturnValue(-1)  // Unknown - it's a parameter
            }
            
            // Check if tracked as string var
            is_str = Gen_IsStringVar(var_name)
            IfCondition EqualTo(is_str, 1) ThenBlock: {
                ReturnValue(1)  // Known string
            }
            
            // Not tracked as string - but could still be unknown
            // For now, assume non-string if not tracked
            // (This is conservative - local vars that aren't strings)
            ReturnValue(0)
        }
        
        // Function call - check if it's a known string-returning function
        IfCondition EqualTo(t, Node.CALL) ThenBlock: {
            call_name = ArrayGet(node, 3)
            
            // Known string functions
            cmp = StringCompare(call_name, "str")
            IfCondition EqualTo(cmp, 0) ThenBlock: { ReturnValue(1) }
            cmp = StringCompare(call_name, "input")
            IfCondition EqualTo(cmp, 0) ThenBlock: { ReturnValue(1) }
            cmp = StringCompare(call_name, "chr")
            IfCondition EqualTo(cmp, 0) ThenBlock: { ReturnValue(1) }
            cmp = StringCompare(call_name, "String.Concat")
            IfCondition EqualTo(cmp, 0) ThenBlock: { ReturnValue(1) }
            cmp = StringCompare(call_name, "NumberToString")
            IfCondition EqualTo(cmp, 0) ThenBlock: { ReturnValue(1) }
            
            // Known non-string functions
            cmp = StringCompare(call_name, "len")
            IfCondition EqualTo(cmp, 0) ThenBlock: { ReturnValue(0) }
            cmp = StringCompare(call_name, "int")
            IfCondition EqualTo(cmp, 0) ThenBlock: { ReturnValue(0) }
            cmp = StringCompare(call_name, "abs")
            IfCondition EqualTo(cmp, 0) ThenBlock: { ReturnValue(0) }
            cmp = StringCompare(call_name, "sum")
            IfCondition EqualTo(cmp, 0) ThenBlock: { ReturnValue(0) }
            cmp = StringCompare(call_name, "min")
            IfCondition EqualTo(cmp, 0) ThenBlock: { ReturnValue(0) }
            cmp = StringCompare(call_name, "max")
            IfCondition EqualTo(cmp, 0) ThenBlock: { ReturnValue(0) }
            
            // User-defined function - unknown return type
            ReturnValue(-1)
        }
        
        // Method call - check if string method
        IfCondition EqualTo(t, Node.METHOD_CALL) ThenBlock: {
            method = ArrayGet(node, 4)
            
            // String methods that return strings
            cmp = StringCompare(method, "upper")
            IfCondition EqualTo(cmp, 0) ThenBlock: { ReturnValue(1) }
            cmp = StringCompare(method, "lower")
            IfCondition EqualTo(cmp, 0) ThenBlock: { ReturnValue(1) }
            cmp = StringCompare(method, "strip")
            IfCondition EqualTo(cmp, 0) ThenBlock: { ReturnValue(1) }
            cmp = StringCompare(method, "replace")
            IfCondition EqualTo(cmp, 0) ThenBlock: { ReturnValue(1) }
            
            // Methods that return non-strings
            cmp = StringCompare(method, "find")
            IfCondition EqualTo(cmp, 0) ThenBlock: { ReturnValue(0) }
            cmp = StringCompare(method, "count")
            IfCondition EqualTo(cmp, 0) ThenBlock: { ReturnValue(0) }
            cmp = StringCompare(method, "index")
            IfCondition EqualTo(cmp, 0) ThenBlock: { ReturnValue(0) }
            
            // Unknown method
            ReturnValue(-1)
        }
        
        // Index access - unknown (could be string char or list element)
        IfCondition EqualTo(t, Node.INDEX_ACCESS) ThenBlock: {
            ReturnValue(-1)
        }
        
        // Binary op - check children
        IfCondition EqualTo(t, Node.BINARY_OP) ThenBlock: {
            op = ArrayGet(node, 4)
            
            // + with strings produces string
            IfCondition EqualTo(op, Token.PLUS) ThenBlock: {
                left = ArrayGet(node, 3)
                right = ArrayGet(node, 5)
                left_status = Gen_GetStringStatus(left)
                right_status = Gen_GetStringStatus(right)
                
                // If either is definitely a string, result is string
                IfCondition EqualTo(left_status, 1) ThenBlock: { ReturnValue(1) }
                IfCondition EqualTo(right_status, 1) ThenBlock: { ReturnValue(1) }
                
                // If either is unknown, result is unknown
                IfCondition EqualTo(left_status, -1) ThenBlock: { ReturnValue(-1) }
                IfCondition EqualTo(right_status, -1) ThenBlock: { ReturnValue(-1) }
                
                // Both are non-strings
                ReturnValue(0)
            }
            
            // Comparison ops return integers
            IfCondition EqualTo(op, Token.EQ) ThenBlock: { ReturnValue(0) }
            IfCondition EqualTo(op, Token.NE) ThenBlock: { ReturnValue(0) }
            IfCondition EqualTo(op, Token.LT) ThenBlock: { ReturnValue(0) }
            IfCondition EqualTo(op, Token.GT) ThenBlock: { ReturnValue(0) }
            IfCondition EqualTo(op, Token.LE) ThenBlock: { ReturnValue(0) }
            IfCondition EqualTo(op, Token.GE) ThenBlock: { ReturnValue(0) }
            
            // Arithmetic ops return integers
            ReturnValue(0)
        }
        
        // Default: unknown
        ReturnValue(-1)
    }
}

// =============================================================================
// UPDATED Gen_BinaryOp - Replace the existing function with this
// =============================================================================
Function.Gen_BinaryOp {
    Input: node: Address
    Body: {
        left = ArrayGet(node, 3)
        op = ArrayGet(node, 4)
        right = ArrayGet(node, 5)
        
        // Check for string concatenation (+ operator)
        IfCondition EqualTo(op, Token.PLUS) ThenBlock: {
            left_is_str = Gen_InvolvesString(left)
            right_is_str = Gen_InvolvesString(right)
            
            IfCondition Or(EqualTo(left_is_str, 1), EqualTo(right_is_str, 1)) ThenBlock: {
                Gen_Emit("String.Concat(")
                Gen_Expr(left)
                Gen_Emit(", ")
                Gen_Expr(right)
                Gen_Emit(")")
                ReturnValue(0)
            }
        }
        
        // Check for string repeat (* operator)
        IfCondition EqualTo(op, Token.STAR) ThenBlock: {
            left_is_str = Gen_InvolvesString(left)
            IfCondition EqualTo(left_is_str, 1) ThenBlock: {
                Gen_Emit("String.Repeat(")
                Gen_Expr(left)
                Gen_Emit(", ")
                Gen_Expr(right)
                Gen_Emit(")")
                ReturnValue(0)
            }
        }
        
        // Check for string equality (== operator)
        IfCondition EqualTo(op, Token.EQ) ThenBlock: {
            left_is_str = Gen_InvolvesString(left)
            right_is_str = Gen_InvolvesString(right)
            
            IfCondition Or(EqualTo(left_is_str, 1), EqualTo(right_is_str, 1)) ThenBlock: {
                Gen_Emit("EqualTo(StringCompare(")
                Gen_Expr(left)
                Gen_Emit(", ")
                Gen_Expr(right)
                Gen_Emit("), 0)")
                ReturnValue(0)
            }
        }
        
        // Check for string inequality (!= operator)
        IfCondition EqualTo(op, Token.NE) ThenBlock: {
            left_is_str = Gen_InvolvesString(left)
            right_is_str = Gen_InvolvesString(right)
            
            IfCondition Or(EqualTo(left_is_str, 1), EqualTo(right_is_str, 1)) ThenBlock: {
                Gen_Emit("NotEqual(StringCompare(")
                Gen_Expr(left)
                Gen_Emit(", ")
                Gen_Expr(right)
                Gen_Emit("), 0)")
                ReturnValue(0)
            }
        }
        
        // Handle 'in' operator for list/dict membership
        IfCondition EqualTo(op, Token.IN) ThenBlock: {
            // Check if right side is a known dict or list
            right_type = AST_Type(right)
            is_dict = 0
            is_list = 0
            IfCondition EqualTo(right_type, Node.IDENT) ThenBlock: {
                var_name = ArrayGet(right, 3)
                is_dict = Gen_IsDictVar(var_name)
                is_list = Gen_IsListVar(var_name)
            }
            IfCondition EqualTo(right_type, Node.LIST_LIT) ThenBlock: {
                is_list = 1
            }
            IfCondition EqualTo(right_type, Node.DICT_LIT) ThenBlock: {
                is_dict = 1
            }
            
            IfCondition EqualTo(is_dict, 1) ThenBlock: {
                // Known dict - use THash.Contains
                Gen_Emit("THash.Contains(")
                Gen_Expr(right)
                Gen_Emit(", ")
                Gen_Expr(left)
                Gen_Emit(")")
            } ElseBlock: {
                IfCondition EqualTo(is_list, 1) ThenBlock: {
                    // Known list - use AIMacro.ListContains
                    Gen_Emit("AIMacro.ListContains(")
                    Gen_Expr(right)
                    Gen_Emit(", ")
                    Gen_Expr(left)
                    Gen_Emit(")")
                } ElseBlock: {
                    // Unknown type (e.g. function parameter) - use runtime dispatch
                    Gen_Emit("DictGen_SmartContains(")
                    Gen_Expr(right)
                    Gen_Emit(", ")
                    Gen_Expr(left)
                    Gen_Emit(")")
                }
            }
            ReturnValue(0)
        }

        // Default: normal binary op
        op_name = Gen_OpName(op)
        Gen_Emit(op_name)
        Gen_Emit("(")
        Gen_Expr(left)
        Gen_Emit(", ")
        Gen_Expr(right)
        Gen_Emit(")")
    }
}


// =============================================================================
// UNARY OPERATION
// =============================================================================
Function.Gen_UnaryOp {
    Input: node: Address
    Body: {
        op = ArrayGet(node, 3)
        operand = ArrayGet(node, 4)
        
        IfCondition EqualTo(op, Token.NOT) ThenBlock: {
            Gen_Emit("Not(")
            Gen_Expr(operand)
            Gen_Emit(")")
        } ElseBlock: {
            IfCondition EqualTo(op, Token.MINUS) ThenBlock: {
                Gen_Emit("Subtract(0, ")
                Gen_Expr(operand)
                Gen_Emit(")")
            }
        }
    }
}

// =============================================================================
// FUNCTION CALL
// =============================================================================
Function.Gen_CallExpr {
    Input: node: Address
    Body: {
        name = ArrayGet(node, 3)
        args = ArrayGet(node, 4)
        
        // Handle print specially
        cmp = StringCompare(name, "print")
        IfCondition EqualTo(cmp, 0) ThenBlock: {
            Gen_PrintCall(args)
            ReturnValue(0)
        }
        
        // Handle input specially - ensure we always pass a prompt argument
        cmp = StringCompare(name, "input")
        IfCondition EqualTo(cmp, 0) ThenBlock: {
            Gen_Emit("AIMacro.Input(")
            n = XArray.XSize(args)
            IfCondition EqualTo(n, 0) ThenBlock: {
                // No args - pass empty string
                Gen_Emit("\"\"")
            } ElseBlock: {
                // Has prompt arg - emit it (flatten if needed)
                arg = XArray.XGet(args, 0)
                has_call = Gen_HasCall(arg)
                IfCondition EqualTo(has_call, 1) ThenBlock: {
                    arg = Gen_FlattenExpr(arg)
                }
                Gen_Expr(arg)
            }
            Gen_Emit(")")
            ReturnValue(0)
        }
        
        // Handle isinstance specially - second arg is a type name
        cmp = StringCompare(name, "isinstance")
        IfCondition EqualTo(cmp, 0) ThenBlock: {
            Gen_Emit("Types.IsInstance(")
            arg0 = XArray.XGet(args, 0)
            Gen_Expr(arg0)
            Gen_Emit(", ")
            arg1 = XArray.XGet(args, 1)
            arg1_type = AST_Type(arg1)
            IfCondition EqualTo(arg1_type, Node.IDENT) ThenBlock: {
                type_name = ArrayGet(arg1, 3)
                type_const = Gen_MapTypeConstant(type_name)
                Gen_Emit(type_const)
            } ElseBlock: {
                Gen_Expr(arg1)
            }
            Gen_Emit(")")
            ReturnValue(0)
        }
        
        // Handle type() specially
        cmp = StringCompare(name, "type")
        IfCondition EqualTo(cmp, 0) ThenBlock: {
            Gen_Emit("Types.TypeOf(")
            n = XArray.XSize(args)
            IfCondition GreaterThan(n, 0) ThenBlock: {
                arg0 = XArray.XGet(args, 0)
                Gen_Expr(arg0)
            }
            Gen_Emit(")")
            ReturnValue(0)
        }
        
        // ===== Handle len() with dict detection =====
        // ===== Handle len() with dict/list detection =====
        cmp = StringCompare(name, "len")
        IfCondition EqualTo(cmp, 0) ThenBlock: {
            n = XArray.XSize(args)
            IfCondition GreaterThan(n, 0) ThenBlock: {
                arg0 = XArray.XGet(args, 0)
                arg0_type = AST_Type(arg0)
                is_dict_arg = 0
                is_list_arg = 0
                
                IfCondition EqualTo(arg0_type, Node.IDENT) ThenBlock: {
                    arg_name = ArrayGet(arg0, 3)
                    is_dict_arg = Gen_IsDictVar(arg_name)
                    is_list_arg = Gen_IsListVar(arg_name)
                }
                IfCondition EqualTo(arg0_type, Node.DICT_LIT) ThenBlock: {
                    is_dict_arg = 1
                }
                IfCondition EqualTo(arg0_type, Node.LIST_LIT) ThenBlock: {
                    is_list_arg = 1
                }
                
                IfCondition EqualTo(is_dict_arg, 1) ThenBlock: {
                    Gen_Emit("THash.Size(")
                    Gen_Expr(arg0)
                    Gen_Emit(")")
                    ReturnValue(0)
                }
                
                IfCondition EqualTo(is_list_arg, 1) ThenBlock: {
                    Gen_Emit("AIMacro.SmartLen(")
                    Gen_Expr(arg0)
                    Gen_Emit(")")
                    ReturnValue(0)
                }
                
                // Unknown type - use runtime dispatch
                Gen_Emit("DictGen_SmartLen(")
                Gen_Expr(arg0)
                Gen_Emit(")")
                ReturnValue(0)
            }
        }

        // ===== END len() dict handling =====

        // =========== OOP ADDITIONS ===========
        
        // Check for isinstance(obj, ClassName)
        cmp = StringCompare(name, "isinstance")
        IfCondition EqualTo(cmp, 0) ThenBlock: {
            OOPGen_IsInstance(node)
            ReturnValue(0)
        }
        
        // Check if this is a class instantiation: ClassName(args)
        // 'name' here is actually the function/class name string from the AST
        is_class = OOPGen_IsClassName(name)
        IfCondition EqualTo(is_class, 1) ThenBlock: {
            OOPGen_InstanceCreation(name, args)
            ReturnValue(0)
        }
        
        // =========== END OOP ADDITIONS ===========
        
        // =========== PACKED FUNCTION CALL (>6 params) ===========
        is_packed = Gen_IsPackedFunc(name)
        IfCondition EqualTo(is_packed, 1) ThenBlock: {
            Gen_PackedCall(name, args)
            ReturnValue(0)
        }
        // =========== END PACKED FUNCTION CALL ===========
        
        func_name = Gen_MapBuiltin(name)
        
        Gen_Emit(func_name)
        Gen_Emit("(")
        
        n = XArray.XSize(args)
        i = 0
        WhileLoop LessThan(i, n) {
            IfCondition GreaterThan(i, 0) ThenBlock: {
                Gen_Emit(", ")
            }
            arg = XArray.XGet(args, i)
            Gen_Expr(arg)
            i = Add(i, 1)
        }
        
        Gen_Emit(")")
    }
}

// =============================================================================
// PACK ARGUMENTS FOR >6 PARAM FUNCTION CALL
// =============================================================================
Function.Gen_PackedCall {
    Input: name: Address
    Input: args: Address
    Body: {
        n = XArray.XSize(args)
        
        // Create pack array name
        pack_name = Gen_TempName()
        
        // Emit: __packN = TArray.TCreate(n)
        Gen_EmitIndent()
        Gen_Emit(pack_name)
        Gen_Emit(" = TArray.TCreate(")
        n_str = NumberToString(n)
        Gen_Emit(n_str)
        Gen_Emit(")\n")
        Deallocate(n_str, 0)
        
        // Emit: TArray.TPush(__packN, arg) for each arg
        idx = 0
        WhileLoop LessThan(idx, n) {
            Gen_EmitIndent()
            Gen_Emit("TArray.TPush(")
            Gen_Emit(pack_name)
            Gen_Emit(", ")
            arg = XArray.XGet(args, idx)
            Gen_Expr(arg)
            Gen_Emit(")\n")
            idx = Add(idx, 1)
        }
        
        // Emit the call with packed array
        Gen_Emit(name)
        Gen_Emit("(")
        Gen_Emit(pack_name)
        Gen_Emit(")")
    }
}

// =============================================================================
// REPLACEMENT Gen_PrintCall - Uses Gen_FlattenExpr for all complex args
// =============================================================================
Function.Gen_PrintCall {
    Input: args: Address
    Body: {
        n = XArray.XSize(args)
        
        IfCondition EqualTo(n, 0) ThenBlock: {
            Gen_Emit("PrintMessage(\"\\n\")")
            ReturnValue(0)
        }
        
        i = 0
        WhileLoop LessThan(i, n) {
            arg = XArray.XGet(args, i)
            arg_type = AST_Type(arg)
            
            // String literal - use PrintMessage directly
            IfCondition EqualTo(arg_type, Node.STR_LIT) ThenBlock: {
                str = ArrayGet(arg, 3)
                Gen_Emit("PrintMessage(\"")
                Gen_EmitEscaped(str)
                Gen_Emit("\")")
            } ElseBlock: {
                // Number literal - use PrintNumber directly
                IfCondition EqualTo(arg_type, Node.NUM_LIT) ThenBlock: {
                    val = ArrayGet(arg, 3)
                    Gen_Emit("PrintNumber(")
                    Gen_EmitNumber(val)
                    Gen_Emit(")")
                } ElseBlock: {
                    // For anything else, check if needs flattening
                    has_call = Gen_HasCall(arg)
                    is_string = Gen_InvolvesString(arg)
                    needs_flatten = Or(EqualTo(has_call, 1), EqualTo(is_string, 1))
                    
                    IfCondition EqualTo(needs_flatten, 1) ThenBlock: {
                        // Flatten the entire expression tree
                        flat_arg = Gen_FlattenExpr(arg)
                        
                        // Now flat_arg is either an ident or simple expr
                        Gen_Emit("AIMacro.SmartPrint(")
                        Gen_Expr(flat_arg)
                        Gen_Emit(")")
                    } ElseBlock: {
                        // Simple variable or expression
                        Gen_Emit("AIMacro.SmartPrint(")
                        Gen_Expr(arg)
                        Gen_Emit(")")
                    }
                }
            }
            
            // Add space between args, newline at end
            IfCondition EqualTo(i, Subtract(n, 1)) ThenBlock: {
                Gen_Emit("\n")
                Gen_EmitIndent()
                Gen_Emit("PrintMessage(\"\\n\")")
            } ElseBlock: {
                Gen_Emit("\n")
                Gen_EmitIndent()
                Gen_Emit("PrintMessage(\" \")\n")
                Gen_EmitIndent()
            }
            
            i = Add(i, 1)
        }
    }
}

// =============================================================================
// MAP BUILTIN FUNCTIONS
// =============================================================================
Function.Gen_MapBuiltin {
    Input: name: Address
    Output: Address
    Body: {
        cmp = StringCompare(name, "len")
        IfCondition EqualTo(cmp, 0) ThenBlock: { ReturnValue("AIMacro.SmartLen") }
        
        cmp = StringCompare(name, "str")
        IfCondition EqualTo(cmp, 0) ThenBlock: { ReturnValue("AIMacro.Str") }
        
        cmp = StringCompare(name, "int")
        IfCondition EqualTo(cmp, 0) ThenBlock: { ReturnValue("AIMacro.Int") }
        
        cmp = StringCompare(name, "abs")
        IfCondition EqualTo(cmp, 0) ThenBlock: { ReturnValue("AIMacro.Abs") }
        
        cmp = StringCompare(name, "max")
        IfCondition EqualTo(cmp, 0) ThenBlock: { ReturnValue("AIMacro.Max") }
        
        cmp = StringCompare(name, "min")
        IfCondition EqualTo(cmp, 0) ThenBlock: { ReturnValue("AIMacro.Min") }
        
        cmp = StringCompare(name, "sum")
        IfCondition EqualTo(cmp, 0) ThenBlock: { ReturnValue("AIMacro.SmartSum") }  
        
        cmp = StringCompare(name, "ord")
        IfCondition EqualTo(cmp, 0) ThenBlock: { ReturnValue("AIMacro.Ord") }
        
        cmp = StringCompare(name, "chr")
        IfCondition EqualTo(cmp, 0) ThenBlock: { ReturnValue("AIMacro.Chr") }

        cmp = StringCompare(name, "bool")
        IfCondition EqualTo(cmp, 0) ThenBlock: { ReturnValue("AIMacro.Bool") }

        cmp = StringCompare(name, "any")
        IfCondition EqualTo(cmp, 0) ThenBlock: { ReturnValue("AIMacro.Any") }
        
        cmp = StringCompare(name, "all")
        IfCondition EqualTo(cmp, 0) ThenBlock: { ReturnValue("AIMacro.All") }

        // Use typed versions that return TArray
        cmp = StringCompare(name, "reversed")
        IfCondition EqualTo(cmp, 0) ThenBlock: { ReturnValue("AIMacro.TypedReversed") }
        
        cmp = StringCompare(name, "round")
        IfCondition EqualTo(cmp, 0) ThenBlock: { ReturnValue("AIMacro.Round") }
        
        cmp = StringCompare(name, "enumerate")
        IfCondition EqualTo(cmp, 0) ThenBlock: { ReturnValue("AIMacro.Enumerate") }
        
        cmp = StringCompare(name, "zip")
        IfCondition EqualTo(cmp, 0) ThenBlock: { ReturnValue("AIMacro.Zip") }

        // Use typed sorted that returns TArray
        cmp = StringCompare(name, "sorted")
        IfCondition EqualTo(cmp, 0) ThenBlock: { ReturnValue("AIMacro.TypedSorted") }

        cmp = StringCompare(name, "isinstance")
        IfCondition EqualTo(cmp, 0) ThenBlock: { ReturnValue("Types.IsInstance") }
        
        cmp = StringCompare(name, "type")
        IfCondition EqualTo(cmp, 0) ThenBlock: { ReturnValue("Types.TypeOf") }

        ReturnValue(name)
    }
}


// =============================================================================
// MAP TYPE NAME TO TYPEID CONSTANT
// Converts Python type names to TypeID.* constants
// =============================================================================
Function.Gen_MapTypeConstant {
    Input: name: Address
    Output: Address
    Body: {
        cmp = StringCompare(name, "int")
        IfCondition EqualTo(cmp, 0) ThenBlock: { ReturnValue("TypeID.INT") }
        
        cmp = StringCompare(name, "str")
        IfCondition EqualTo(cmp, 0) ThenBlock: { ReturnValue("TypeID.STR") }
        
        cmp = StringCompare(name, "list")
        IfCondition EqualTo(cmp, 0) ThenBlock: { ReturnValue("TypeID.LIST") }
        
        cmp = StringCompare(name, "dict")
        IfCondition EqualTo(cmp, 0) ThenBlock: { ReturnValue("TypeID.DICT") }
        
        cmp = StringCompare(name, "bool")
        IfCondition EqualTo(cmp, 0) ThenBlock: { ReturnValue("TypeID.BOOL") }
        
        cmp = StringCompare(name, "None")
        IfCondition EqualTo(cmp, 0) ThenBlock: { ReturnValue("TypeID.NONE") }
        
        cmp = StringCompare(name, "NoneType")
        IfCondition EqualTo(cmp, 0) ThenBlock: { ReturnValue("TypeID.NONE") }
        
        // Unknown type - return as-is (might be a variable)
        ReturnValue(name)
    }
}

// =============================================================================
// METHOD CALL - With type-aware dispatch for ambiguous methods
// =============================================================================
Function.Gen_MethodCallExpr {
    Input: node: Address
    Body: {
        obj = ArrayGet(node, 3)
        method = ArrayGet(node, 4)
        args = ArrayGet(node, 5)
        
        // ===== CHECK IF OBJECT IS A DICT =====
        obj_type = AST_Type(obj)
        is_dict = 0
        IfCondition EqualTo(obj_type, Node.IDENT) ThenBlock: {
            obj_name = ArrayGet(obj, 3)
            is_dict = Gen_IsDictVar(obj_name)
        }
        
        // ===== DICT METHODS =====
        IfCondition EqualTo(is_dict, 1) ThenBlock: {
            // d.keys()
            cmp = StringCompare(method, "keys")
            IfCondition EqualTo(cmp, 0) ThenBlock: {
                Gen_Emit("THash.Keys(")
                Gen_Expr(obj)
                Gen_Emit(")")
                ReturnValue(0)
            }
            
            // d.values()
            cmp = StringCompare(method, "values")
            IfCondition EqualTo(cmp, 0) ThenBlock: {
                Gen_Emit("THash.Values(")
                Gen_Expr(obj)
                Gen_Emit(")")
                ReturnValue(0)
            }
            
            // d.items()
            cmp = StringCompare(method, "items")
            IfCondition EqualTo(cmp, 0) ThenBlock: {
                Gen_Emit("THash.Items(")
                Gen_Expr(obj)
                Gen_Emit(")")
                ReturnValue(0)
            }
            
            // d.clear()
            cmp = StringCompare(method, "clear")
            IfCondition EqualTo(cmp, 0) ThenBlock: {
                Gen_Emit("THash.Clear(")
                Gen_Expr(obj)
                Gen_Emit(")")
                ReturnValue(0)
            }
            
            // d.get(key) or d.get(key, default)
            cmp = StringCompare(method, "get")
            IfCondition EqualTo(cmp, 0) ThenBlock: {
                n = XArray.XSize(args)
                IfCondition LessEqual(n, 1) ThenBlock: {
                    Gen_Emit("THash.Get(")
                    Gen_Expr(obj)
                    IfCondition EqualTo(n, 1) ThenBlock: {
                        Gen_Emit(", ")
                        arg0 = XArray.XGet(args, 0)
                        Gen_Expr(arg0)
                    }
                    Gen_Emit(")")
                } ElseBlock: {
                    Gen_Emit("DictGen_GetWithDefault(")
                    Gen_Expr(obj)
                    Gen_Emit(", ")
                    arg0 = XArray.XGet(args, 0)
                    Gen_Expr(arg0)
                    Gen_Emit(", ")
                    arg1 = XArray.XGet(args, 1)
                    Gen_Expr(arg1)
                    Gen_Emit(")")
                }
                ReturnValue(0)
            }
            
            // d.pop(key) - dict version
            cmp = StringCompare(method, "pop")
            IfCondition EqualTo(cmp, 0) ThenBlock: {
                Gen_Emit("DictGen_Pop(")
                Gen_Expr(obj)
                Gen_Emit(", ")
                arg0 = XArray.XGet(args, 0)
                Gen_Expr(arg0)
                Gen_Emit(")")
                ReturnValue(0)
            }
            
            // d.update(other)
            cmp = StringCompare(method, "update")
            IfCondition EqualTo(cmp, 0) ThenBlock: {
                Gen_Emit("DictGen_Update(")
                Gen_Expr(obj)
                Gen_Emit(", ")
                arg0 = XArray.XGet(args, 0)
                Gen_Expr(arg0)
                Gen_Emit(")")
                ReturnValue(0)
            }
            
            // d.copy()
            cmp = StringCompare(method, "copy")
            IfCondition EqualTo(cmp, 0) ThenBlock: {
                Gen_Emit("DictGen_Copy(")
                Gen_Expr(obj)
                Gen_Emit(")")
                ReturnValue(0)
            }
            
            // d.setdefault(key, default)
            cmp = StringCompare(method, "setdefault")
            IfCondition EqualTo(cmp, 0) ThenBlock: {
                Gen_Emit("DictGen_SetDefault(")
                Gen_Expr(obj)
                Gen_Emit(", ")
                arg0 = XArray.XGet(args, 0)
                Gen_Expr(arg0)
                Gen_Emit(", ")
                n = XArray.XSize(args)
                IfCondition GreaterThan(n, 1) ThenBlock: {
                    arg1 = XArray.XGet(args, 1)
                    Gen_Expr(arg1)
                } ElseBlock: {
                    Gen_Emit("0")
                }
                Gen_Emit(")")
                ReturnValue(0)
            }
        }
        // ===== END DICT METHODS =====
        
        // Check for ambiguous methods that need type dispatch
        cmp = StringCompare(method, "count")
        IfCondition EqualTo(cmp, 0) ThenBlock: {
            // Determine if object is a list or string
            obj_type = AST_Type(obj)
            is_list = 0
            
            IfCondition EqualTo(obj_type, Node.IDENT) ThenBlock: {
                obj_name = ArrayGet(obj, 3)
                is_list = Gen_IsListVar(obj_name)
            }
            IfCondition EqualTo(obj_type, Node.LIST_LIT) ThenBlock: {
                is_list = 1
            }
            
            IfCondition EqualTo(is_list, 1) ThenBlock: {
                Gen_Emit("AIMacro.ListCount(")
            } ElseBlock: {
                Gen_Emit("String.Count(")
            }
            Gen_Expr(obj)
            
            n = XArray.XSize(args)
            i = 0
            WhileLoop LessThan(i, n) {
                Gen_Emit(", ")
                arg = XArray.XGet(args, i)
                Gen_Expr(arg)
                i = Add(i, 1)
            }
            
            Gen_Emit(")")
            ReturnValue(0)
        }
        
        // Handle pop() - check if it has an argument (LIST version)
        cmp = StringCompare(method, "pop")
        IfCondition EqualTo(cmp, 0) ThenBlock: {
            n = XArray.XSize(args)
            IfCondition EqualTo(n, 0) ThenBlock: {
                // No args - use SmartPop (handles both XArray and TArray)
                Gen_Emit("AIMacro.SmartPop(")
                Gen_Expr(obj)
                Gen_Emit(")")
            } ElseBlock: {
                // Has index arg - use SmartPopAt
                Gen_Emit("AIMacro.SmartPopAt(")
                Gen_Expr(obj)
                Gen_Emit(", ")
                arg = XArray.XGet(args, 0)
                Gen_Expr(arg)
                Gen_Emit(")")
            }
            ReturnValue(0)
        }

        // =========== OOP ADDITIONS ===========
        
        // If we reach here, this might be an OOP method call
        // Check if the object is an OOP instance (not a dict, list, or string)
        // For now, use OOP dispatch for any unrecognized method
        
        // If object is a known OOP variable, use OOP.MethodCall
        // This requires tracking which variables hold OOP objects
        // For simplicity, we can check if it's NOT a known dict/list/string
        
        obj_type = AST_Type(obj)
        IfCondition EqualTo(obj_type, Node.IDENT) ThenBlock: {
            obj_name = ArrayGet(obj, 3)
            is_dict = Gen_IsDictVar(obj_name)
            is_list = Gen_IsListVar(obj_name)
            is_str = Gen_IsStringVar(obj_name)
            
            // If not a known container type, try OOP dispatch
            IfCondition And(EqualTo(is_dict, 0), And(EqualTo(is_list, 0), EqualTo(is_str, 0))) ThenBlock: {
                OOPGen_MethodCall(node)
                ReturnValue(0)
            }
        }
        
        // =========== END OOP ADDITIONS ===========

        // Normal method dispatch for non-ambiguous methods
        func = Gen_MapMethod(method)
        
        Gen_Emit(func)
        Gen_Emit("(")
        Gen_Expr(obj)
        
        n = XArray.XSize(args)
        i = 0
        WhileLoop LessThan(i, n) {
            Gen_Emit(", ")
            arg = XArray.XGet(args, i)
            Gen_Expr(arg)
            i = Add(i, 1)
        }
        
        Gen_Emit(")")
    }
}

// =============================================================================
// MAP METHODS
// =============================================================================
Function.Gen_MapMethod {
    Input: method: Address
    Output: Address
    Body: {
        // List methods - use smart versions that handle both XArray and TArray
        cmp = StringCompare(method, "append")
        IfCondition EqualTo(cmp, 0) ThenBlock: { ReturnValue("AIMacro.SmartPush") }
        
         cmp = StringCompare(method, "pop")
        IfCondition EqualTo(cmp, 0) ThenBlock: { ReturnValue("AIMacro.SmartPop") }
        
        // String methods (unchanged)
        cmp = StringCompare(method, "upper")
        IfCondition EqualTo(cmp, 0) ThenBlock: { ReturnValue("String.Upper") }
        
        cmp = StringCompare(method, "lower")
        IfCondition EqualTo(cmp, 0) ThenBlock: { ReturnValue("String.Lower") }
        
        cmp = StringCompare(method, "strip")
        IfCondition EqualTo(cmp, 0) ThenBlock: { ReturnValue("String.Strip") }
        
        cmp = StringCompare(method, "lstrip")
        IfCondition EqualTo(cmp, 0) ThenBlock: { ReturnValue("String.LStrip") }
        
        cmp = StringCompare(method, "rstrip")
        IfCondition EqualTo(cmp, 0) ThenBlock: { ReturnValue("String.RStrip") }
        
        cmp = StringCompare(method, "split")
        IfCondition EqualTo(cmp, 0) ThenBlock: { ReturnValue("String.Split") }
        
        cmp = StringCompare(method, "join")
        IfCondition EqualTo(cmp, 0) ThenBlock: { ReturnValue("String.Join") }
        
        cmp = StringCompare(method, "replace")
        IfCondition EqualTo(cmp, 0) ThenBlock: { ReturnValue("String.Replace") }
        
        cmp = StringCompare(method, "find")
        IfCondition EqualTo(cmp, 0) ThenBlock: { ReturnValue("String.Find") }
        
        cmp = StringCompare(method, "startswith")
        IfCondition EqualTo(cmp, 0) ThenBlock: { ReturnValue("String.StartsWith") }
        
        cmp = StringCompare(method, "endswith")
        IfCondition EqualTo(cmp, 0) ThenBlock: { ReturnValue("String.EndsWith") }
        
        cmp = StringCompare(method, "count")
        IfCondition EqualTo(cmp, 0) ThenBlock: { ReturnValue("String.Count") }
        
        cmp = StringCompare(method, "isdigit")
        IfCondition EqualTo(cmp, 0) ThenBlock: { ReturnValue("String.IsDigit") }
        
        cmp = StringCompare(method, "isalpha")
        IfCondition EqualTo(cmp, 0) ThenBlock: { ReturnValue("String.IsAlpha") }
        
        cmp = StringCompare(method, "isalnum")
        IfCondition EqualTo(cmp, 0) ThenBlock: { ReturnValue("String.IsAlnum") }

        // Other list methods
        cmp = StringCompare(method, "clear")
        IfCondition EqualTo(cmp, 0) ThenBlock: { ReturnValue("AIMacro.SmartClear") }
        
        cmp = StringCompare(method, "index")
        IfCondition EqualTo(cmp, 0) ThenBlock: { ReturnValue("AIMacro.ListIndex") }

        cmp = StringCompare(method, "copy")
        IfCondition EqualTo(cmp, 0) ThenBlock: { ReturnValue("AIMacro.TypedListCopy") }
        
        cmp = StringCompare(method, "extend")
        IfCondition EqualTo(cmp, 0) ThenBlock: { ReturnValue("AIMacro.ListExtend") }

        cmp = StringCompare(method, "remove")
        IfCondition EqualTo(cmp, 0) ThenBlock: { ReturnValue("AIMacro.ListRemove") }
        
        cmp = StringCompare(method, "insert")
        IfCondition EqualTo(cmp, 0) ThenBlock: { ReturnValue("AIMacro.ListInsert") }
                
        ReturnValue(method)
    }
}

// =============================================================================
// Gen_IndexAccess - FIXED VERSION
// Handles both string and list indexing, including negative indices
// =============================================================================

Function.Gen_IndexAccess {
    Input: node: Address
    Body: {
        expr = ArrayGet(node, 3)
        index = ArrayGet(node, 4)
        
        expr_type = AST_Type(expr)
        is_string_access = 0
        is_dict_access = 0
        
        IfCondition EqualTo(expr_type, Node.IDENT) ThenBlock: {
            var_name = ArrayGet(expr, 3)
            is_str = Gen_IsStringVar(var_name)
            IfCondition EqualTo(is_str, 1) ThenBlock: {
                is_string_access = 1
            }
            is_dict = Gen_IsDictVar(var_name)
            IfCondition EqualTo(is_dict, 1) ThenBlock: {
                is_dict_access = 1
            }
        }
        IfCondition EqualTo(expr_type, Node.STR_LIT) ThenBlock: {
            is_string_access = 1
        }
        
        // DICT INDEXING
        IfCondition EqualTo(is_dict_access, 1) ThenBlock: {
            Gen_Emit("THash.Get(")
            Gen_Expr(expr)
            Gen_Emit(", ")
            Gen_Expr(index)
            Gen_Emit(")")
            ReturnValue(0)
        }
        
        index_type = AST_Type(index)
        is_negative = 0
        neg_value = 0
        
        IfCondition EqualTo(index_type, Node.UNARY_OP) ThenBlock: {
            op = ArrayGet(index, 3)
            IfCondition EqualTo(op, Token.MINUS) ThenBlock: {
                operand = ArrayGet(index, 4)
                operand_type = AST_Type(operand)
                IfCondition EqualTo(operand_type, Node.NUM_LIT) ThenBlock: {
                    is_negative = 1
                    neg_value = ArrayGet(operand, 3)
                }
            }
        }
        
        // STRING INDEXING
        IfCondition EqualTo(is_string_access, 1) ThenBlock: {
            IfCondition EqualTo(is_negative, 1) ThenBlock: {
                Gen_Emit("AIMacro.Chr(GetByte(")
                Gen_Expr(expr)
                Gen_Emit(", Subtract(StringLength(")
                Gen_Expr(expr)
                Gen_Emit("), ")
                Gen_EmitNumber(neg_value)
                Gen_Emit(")))")
            } ElseBlock: {
                Gen_Emit("AIMacro.Chr(GetByte(")
                Gen_Expr(expr)
                Gen_Emit(", ")
                Gen_Expr(index)
                Gen_Emit("))")
            }
            ReturnValue(0)
        }
        
        // ARRAY INDEXING - SmartGet/SmartSize (handles XArray & TArray)
        IfCondition EqualTo(is_negative, 1) ThenBlock: {
            Gen_Emit("DictGen_SmartGet(")
            Gen_Expr(expr)
            Gen_Emit(", Subtract(AIMacro.SmartSize(")
            Gen_Expr(expr)
            Gen_Emit("), ")
            Gen_EmitNumber(neg_value)
            Gen_Emit("))")
        } ElseBlock: {
            Gen_Emit("DictGen_SmartGet(")
            Gen_Expr(expr)
            Gen_Emit(", ")
            Gen_Expr(index)
            Gen_Emit(")")
        }
    }
}
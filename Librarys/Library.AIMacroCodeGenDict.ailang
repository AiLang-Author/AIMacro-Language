// Library.AIMacroCodeGenDict.ailang
// Dictionary Code Generation for AIMacro
// Uses THash (typed hash table with magic number) for Python dict support
//
// This library handles all dict-related code generation:
// - Dict literal assignment: d = {"key": value}
// - Dict access: d["key"]
// - Dict assignment: d["key"] = value
// - Dict methods: d.keys(), d.values(), d.items(), d.get(), d.pop()
// - Type checking: isinstance(x, dict)
//
// Dependencies: XArrays, AIMacroCore, AIMacroParserCore, AIMacroCodeGen1

LibraryImport.XArrays
LibraryImport.AIMacroCore
LibraryImport.AIMacroParserCore
LibraryImport.AIMacroCodeGen1

// =============================================================================
// DICT VARIABLE TRACKING
// Track which variables are dicts for proper method dispatch
// =============================================================================
FixedPool.DictGen {
    "dict_vars": Initialize=0, CanChange=True
}

Function.DictGen_Init {
    Body: {
        DictGen.dict_vars = XArray.XCreate(32)
    }
}

Function.DictGen_Free {
    Body: {
        IfCondition NotEqual(DictGen.dict_vars, 0) ThenBlock: {
            // Free copied names
            sz = XArray.XSize(DictGen.dict_vars)
            i = 0
            WhileLoop LessThan(i, sz) {
                name = XArray.XGet(DictGen.dict_vars, i)
                IfCondition NotEqual(name, 0) ThenBlock: {
                    Deallocate(name, 0)
                }
                i = Add(i, 1)
            }
            XArray.XDestroy(DictGen.dict_vars)
            DictGen.dict_vars = 0
        }
    }
}

Function.DictGen_Reset {
    Body: {
        // Clear for new function - called from Gen_Function
        IfCondition NotEqual(DictGen.dict_vars, 0) ThenBlock: {
            XArray.XClear(DictGen.dict_vars)
        }
    }
}

Function.DictGen_IsDictVar {
    Input: name: Address
    Output: Integer
    Body: {
        IfCondition EqualTo(name, 0) ThenBlock: {
            ReturnValue(0)
        }
        IfCondition EqualTo(DictGen.dict_vars, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        sz = XArray.XSize(DictGen.dict_vars)
        idx = 0
        WhileLoop LessThan(idx, sz) {
            varname = XArray.XGet(DictGen.dict_vars, idx)
            cmp = StringCompare(name, varname)
            IfCondition EqualTo(cmp, 0) ThenBlock: {
                ReturnValue(1)
            }
            idx = Add(idx, 1)
        }
        ReturnValue(0)
    }
}

Function.DictGen_MarkDictVar {
    Input: name: Address
    Body: {
        IfCondition EqualTo(name, 0) ThenBlock: {
            ReturnValue(0)
        }
        IfCondition EqualTo(DictGen.dict_vars, 0) ThenBlock: {
            DictGen.dict_vars = XArray.XCreate(32)
        }
        
        // Check if already tracked
        already = DictGen_IsDictVar(name)
        IfCondition EqualTo(already, 1) ThenBlock: {
            ReturnValue(0)
        }
        
        // Copy the name and add to list
        len = StringLength(name)
        copy = Allocate(Add(len, 1))
        i = 0
        WhileLoop LessThan(i, len) {
            c = GetByte(name, i)
            SetByte(copy, i, c)
            i = Add(i, 1)
        }
        SetByte(copy, len, 0)
        
        XArray.XPush(DictGen.dict_vars, copy)
    }
}

// =============================================================================
// DICT LITERAL ASSIGNMENT
// Python: d = {"name": "test", "count": 42}
// AILang: d = THash.Create(16)
//         THash.Set(d, "name", "test")
//         THash.Set(d, "count", 42)
// =============================================================================
Function.DictGen_Assignment {
    Input: target: Address
    Input: dict_node: Address
    Body: {
        pairs = ArrayGet(dict_node, 3)
        n = XArray.XSize(pairs)
        num_pairs = Divide(n, 2)
        
        // Mark this variable as a dict
        DictGen_MarkDictVar(target)
        
        // Calculate capacity (at least 16, or 2x pairs)
        capacity = Multiply(num_pairs, 2)
        IfCondition LessThan(capacity, 16) ThenBlock: {
            capacity = 16
        }
        
        // Emit: target = THash.Create(capacity)
        Gen_EmitIndent()
        Gen_EmitIdent(target)
        Gen_Emit(" = THash.Create(")
        Gen_EmitNumber(capacity)
        Gen_Emit(")\n")
        
        // Emit THash.Set for each key-value pair
        i = 0
        WhileLoop LessThan(i, n) {
            key = XArray.XGet(pairs, i)
            value = XArray.XGet(pairs, Add(i, 1))
            
            // Flatten key if needed
            key_has_call = Gen_HasCall(key)
            IfCondition EqualTo(key_has_call, 1) ThenBlock: {
                key = Gen_FlattenExpr(key)
            }
            
            // Flatten value if needed
            value_has_call = Gen_HasCall(value)
            IfCondition EqualTo(value_has_call, 1) ThenBlock: {
                value = Gen_FlattenExpr(value)
            }
            
            Gen_EmitIndent()
            Gen_Emit("THash.Set(")
            Gen_EmitIdent(target)
            Gen_Emit(", ")
            Gen_Expr(key)
            Gen_Emit(", ")
            Gen_Expr(value)
            Gen_Emit(")\n")
            
            i = Add(i, 2)
        }
    }
}

// =============================================================================
// DICT ACCESS (GET)
// Python: value = d["key"]
// AILang: value = THash.Get(d, "key")
// =============================================================================
Function.DictGen_Access {
    Input: expr: Address
    Input: key: Address
    Body: {
        Gen_Emit("THash.Get(")
        Gen_Expr(expr)
        Gen_Emit(", ")
        Gen_Expr(key)
        Gen_Emit(")")
    }
}

// =============================================================================
// DICT INDEX ASSIGNMENT
// Python: d["key"] = value
// AILang: THash.Set(d, "key", value)
// =============================================================================
Function.DictGen_IndexAssign {
    Input: expr: Address
    Input: key: Address
    Input: value: Address
    Body: {
        // Flatten key if needed
        key_has_call = Gen_HasCall(key)
        IfCondition EqualTo(key_has_call, 1) ThenBlock: {
            key = Gen_FlattenExpr(key)
        }
        
        // Flatten value if needed
        value_has_call = Gen_HasCall(value)
        IfCondition EqualTo(value_has_call, 1) ThenBlock: {
            value = Gen_FlattenExpr(value)
        }
        
        Gen_EmitIndent()
        Gen_Emit("THash.Set(")
        Gen_Expr(expr)
        Gen_Emit(", ")
        Gen_Expr(key)
        Gen_Emit(", ")
        Gen_Expr(value)
        Gen_Emit(")\n")
    }
}

// =============================================================================
// DICT METHOD CALLS
// Maps Python dict methods to THash functions
// =============================================================================
Function.DictGen_MethodCall {
    Input: obj: Address
    Input: method: Address
    Input: args: Address
    Output: Integer   // Returns 1 if handled, 0 if not a dict method
    Body: {
        // Check if this is a known dict variable
        obj_type = AST_Type(obj)
        is_dict = 0
        
        IfCondition EqualTo(obj_type, Node.IDENT) ThenBlock: {
            obj_name = ArrayGet(obj, 3)
            is_dict = DictGen_IsDictVar(obj_name)
        }
        IfCondition EqualTo(obj_type, Node.DICT_LIT) ThenBlock: {
            is_dict = 1
        }
        
        // If not a known dict, return 0 to let normal method handling proceed
        IfCondition EqualTo(is_dict, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        // Handle dict methods
        
        // d.get(key) or d.get(key, default)
        cmp = StringCompare(method, "get")
        IfCondition EqualTo(cmp, 0) ThenBlock: {
            n = XArray.XSize(args)
            IfCondition EqualTo(n, 1) ThenBlock: {
                // d.get(key) - returns 0 if not found
                Gen_Emit("THash.Get(")
                Gen_Expr(obj)
                Gen_Emit(", ")
                arg0 = XArray.XGet(args, 0)
                Gen_Expr(arg0)
                Gen_Emit(")")
            } ElseBlock: {
                // d.get(key, default) - need to check Contains first
                // This requires a more complex pattern, emit inline
                Gen_Emit("DictGen_GetWithDefault(")
                Gen_Expr(obj)
                Gen_Emit(", ")
                arg0 = XArray.XGet(args, 0)
                Gen_Expr(arg0)
                Gen_Emit(", ")
                arg1 = XArray.XGet(args, 1)
                Gen_Expr(arg1)
                Gen_Emit(")")
            }
            ReturnValue(1)
        }
        
        // d.keys()
        cmp = StringCompare(method, "keys")
        IfCondition EqualTo(cmp, 0) ThenBlock: {
            Gen_Emit("THash.Keys(")
            Gen_Expr(obj)
            Gen_Emit(")")
            ReturnValue(1)
        }
        
        // d.values()
        cmp = StringCompare(method, "values")
        IfCondition EqualTo(cmp, 0) ThenBlock: {
            Gen_Emit("THash.Values(")
            Gen_Expr(obj)
            Gen_Emit(")")
            ReturnValue(1)
        }
        
        // d.items()
        cmp = StringCompare(method, "items")
        IfCondition EqualTo(cmp, 0) ThenBlock: {
            Gen_Emit("THash.Items(")
            Gen_Expr(obj)
            Gen_Emit(")")
            ReturnValue(1)
        }
        
        // d.pop(key) or d.pop(key, default)
        cmp = StringCompare(method, "pop")
        IfCondition EqualTo(cmp, 0) ThenBlock: {
            // Get value then delete
            // For simplicity, emit as sequence
            Gen_Emit("DictGen_Pop(")
            Gen_Expr(obj)
            Gen_Emit(", ")
            arg0 = XArray.XGet(args, 0)
            Gen_Expr(arg0)
            Gen_Emit(")")
            ReturnValue(1)
        }
        
        // d.clear()
        cmp = StringCompare(method, "clear")
        IfCondition EqualTo(cmp, 0) ThenBlock: {
            Gen_Emit("THash.Clear(")
            Gen_Expr(obj)
            Gen_Emit(")")
            ReturnValue(1)
        }
        
        // d.update(other_dict) - not implemented yet
        // d.setdefault(key, default) - not implemented yet
        
        // Not a dict method we handle
        ReturnValue(0)
    }
}

// =============================================================================
// DICT MEMBERSHIP TEST
// Python: "key" in d  or  "key" not in d
// AILang: THash.Contains(d, "key")
// =============================================================================
Function.DictGen_Contains {
    Input: dict_expr: Address
    Input: key_expr: Address
    Body: {
        Gen_Emit("THash.Contains(")
        Gen_Expr(dict_expr)
        Gen_Emit(", ")
        Gen_Expr(key_expr)
        Gen_Emit(")")
    }
}

// =============================================================================
// DICT LEN
// Python: len(d)
// AILang: THash.Size(d)
// =============================================================================
Function.DictGen_Len {
    Input: dict_expr: Address
    Body: {
        Gen_Emit("THash.Size(")
        Gen_Expr(dict_expr)
        Gen_Emit(")")
    }
}

// =============================================================================
// DICT FOR LOOP: for key in d.keys():  OR  for k, v in d.items():
// =============================================================================
Function.DictGen_ForKeys {
    Input: var_name: Address
    Input: dict_expr: Address
    Input: body: Address
    Body: {
        // Generate: keys = THash.Keys(dict)
        //           iterlen = TArray.TSize(keys)
        //           i = 0
        //           WhileLoop i < iterlen:
        //               var_name = TArray.TGet(keys, i)
        //               <body>
        //               i = i + 1
        
        loop_id = Gen.temp_counter
        Gen.temp_counter = Add(Gen.temp_counter, 1)
        loop_suffix = NumberToString(loop_id)
        
        // keys = THash.Keys(dict)
        Gen_EmitIndent()
        Gen_Emit("keys")
        Gen_Emit(loop_suffix)
        Gen_Emit(" = THash.Keys(")
        Gen_Expr(dict_expr)
        Gen_Emit(")\n")
        
        // iterlen = TArray.TSize(keys)
        Gen_EmitIndent()
        Gen_Emit("iterlen")
        Gen_Emit(loop_suffix)
        Gen_Emit(" = TArray.TSize(keys")
        Gen_Emit(loop_suffix)
        Gen_Emit(")\n")
        
        // i = 0
        Gen_EmitIndent()
        Gen_Emit("iteri")
        Gen_Emit(loop_suffix)
        Gen_Emit(" = 0\n")
        
        // WhileLoop
        Gen_EmitIndent()
        Gen_Emit("WhileLoop LessThan(iteri")
        Gen_Emit(loop_suffix)
        Gen_Emit(", iterlen")
        Gen_Emit(loop_suffix)
        Gen_Emit(") {\n")
        
        Gen.indent = Add(Gen.indent, 1)
        
        // var_name = TArray.TGet(keys, i)
        Gen_EmitIndent()
        Gen_EmitIdent(var_name)
        Gen_Emit(" = TArray.TGet(keys")
        Gen_Emit(loop_suffix)
        Gen_Emit(", iteri")
        Gen_Emit(loop_suffix)
        Gen_Emit(")\n")
        
        // Body
        Gen_Body(body)
        
        // i = i + 1
        Gen_EmitIndent()
        Gen_Emit("iteri")
        Gen_Emit(loop_suffix)
        Gen_Emit(" = Add(iteri")
        Gen_Emit(loop_suffix)
        Gen_Emit(", 1)\n")
        
        Gen.indent = Subtract(Gen.indent, 1)
        Gen_EmitIndent()
        Gen_Emit("}\n")
        
        Deallocate(loop_suffix, 0)
    }
}

Function.DictGen_ForItems {
    Input: key_var: Address
    Input: val_var: Address
    Input: dict_expr: Address
    Input: body: Address
    Body: {
        // Generate: items = THash.Items(dict)
        //           iterlen = TArray.TSize(items)
        //           i = 0
        //           WhileLoop i < iterlen:
        //               pair = TArray.TGet(items, i)
        //               key_var = TArray.TGet(pair, 0)
        //               val_var = TArray.TGet(pair, 1)
        //               <body>
        //               i = i + 1
        
        loop_id = Gen.temp_counter
        Gen.temp_counter = Add(Gen.temp_counter, 1)
        loop_suffix = NumberToString(loop_id)
        
        // items = THash.Items(dict)
        Gen_EmitIndent()
        Gen_Emit("items")
        Gen_Emit(loop_suffix)
        Gen_Emit(" = THash.Items(")
        Gen_Expr(dict_expr)
        Gen_Emit(")\n")
        
        // iterlen = TArray.TSize(items)
        Gen_EmitIndent()
        Gen_Emit("iterlen")
        Gen_Emit(loop_suffix)
        Gen_Emit(" = TArray.TSize(items")
        Gen_Emit(loop_suffix)
        Gen_Emit(")\n")
        
        // i = 0
        Gen_EmitIndent()
        Gen_Emit("iteri")
        Gen_Emit(loop_suffix)
        Gen_Emit(" = 0\n")
        
        // WhileLoop
        Gen_EmitIndent()
        Gen_Emit("WhileLoop LessThan(iteri")
        Gen_Emit(loop_suffix)
        Gen_Emit(", iterlen")
        Gen_Emit(loop_suffix)
        Gen_Emit(") {\n")
        
        Gen.indent = Add(Gen.indent, 1)
        
        // pair = TArray.TGet(items, i)
        Gen_EmitIndent()
        Gen_Emit("__pair")
        Gen_Emit(loop_suffix)
        Gen_Emit(" = TArray.TGet(items")
        Gen_Emit(loop_suffix)
        Gen_Emit(", iteri")
        Gen_Emit(loop_suffix)
        Gen_Emit(")\n")
        
        // key_var = TArray.TGet(pair, 0)
        Gen_EmitIndent()
        Gen_EmitIdent(key_var)
        Gen_Emit(" = TArray.TGet(__pair")
        Gen_Emit(loop_suffix)
        Gen_Emit(", 0)\n")
        
        // val_var = TArray.TGet(pair, 1)
        Gen_EmitIndent()
        Gen_EmitIdent(val_var)
        Gen_Emit(" = TArray.TGet(__pair")
        Gen_Emit(loop_suffix)
        Gen_Emit(", 1)\n")
        
        // Body
        Gen_Body(body)
        
        // i = i + 1
        Gen_EmitIndent()
        Gen_Emit("iteri")
        Gen_Emit(loop_suffix)
        Gen_Emit(" = Add(iteri")
        Gen_Emit(loop_suffix)
        Gen_Emit(", 1)\n")
        
        Gen.indent = Subtract(Gen.indent, 1)
        Gen_EmitIndent()
        Gen_Emit("}\n")
        
        Deallocate(loop_suffix, 0)
    }
}

// =============================================================================
// CHECK IF EXPRESSION IS A DICT
// Used for type dispatch in len(), 'in' operator, etc.
// =============================================================================
Function.DictGen_IsDict {
    Input: node: Address
    Output: Integer
    Body: {
        IfCondition EqualTo(node, 0) ThenBlock: {
            ReturnValue(0)
        }
        
        t = AST_Type(node)
        
        // Dict literal
        IfCondition EqualTo(t, Node.DICT_LIT) ThenBlock: {
            ReturnValue(1)
        }
        
        // Known dict variable
        IfCondition EqualTo(t, Node.IDENT) ThenBlock: {
            name = ArrayGet(node, 3)
            ReturnValue(DictGen_IsDictVar(name))
        }
        
        // Method call that returns dict (e.g., d.copy())
        // For now, not handling these
        
        ReturnValue(0)
    }
}

// =============================================================================
// HELPER: Create inline dict expression
// Used when dict literal appears in expression context (not assignment)
// =============================================================================
Function.DictGen_CreateLiteral {
    Input: dict_node: Address
    Output: Address
    Body: {
        pairs = ArrayGet(dict_node, 3)
        n = XArray.XSize(pairs)
        num_pairs = Divide(n, 2)
        
        // Calculate capacity
        capacity = Multiply(num_pairs, 2)
        IfCondition LessThan(capacity, 16) ThenBlock: {
            capacity = 16
        }
        
        // Create temp for the dict
        temp = Gen_TempName()
        DictGen_MarkDictVar(temp)
        
        // Emit: temp = THash.Create(capacity)
        Gen_EmitIndent()
        Gen_Emit(temp)
        Gen_Emit(" = THash.Create(")
        Gen_EmitNumber(capacity)
        Gen_Emit(")\n")
        
        // Emit THash.Set for each pair
        i = 0
        WhileLoop LessThan(i, n) {
            key = XArray.XGet(pairs, i)
            value = XArray.XGet(pairs, Add(i, 1))
            
            // Flatten if needed
            key_has_call = Gen_HasCall(key)
            IfCondition EqualTo(key_has_call, 1) ThenBlock: {
                key = Gen_FlattenExpr(key)
            }
            value_has_call = Gen_HasCall(value)
            IfCondition EqualTo(value_has_call, 1) ThenBlock: {
                value = Gen_FlattenExpr(value)
            }
            
            Gen_EmitIndent()
            Gen_Emit("THash.Set(")
            Gen_Emit(temp)
            Gen_Emit(", ")
            Gen_Expr(key)
            Gen_Emit(", ")
            Gen_Expr(value)
            Gen_Emit(")\n")
            
            i = Add(i, 2)
        }
        
        // Return identifier node for the temp
        ReturnValue(Gen_MakeIdent(temp))
    }
}

// =============================================================================
// LIBRARY INITIALIZATION
// =============================================================================
SubRoutine.InitializeDictGenLibrary {
    PrintMessage("AIMacroCodeGenDict Library Loaded\n")
    DictGen_Init()
}

RunTask(InitializeDictGenLibrary)
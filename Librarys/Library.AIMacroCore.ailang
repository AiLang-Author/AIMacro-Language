// Library.AIMacroCore.ailang
// Core AIMacro Compiler Infrastructure - Pure AILang Implementation
// This is the foundation for bootstrapping the AIMacro->AILang compiler
//
// Dependencies: XArrays
// Usage: LibraryImport.AIMacroCore

LibraryImport.XArrays

FixedPool.Token {
    "NUMBER": Initialize=1
    "STRING": Initialize=2
    "IDENTIFIER": Initialize=3
    "DEF": Initialize=10
    "END": Initialize=11
    "IF": Initialize=12
    "ELIF": Initialize=13
    "ELSE": Initialize=14
    "WHILE": Initialize=15
    "FOR": Initialize=16
    "IN": Initialize=17
    "RETURN": Initialize=18
    "PASS": Initialize=19
    "BREAK": Initialize=20
    "CONTINUE": Initialize=21
    "EXCEPT": Initialize=25
    "FINALLY": Initialize=26
    "TRY": Initialize=27
    "TRUE": Initialize=30
    "FALSE": Initialize=31
    "NONE": Initialize=32
    "AND": Initialize=40
    "OR": Initialize=41
    "NOT": Initialize=42
    "IS": Initialize=43
    "PLUS": Initialize=50
    "MINUS": Initialize=51
    "STAR": Initialize=52
    "SLASH": Initialize=53
    "FLOOR_DIV": Initialize=54
    "PERCENT": Initialize=55
    "POWER": Initialize=56
    "ASSIGN": Initialize=60
    "PLUS_EQ": Initialize=61
    "MINUS_EQ": Initialize=62
    "STAR_EQ": Initialize=63
    "SLASH_EQ": Initialize=64
    "MOD_EQ": Initialize=65
    "POWER_EQ": Initialize=66
    "FLOOR_DIV_EQ": Initialize=68
    "EQ": Initialize=70
    "NE": Initialize=71
    "LT": Initialize=72
    "LE": Initialize=73
    "GT": Initialize=74
    "GE": Initialize=75
    "LPAREN": Initialize=80
    "RPAREN": Initialize=81
    "LBRACKET": Initialize=82
    "RBRACKET": Initialize=83
    "LBRACE": Initialize=84
    "RBRACE": Initialize=85
    "COMMA": Initialize=86
    "COLON": Initialize=87
    "SEMICOLON": Initialize=88
    "DOT": Initialize=89
    "ARROW": Initialize=90
    "NEWLINE": Initialize=100
    "EOF": Initialize=101
    "COMMENT": Initialize=102
    "ERROR": Initialize=199
     "IMPORT": Initialize=200
    "FROM": Initialize=201  
      
}

FixedPool.Node {
    "PROGRAM": Initialize=1
    "FUNCTION": Initialize=2
    "IF_STMT": Initialize=3
    "WHILE_STMT": Initialize=4
    "FOR_STMT": Initialize=5
    "RETURN_STMT": Initialize=6
    "ASSIGNMENT": Initialize=7
    "BINARY_OP": Initialize=8
    "UNARY_OP": Initialize=9
    "CALL": Initialize=10
    "METHOD_CALL": Initialize=11
    "INDEX_ACCESS": Initialize=12
    "INDEX_ASSIGN": Initialize=13
    "IDENT": Initialize=14
    "NUM_LIT": Initialize=15
    "STR_LIT": Initialize=16
    "BOOL_LIT": Initialize=17
    "LIST_LIT": Initialize=18
    "DICT_LIT": Initialize=19
    "EXPR_STMT": Initialize=20
    "BREAK_STMT": Initialize=21
    "CONTINUE_STMT": Initialize=22
    "AUG_ASSIGN": Initialize=23
    "PASS_STMT": Initialize=24
    "SLICE_ACCESS": Initialize=25
    "TUPLE_UNPACK": Initialize=26
    "TUPLE_FOR": Initialize=27
    "TRY_STMT": Initialize=28
    "EXCEPT_CLAUSE": Initialize=29
     "CLASS_DEF": Initialize=100
    "METHOD_DEF": Initialize=101
    "ATTRIBUTE": Initialize=102
    "ATTR_ASSIGN": Initialize=103
    "METHOD_CALL": Initialize=104
    "SUPER_CALL": Initialize=105
    "STR_EQ": Initialize=106
    "STR_NE": Initialize=107
    "IMPORT": Initialize=110
    "FROM_IMPORT": Initialize=111
}

FixedPool.Lex {
    "src": Initialize=0, CanChange=True
    "len": Initialize=0, CanChange=True
    "pos": Initialize=0, CanChange=True
    "line": Initialize=1, CanChange=True
    "col": Initialize=1, CanChange=True
    "tok_types": Initialize=0, CanChange=True
    "tok_vals": Initialize=0, CanChange=True
    "tok_lines": Initialize=0, CanChange=True
    "tok_cols": Initialize=0, CanChange=True
    "count": Initialize=0, CanChange=True
    "buf": Initialize=0, CanChange=True
    "buf_size": Initialize=512
}

// =============================================================================
// LEXER INITIALIZATION
// =============================================================================
Function.Lex_Init {
    Input: source: Address
    Input: length: Integer
    Body: {
        Lex.src = source
        Lex.len = length
        Lex.pos = 0
        Lex.line = 1
        Lex.col = 1
        Lex.count = 0
        
        // Create token storage
        Lex.tok_types = XArray.XCreate(512)
        Lex.tok_vals = XArray.XCreate(512)
        Lex.tok_lines = XArray.XCreate(512)
        Lex.tok_cols = XArray.XCreate(512)
        
        // Allocate temp buffer
        Lex.buf = Allocate(Lex.buf_size)
    }
}

Function.Lex_Free {
    Body: {
        // Free string/identifier values FIRST (while tok_types is still valid)
        IfCondition And(NotEqual(Lex.tok_vals, 0), NotEqual(Lex.tok_types, 0)) ThenBlock: {
            i = 0
            n = XArray.XSize(Lex.tok_vals)
            WhileLoop LessThan(i, n) {
                v = XArray.XGet(Lex.tok_vals, i)
                t = XArray.XGet(Lex.tok_types, i)
                // Only free if it's a string or identifier (allocated)
                IfCondition Or(EqualTo(t, Token.STRING), EqualTo(t, Token.IDENTIFIER)) ThenBlock: {
                    IfCondition NotEqual(v, 0) ThenBlock: {
                        Deallocate(v, 0)
                    }
                }
                i = Add(i, 1)
            }
        }
        
        // Now destroy the arrays
        IfCondition NotEqual(Lex.tok_types, 0) ThenBlock: {
            XArray.XDestroy(Lex.tok_types)
            Lex.tok_types = 0
        }
        IfCondition NotEqual(Lex.tok_vals, 0) ThenBlock: {
            XArray.XDestroy(Lex.tok_vals)
            Lex.tok_vals = 0
        }
        IfCondition NotEqual(Lex.tok_lines, 0) ThenBlock: {
            XArray.XDestroy(Lex.tok_lines)
            Lex.tok_lines = 0
        }
        IfCondition NotEqual(Lex.tok_cols, 0) ThenBlock: {
            XArray.XDestroy(Lex.tok_cols)
            Lex.tok_cols = 0
        }
        IfCondition NotEqual(Lex.buf, 0) ThenBlock: {
            Deallocate(Lex.buf, Lex.buf_size)
            Lex.buf = 0
        }
    }
}

// =============================================================================
// CHARACTER HELPERS
// =============================================================================
Function.Lex_Char {
    Output: Integer
    Body: {
        IfCondition GreaterEqual(Lex.pos, Lex.len) ThenBlock: {
            ReturnValue(0)
        }
        ch = GetByte(Lex.src, Lex.pos)
        ReturnValue(ch)
    }
}

Function.Lex_Peek {
    Input: offset: Integer
    Output: Integer
    Body: {
        p = Add(Lex.pos, offset)
        IfCondition GreaterEqual(p, Lex.len) ThenBlock: {
            ReturnValue(0)
        }
        ch = GetByte(Lex.src, p)
        ReturnValue(ch)
    }
}

Function.Lex_Advance {
    Body: {
        IfCondition LessThan(Lex.pos, Lex.len) ThenBlock: {
            ch = GetByte(Lex.src, Lex.pos)
            IfCondition EqualTo(ch, 10) ThenBlock: {
                // Newline (LF)
                Lex.line = Add(Lex.line, 1)
                Lex.col = 1
            } ElseBlock: {
                Lex.col = Add(Lex.col, 1)
            }
            Lex.pos = Add(Lex.pos, 1)
        }
    }
}

Function.Lex_IsDigit {
    Input: ch: Integer
    Output: Integer
    Body: {
        IfCondition And(GreaterEqual(ch, 48), LessEqual(ch, 57)) ThenBlock: {
            ReturnValue(1)
        }
        ReturnValue(0)
    }
}

Function.Lex_IsAlpha {
    Input: ch: Integer
    Output: Integer
    Body: {
        // A-Z
        IfCondition And(GreaterEqual(ch, 65), LessEqual(ch, 90)) ThenBlock: {
            ReturnValue(1)
        }
        // a-z
        IfCondition And(GreaterEqual(ch, 97), LessEqual(ch, 122)) ThenBlock: {
            ReturnValue(1)
        }
        // underscore
        IfCondition EqualTo(ch, 95) ThenBlock: {
            ReturnValue(1)
        }
        ReturnValue(0)
    }
}

Function.Lex_IsAlnum {
    Input: ch: Integer
    Output: Integer
    Body: {
        a = Lex_IsAlpha(ch)
        IfCondition EqualTo(a, 1) ThenBlock: {
            ReturnValue(1)
        }
        d = Lex_IsDigit(ch)
        ReturnValue(d)
    }
}

// =============================================================================
// TOKEN EMISSION
// =============================================================================
Function.Lex_Emit {
    Input: tok_type: Integer
    Input: tok_val: Address
    Body: {
        XArray.XPush(Lex.tok_types, tok_type)
        XArray.XPush(Lex.tok_vals, tok_val)
        XArray.XPush(Lex.tok_lines, Lex.line)
        XArray.XPush(Lex.tok_cols, Lex.col)
        Lex.count = Add(Lex.count, 1)
    }
}

Function.Lex_EmitSimple {
    Input: tok_type: Integer
    Body: {
        Lex_Emit(tok_type, 0)
    }
}

// =============================================================================
// STRING READING
// =============================================================================
Function.Lex_ReadString {
    Output: Address
    Body: {
        quote = Lex_Char()
        Lex_Advance()
        
        buf_pos = 0
        done = 0
        
        WhileLoop EqualTo(done, 0) {
            ch = Lex_Char()
            
            IfCondition EqualTo(ch, 0) ThenBlock: {
                done = 1
            } ElseBlock: {
                IfCondition EqualTo(ch, quote) ThenBlock: {
                    done = 1
                } ElseBlock: {
                    // Handle escapes
                    IfCondition EqualTo(ch, 92) ThenBlock: {
                        // Backslash
                        Lex_Advance()
                        esc = Lex_Char()
                        IfCondition EqualTo(esc, 110) ThenBlock: {
                            SetByte(Lex.buf, buf_pos, 10)  // \n
                        } ElseBlock: {
                            IfCondition EqualTo(esc, 116) ThenBlock: {
                                SetByte(Lex.buf, buf_pos, 9)  // \t
                            } ElseBlock: {
                                IfCondition EqualTo(esc, 114) ThenBlock: {
                                    SetByte(Lex.buf, buf_pos, 13)  // \r
                                } ElseBlock: {
                                    SetByte(Lex.buf, buf_pos, esc)
                                }
                            }
                        }
                        buf_pos = Add(buf_pos, 1)
                        Lex_Advance()
                    } ElseBlock: {
                        SetByte(Lex.buf, buf_pos, ch)
                        buf_pos = Add(buf_pos, 1)
                        Lex_Advance()
                    }
                }
            }
        }
        
        // Skip closing quote
        Lex_Advance()
        
        // Allocate result
        result_size = Add(buf_pos, 1)
        result = Allocate(result_size)
        i = 0
        WhileLoop LessThan(i, buf_pos) {
            c = GetByte(Lex.buf, i)
            SetByte(result, i, c)
            i = Add(i, 1)
        }
        SetByte(result, buf_pos, 0)
        
        ReturnValue(result)
    }
}

// =============================================================================
// NUMBER READING
// =============================================================================
Function.Lex_ReadNumber {
    Output: Integer
    Body: {
        val = 0
        
        WhileLoop EqualTo(1, 1) {
            ch = Lex_Char()
            is_dig = Lex_IsDigit(ch)
            IfCondition EqualTo(is_dig, 0) ThenBlock: {
                BreakLoop
            }
            digit = Subtract(ch, 48)
            val = Multiply(val, 10)
            val = Add(val, digit)
            Lex_Advance()
        }
        
        ReturnValue(val)
    }
}

// =============================================================================
// IDENTIFIER READING
// =============================================================================
Function.Lex_ReadIdent {
    Output: Address
    Body: {
        buf_pos = 0
        
        WhileLoop EqualTo(1, 1) {
            ch = Lex_Char()
            is_an = Lex_IsAlnum(ch)
            IfCondition EqualTo(is_an, 0) ThenBlock: {
                BreakLoop
            }
            SetByte(Lex.buf, buf_pos, ch)
            buf_pos = Add(buf_pos, 1)
            Lex_Advance()
        }
        
        // Allocate result
        result_size = Add(buf_pos, 1)
        result = Allocate(result_size)
        i = 0
        WhileLoop LessThan(i, buf_pos) {
            c = GetByte(Lex.buf, i)
            SetByte(result, i, c)
            i = Add(i, 1)
        }
        SetByte(result, buf_pos, 0)
        
        ReturnValue(result)
    }
}

// =============================================================================
// KEYWORD MATCHING
// =============================================================================
Function.Lex_MatchKW {
    Input: word: Address
    Output: Integer
    Body: {
        // Check each keyword - returns token type or IDENTIFIER
        cmp = StringCompare(word, "def")
        IfCondition EqualTo(cmp, 0) ThenBlock: { ReturnValue(Token.DEF) }
        
        cmp = StringCompare(word, "end")
        IfCondition EqualTo(cmp, 0) ThenBlock: { ReturnValue(Token.END) }
        
        cmp = StringCompare(word, "if")
        IfCondition EqualTo(cmp, 0) ThenBlock: { ReturnValue(Token.IF) }
        
        cmp = StringCompare(word, "elif")
        IfCondition EqualTo(cmp, 0) ThenBlock: { ReturnValue(Token.ELIF) }
        
        cmp = StringCompare(word, "else")
        IfCondition EqualTo(cmp, 0) ThenBlock: { ReturnValue(Token.ELSE) }
        
        cmp = StringCompare(word, "while")
        IfCondition EqualTo(cmp, 0) ThenBlock: { ReturnValue(Token.WHILE) }
        
        cmp = StringCompare(word, "for")
        IfCondition EqualTo(cmp, 0) ThenBlock: { ReturnValue(Token.FOR) }
        
        cmp = StringCompare(word, "in")
        IfCondition EqualTo(cmp, 0) ThenBlock: { ReturnValue(Token.IN) }
        
        cmp = StringCompare(word, "return")
        IfCondition EqualTo(cmp, 0) ThenBlock: { ReturnValue(Token.RETURN) }
        
        cmp = StringCompare(word, "pass")
        IfCondition EqualTo(cmp, 0) ThenBlock: { ReturnValue(Token.PASS) }
        
        cmp = StringCompare(word, "break")
        IfCondition EqualTo(cmp, 0) ThenBlock: { ReturnValue(Token.BREAK) }
        
        cmp = StringCompare(word, "continue")
        IfCondition EqualTo(cmp, 0) ThenBlock: { ReturnValue(Token.CONTINUE) }
        
        cmp = StringCompare(word, "True")
        IfCondition EqualTo(cmp, 0) ThenBlock: { ReturnValue(Token.TRUE) }
        
        cmp = StringCompare(word, "False")
        IfCondition EqualTo(cmp, 0) ThenBlock: { ReturnValue(Token.FALSE) }
        
        cmp = StringCompare(word, "None")
        IfCondition EqualTo(cmp, 0) ThenBlock: { ReturnValue(Token.NONE) }
        
        cmp = StringCompare(word, "and")
        IfCondition EqualTo(cmp, 0) ThenBlock: { ReturnValue(Token.AND) }
        
        cmp = StringCompare(word, "or")
        IfCondition EqualTo(cmp, 0) ThenBlock: { ReturnValue(Token.OR) }
        
        cmp = StringCompare(word, "not")
        IfCondition EqualTo(cmp, 0) ThenBlock: { ReturnValue(Token.NOT) }
        
        cmp = StringCompare(word, "is")
        IfCondition EqualTo(cmp, 0) ThenBlock: { ReturnValue(Token.IS) }

        cmp = StringCompare(word, "try")
        IfCondition EqualTo(cmp, 0) ThenBlock: { ReturnValue(Token.TRY) }

        cmp = StringCompare(word, "except")
        IfCondition EqualTo(cmp, 0) ThenBlock: { ReturnValue(Token.EXCEPT) }

        cmp = StringCompare(word, "finally")
        IfCondition EqualTo(cmp, 0) ThenBlock: { ReturnValue(Token.FINALLY) }

        cmp = StringCompare(word, "finally")
        IfCondition EqualTo(cmp, 0) ThenBlock: { ReturnValue(Token.FINALLY) }
        
        // === NEW: Import keywords ===
        cmp = StringCompare(word, "import")
        IfCondition EqualTo(cmp, 0) ThenBlock: { ReturnValue(Token.IMPORT) }
        
        cmp = StringCompare(word, "from")
        IfCondition EqualTo(cmp, 0) ThenBlock: { ReturnValue(Token.FROM) }
        
        // Not a keyword
        ReturnValue(Token.IDENTIFIER)
    }
}

// =============================================================================
// MAIN TOKENIZE FUNCTION
// =============================================================================
Function.Lex_Tokenize {
    Output: Integer
    Body: {
        WhileLoop EqualTo(1, 1) {
            ch = Lex_Char()
            
            // End of source
            IfCondition EqualTo(ch, 0) ThenBlock: {
                BreakLoop
            }
            
            // Skip whitespace (not newlines)
            IfCondition Or(EqualTo(ch, 32), EqualTo(ch, 9)) ThenBlock: {
                Lex_Advance()
                ContinueLoop
            }
            
            // Newline
            IfCondition EqualTo(ch, 10) ThenBlock: {
                Lex_EmitSimple(Token.NEWLINE)
                Lex_Advance()
                ContinueLoop
            }
            
            // Carriage return (skip)
            IfCondition EqualTo(ch, 13) ThenBlock: {
                Lex_Advance()
                ContinueLoop
            }
            
            // Comment
            IfCondition EqualTo(ch, 35) ThenBlock: {
                // Skip to end of line
                WhileLoop EqualTo(1, 1) {
                    c = Lex_Char()
                    IfCondition Or(EqualTo(c, 0), EqualTo(c, 10)) ThenBlock: {
                        BreakLoop
                    }
                    Lex_Advance()
                }
                ContinueLoop
            }
            
            // String literals
            IfCondition Or(EqualTo(ch, 34), EqualTo(ch, 39)) ThenBlock: {
                str = Lex_ReadString()
                Lex_Emit(Token.STRING, str)
                ContinueLoop
            }
            
            // Numbers
            is_digit = Lex_IsDigit(ch)
            IfCondition EqualTo(is_digit, 1) ThenBlock: {
                num = Lex_ReadNumber()
                Lex_Emit(Token.NUMBER, num)
                ContinueLoop
            }
            
            // Identifiers and keywords
            is_alpha = Lex_IsAlpha(ch)
            IfCondition EqualTo(is_alpha, 1) ThenBlock: {
                ident = Lex_ReadIdent()
                kw = Lex_MatchKW(ident)
                IfCondition EqualTo(kw, Token.IDENTIFIER) ThenBlock: {
                    Lex_Emit(Token.IDENTIFIER, ident)
                } ElseBlock: {
                    Lex_EmitSimple(kw)
                    Deallocate(ident, 0)
                }
                ContinueLoop
            }

            // PEEK AHEAD - Do this BEFORE checking multi-char operators!
            next_ch = Lex_Peek(1)
            third_ch = Lex_Peek(2)

            // THREE-CHARACTER OPERATORS (check first!)
            matched_three = 0
            
            // **=
            IfCondition And(EqualTo(ch, 42), And(EqualTo(next_ch, 42), EqualTo(third_ch, 61))) ThenBlock: {
                Lex_EmitSimple(Token.POWER_EQ)
                Lex_Advance()
                Lex_Advance()
                Lex_Advance()
                matched_three = 1
            }
            // //=
            IfCondition And(EqualTo(matched_three, 0), And(EqualTo(ch, 47), And(EqualTo(next_ch, 47), EqualTo(third_ch, 61)))) ThenBlock: {
                Lex_EmitSimple(Token.FLOOR_DIV_EQ)
                Lex_Advance()
                Lex_Advance()
                Lex_Advance()
                matched_three = 1
            }
            
            IfCondition EqualTo(matched_three, 1) ThenBlock: {
                ContinueLoop
            }
            
            // Two-character operators
            matched_two = 0
            
            // ==
            IfCondition And(EqualTo(ch, 61), EqualTo(next_ch, 61)) ThenBlock: {
                Lex_EmitSimple(Token.EQ)
                Lex_Advance()
                Lex_Advance()
                matched_two = 1
            }
            // !=
            IfCondition And(EqualTo(matched_two, 0), And(EqualTo(ch, 33), EqualTo(next_ch, 61))) ThenBlock: {
                Lex_EmitSimple(Token.NE)
                Lex_Advance()
                Lex_Advance()
                matched_two = 1
            }
            // <=
            IfCondition And(EqualTo(matched_two, 0), And(EqualTo(ch, 60), EqualTo(next_ch, 61))) ThenBlock: {
                Lex_EmitSimple(Token.LE)
                Lex_Advance()
                Lex_Advance()
                matched_two = 1
            }
            // >=
            IfCondition And(EqualTo(matched_two, 0), And(EqualTo(ch, 62), EqualTo(next_ch, 61))) ThenBlock: {
                Lex_EmitSimple(Token.GE)
                Lex_Advance()
                Lex_Advance()
                matched_two = 1
            }
            // **
            IfCondition And(EqualTo(matched_two, 0), And(EqualTo(ch, 42), EqualTo(next_ch, 42))) ThenBlock: {
                Lex_EmitSimple(Token.POWER)
                Lex_Advance()
                Lex_Advance()
                matched_two = 1
            }
            // //
            IfCondition And(EqualTo(matched_two, 0), And(EqualTo(ch, 47), EqualTo(next_ch, 47))) ThenBlock: {
                Lex_EmitSimple(Token.FLOOR_DIV)
                Lex_Advance()
                Lex_Advance()
                matched_two = 1
            }
            // +=
            IfCondition And(EqualTo(matched_two, 0), And(EqualTo(ch, 43), EqualTo(next_ch, 61))) ThenBlock: {
                Lex_EmitSimple(Token.PLUS_EQ)
                Lex_Advance()
                Lex_Advance()
                matched_two = 1
            }
            // -=
            IfCondition And(EqualTo(matched_two, 0), And(EqualTo(ch, 45), EqualTo(next_ch, 61))) ThenBlock: {
                Lex_EmitSimple(Token.MINUS_EQ)
                Lex_Advance()
                Lex_Advance()
                matched_two = 1
            }
            // *=
            IfCondition And(EqualTo(matched_two, 0), And(EqualTo(ch, 42), EqualTo(next_ch, 61))) ThenBlock: {
                Lex_EmitSimple(Token.STAR_EQ)
                Lex_Advance()
                Lex_Advance()
                matched_two = 1
            }
            // /=
            IfCondition And(EqualTo(matched_two, 0), And(EqualTo(ch, 47), EqualTo(next_ch, 61))) ThenBlock: {
                Lex_EmitSimple(Token.SLASH_EQ)
                Lex_Advance()
                Lex_Advance()
                matched_two = 1
            }
            // %= 
            IfCondition And(EqualTo(matched_two, 0), And(EqualTo(ch, 37), EqualTo(next_ch, 61))) ThenBlock: {
                Lex_EmitSimple(Token.MOD_EQ)
                Lex_Advance()
                Lex_Advance()
                matched_two = 1
            }
            // ->
            IfCondition And(EqualTo(matched_two, 0), And(EqualTo(ch, 45), EqualTo(next_ch, 62))) ThenBlock: {
                Lex_EmitSimple(Token.ARROW)
                Lex_Advance()
                Lex_Advance()
                matched_two = 1
            }
            
            IfCondition EqualTo(matched_two, 1) ThenBlock: {
                ContinueLoop
            }
            
            // Single-character operators
            IfCondition EqualTo(ch, 43) ThenBlock: { Lex_EmitSimple(Token.PLUS) Lex_Advance() ContinueLoop }
            IfCondition EqualTo(ch, 45) ThenBlock: { Lex_EmitSimple(Token.MINUS) Lex_Advance() ContinueLoop }
            IfCondition EqualTo(ch, 42) ThenBlock: { Lex_EmitSimple(Token.STAR) Lex_Advance() ContinueLoop }
            IfCondition EqualTo(ch, 47) ThenBlock: { Lex_EmitSimple(Token.SLASH) Lex_Advance() ContinueLoop }
            IfCondition EqualTo(ch, 37) ThenBlock: { Lex_EmitSimple(Token.PERCENT) Lex_Advance() ContinueLoop }
            IfCondition EqualTo(ch, 61) ThenBlock: { Lex_EmitSimple(Token.ASSIGN) Lex_Advance() ContinueLoop }
            IfCondition EqualTo(ch, 60) ThenBlock: { Lex_EmitSimple(Token.LT) Lex_Advance() ContinueLoop }
            IfCondition EqualTo(ch, 62) ThenBlock: { Lex_EmitSimple(Token.GT) Lex_Advance() ContinueLoop }
            IfCondition EqualTo(ch, 40) ThenBlock: { Lex_EmitSimple(Token.LPAREN) Lex_Advance() ContinueLoop }
            IfCondition EqualTo(ch, 41) ThenBlock: { Lex_EmitSimple(Token.RPAREN) Lex_Advance() ContinueLoop }
            IfCondition EqualTo(ch, 91) ThenBlock: { Lex_EmitSimple(Token.LBRACKET) Lex_Advance() ContinueLoop }
            IfCondition EqualTo(ch, 93) ThenBlock: { Lex_EmitSimple(Token.RBRACKET) Lex_Advance() ContinueLoop }
            IfCondition EqualTo(ch, 123) ThenBlock: { Lex_EmitSimple(Token.LBRACE) Lex_Advance() ContinueLoop }
            IfCondition EqualTo(ch, 125) ThenBlock: { Lex_EmitSimple(Token.RBRACE) Lex_Advance() ContinueLoop }
            IfCondition EqualTo(ch, 44) ThenBlock: { Lex_EmitSimple(Token.COMMA) Lex_Advance() ContinueLoop }
            IfCondition EqualTo(ch, 58) ThenBlock: { Lex_EmitSimple(Token.COLON) Lex_Advance() ContinueLoop }
            IfCondition EqualTo(ch, 59) ThenBlock: { Lex_EmitSimple(Token.SEMICOLON) Lex_Advance() ContinueLoop }
            IfCondition EqualTo(ch, 46) ThenBlock: { Lex_EmitSimple(Token.DOT) Lex_Advance() ContinueLoop }
            
            // Unknown character - skip
            Lex_Advance()
        }
        
        // Add EOF
        Lex_EmitSimple(Token.EOF)
        
        ReturnValue(Lex.count)
    }
}

// =============================================================================
// TOKEN ACCESS
// =============================================================================
Function.Lex_GetType {
    Input: idx: Integer
    Output: Integer
    Body: {
        IfCondition GreaterEqual(idx, Lex.count) ThenBlock: {
            ReturnValue(Token.EOF)
        }
        t = XArray.XGet(Lex.tok_types, idx)
        ReturnValue(t)
    }
}

Function.Lex_GetVal {
    Input: idx: Integer
    Output: Address
    Body: {
        IfCondition GreaterEqual(idx, Lex.count) ThenBlock: {
            ReturnValue(0)
        }
        v = XArray.XGet(Lex.tok_vals, idx)
        ReturnValue(v)
    }
}

Function.Lex_GetLine {
    Input: idx: Integer
    Output: Integer
    Body: {
        IfCondition GreaterEqual(idx, Lex.count) ThenBlock: {
            ReturnValue(0)
        }
        l = XArray.XGet(Lex.tok_lines, idx)
        ReturnValue(l)
    }
}

Function.Lex_GetCol {
    Input: idx: Integer
    Output: Integer
    Body: {
        IfCondition GreaterEqual(idx, Lex.count) ThenBlock: {
            ReturnValue(0)
        }
        c = XArray.XGet(Lex.tok_cols, idx)
        ReturnValue(c)
    }
}

Function.Lex_Count {
    Output: Integer
    Body: {
        ReturnValue(Lex.count)
    }
}
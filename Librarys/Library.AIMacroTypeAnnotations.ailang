// Library.AIMacroTypeAnnotations.ailang
// Type annotation parsing and lookup for AIMacro
// Handles Python-style type hints: def func(a: int, b: str) -> int:
//
// Dependencies: XArrays, XSHash
// Usage: LibraryImport.AIMacroTypeAnnotations

LibraryImport.XArrays


// =============================================================================
// TYPE CONSTANTS
// =============================================================================
FixedPool.TypeID {
    "UNKNOWN": Initialize=0
    "INT": Initialize=1
    "STR": Initialize=2
    "LIST": Initialize=3
    "DICT": Initialize=4
    "BOOL": Initialize=5
    "FLOAT": Initialize=6
    "ADDR": Initialize=7
}

// =============================================================================
// STATE
// =============================================================================
FixedPool.TypeAnno {
    "param_types": Initialize=0
    "func_returns": Initialize=0
    "current_func": Initialize=0
    "initialized": Initialize=0
}

// =============================================================================
// INITIALIZATION
// =============================================================================
Function.TypeAnno_Init {
    Body: {
        IfCondition EqualTo(TypeAnno.initialized, 1) ThenBlock: {
            ReturnValue(0)
        }
        
        // Hash table: "funcname.paramname" -> TypeID
        TypeAnno.param_types = XSHash.XCreate(256)
        
        // Hash table: "funcname" -> return TypeID
        TypeAnno.func_returns = XSHash.XCreate(64)
        
        TypeAnno.initialized = 1
        ReturnValue(1)
    }
}

// =============================================================================
// PARSE TYPE STRING TO TypeID
// =============================================================================
Function.TypeAnno_ParseType {
    Input: type_str: Address
    Output: Integer
    Body: {
        IfCondition EqualTo(type_str, 0) ThenBlock: {
            ReturnValue(TypeID.UNKNOWN)
        }
        
        cmp = StringCompare(type_str, "int")
        IfCondition EqualTo(cmp, 0) ThenBlock: {
            ReturnValue(TypeID.INT)
        }
        
        cmp = StringCompare(type_str, "str")
        IfCondition EqualTo(cmp, 0) ThenBlock: {
            ReturnValue(TypeID.STR)
        }
        
        cmp = StringCompare(type_str, "list")
        IfCondition EqualTo(cmp, 0) ThenBlock: {
            ReturnValue(TypeID.LIST)
        }
        
        cmp = StringCompare(type_str, "dict")
        IfCondition EqualTo(cmp, 0) ThenBlock: {
            ReturnValue(TypeID.DICT)
        }
        
        cmp = StringCompare(type_str, "bool")
        IfCondition EqualTo(cmp, 0) ThenBlock: {
            ReturnValue(TypeID.BOOL)
        }
        
        cmp = StringCompare(type_str, "float")
        IfCondition EqualTo(cmp, 0) ThenBlock: {
            ReturnValue(TypeID.FLOAT)
        }
        
        // Address/pointer type
        cmp = StringCompare(type_str, "Address")
        IfCondition EqualTo(cmp, 0) ThenBlock: {
            ReturnValue(TypeID.ADDR)
        }
        
        ReturnValue(TypeID.UNKNOWN)
    }
}

// =============================================================================
// REGISTER PARAMETER TYPE
// Called when parsing function definition with type annotation
// =============================================================================
Function.TypeAnno_RegisterParam {
    Input: func_name: Address
    Input: param_name: Address
    Input: type_id: Integer
    Body: {
        TypeAnno_Init()
        
        // Build key: "funcname.paramname"
        key = StringConcat(func_name, ".")
        key = StringConcat(key, param_name)
        
        XSHash.XInsert(TypeAnno.param_types, key, type_id)
    }
}

// =============================================================================
// REGISTER FUNCTION RETURN TYPE
// =============================================================================
Function.TypeAnno_RegisterReturn {
    Input: func_name: Address
    Input: type_id: Integer
    Body: {
        TypeAnno_Init()
        XSHash.XInsert(TypeAnno.func_returns, func_name, type_id)
    }
}

// =============================================================================
// SET CURRENT FUNCTION CONTEXT
// Called when entering a function during codegen
// =============================================================================
Function.TypeAnno_EnterFunction {
    Input: func_name: Address
    Body: {
        TypeAnno.current_func = func_name
    }
}

Function.TypeAnno_ExitFunction {
    Body: {
        TypeAnno.current_func = 0
    }
}

// =============================================================================
// LOOKUP PARAMETER TYPE
// Returns TypeID for a parameter in the current function
// =============================================================================
Function.TypeAnno_GetParamType {
    Input: param_name: Address
    Output: Integer
    Body: {
        TypeAnno_Init()
        
        IfCondition EqualTo(TypeAnno.current_func, 0) ThenBlock: {
            ReturnValue(TypeID.UNKNOWN)
        }
        
        // Build key: "funcname.paramname"
        key = StringConcat(TypeAnno.current_func, ".")
        key = StringConcat(key, param_name)
        
        result = XSHash.XLookup(TypeAnno.param_types, key)
        IfCondition EqualTo(result, 0) ThenBlock: {
            ReturnValue(TypeID.UNKNOWN)
        }
        
        ReturnValue(result)
    }
}

// =============================================================================
// LOOKUP FUNCTION RETURN TYPE
// =============================================================================
Function.TypeAnno_GetReturnType {
    Input: func_name: Address
    Output: Integer
    Body: {
        TypeAnno_Init()
        
        result = XSHash.XLookup(TypeAnno.func_returns, func_name)
        IfCondition EqualTo(result, 0) ThenBlock: {
            ReturnValue(TypeID.UNKNOWN)
        }
        
        ReturnValue(result)
    }
}

// =============================================================================
// CHECK IF IDENTIFIER IS A STRING TYPE
// Checks both local string vars AND typed parameters
// =============================================================================
Function.TypeAnno_IsString {
    Input: var_name: Address
    Output: Integer
    Body: {
        // First check if it's a known string variable (from Gen_IsStringVar)
        // This handles local assignments like: s = "hello"
        
        // Then check if it's a typed parameter
        param_type = TypeAnno_GetParamType(var_name)
        IfCondition EqualTo(param_type, TypeID.STR) ThenBlock: {
            ReturnValue(1)
        }
        
        ReturnValue(0)
    }
}

// =============================================================================
// ERROR REPORTING FOR MISSING ANNOTATIONS
// =============================================================================
Function.TypeAnno_RequireAnnotation {
    Input: func_name: Address
    Input: param_name: Address
    Input: line: Integer
    Body: {
        PrintMessage("Error: Function '")
        PrintString(func_name)
        PrintMessage("' parameter '")
        PrintString(param_name)
        PrintMessage("' missing type annotation at line ")
        PrintNumber(line)
        PrintMessage("\n")
        PrintMessage("AIMacro requires explicit types for all function parameters.\n")
        PrintMessage("Example: def ")
        PrintString(func_name)
        PrintMessage("(")
        PrintString(param_name)
        PrintMessage(": int, ...)\n")
    }
}

// =============================================================================
// LIBRARY INIT
// =============================================================================
SubRoutine.InitTypeAnnotations {
    TypeAnno_Init()
    PrintMessage("AIMacroTypeAnnotations Library Loaded\n")
}

RunTask(InitTypeAnnotations)
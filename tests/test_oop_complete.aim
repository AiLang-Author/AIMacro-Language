# test_oop_complete.aim
# Comprehensive OOP test harness for AIMacro
# Tests all OOP features systematically

# ============================================================================
# TEST INFRASTRUCTURE
# ============================================================================
tests_passed = 0
tests_failed = 0

def assert_eq(actual: int, expected: int, name: str) -> int:
    if actual == expected:
        print("  PASS:", name)
        return 1
    else:
        print("  FAIL:", name, "| Expected:", expected, "Got:", actual)
        return 0
    end
end

# ============================================================================
# SECTION 1: Basic Class Definition and Instantiation
# ============================================================================

def test_basic_instantiation() -> int:
    print("")
    print("=== SECTION 1: Basic Class & Instantiation ===")
    p = 0
    
    s = Simple()
    v = s.value
    p = p + assert_eq(v, 42, "basic instantiation")
    
    print("Basic instantiation:", p, "/ 1")
    return p
end

class Simple:
    def __init__(self):
        self.value = 42
    end
end

# ============================================================================
# SECTION 2: Constructor with Parameters
# ============================================================================

def test_constructor_params() -> int:
    print("")
    print("=== SECTION 2: Constructor Parameters ===")
    p = 0
    
    pt = Point(10, 20)
    p = p + assert_eq(pt.x, 10, "constructor param x")
    p = p + assert_eq(pt.y, 20, "constructor param y")
    
    print("Constructor params:", p, "/ 2")
    return p
end

class Point:
    def __init__(self, x: int, y: int):
        self.x = x
        self.y = y
    end
end

# ============================================================================
# SECTION 3: Methods that Modify State
# ============================================================================

def test_state_modification() -> int:
    print("")
    print("=== SECTION 3: State Modification ===")
    p = 0
    
    c = Counter()
    initial = c.get()
    p = p + assert_eq(initial, 0, "initial count")
    
    c.increment()
    after_inc = c.get()
    p = p + assert_eq(after_inc, 1, "after increment")
    
    c.increment()
    c.increment()
    after_three = c.get()
    p = p + assert_eq(after_three, 3, "multiple increments")
    
    c.decrement()
    after_dec = c.get()
    p = p + assert_eq(after_dec, 2, "decrement")
    
    c.add(10)
    after_add = c.get()
    p = p + assert_eq(after_add, 12, "add with param")
    
    print("State modification:", p, "/ 5")
    return p
end

class Counter:
    def __init__(self):
        self.count = 0
    end
    
    def increment(self):
        self.count = self.count + 1
    end
    
    def decrement(self):
        self.count = self.count - 1
    end
    
    def add(self, n: int):
        self.count = self.count + n
    end
    
    def get(self) -> int:
        return self.count
    end
end

# ============================================================================
# SECTION 4: Multiple Instances
# ============================================================================

def test_multiple_instances() -> int:
    print("")
    print("=== SECTION 4: Multiple Instances ===")
    p = 0
    
    c1 = Counter()
    c2 = Counter()
    
    c1.add(5)
    c2.add(10)
    
    v1 = c1.get()
    v2 = c2.get()
    
    p = p + assert_eq(v1, 5, "instance 1 independent")
    p = p + assert_eq(v2, 10, "instance 2 independent")
    
    print("Multiple instances:", p, "/ 2")
    return p
end

# ============================================================================
# SECTION 5: Object as Parameter
# ============================================================================

def get_point_sum(pt: Point) -> int:
    return pt.x + pt.y
end

def test_object_as_param() -> int:
    print("")
    print("=== SECTION 5: Object as Parameter ===")
    p = 0
    
    p1 = Point(3, 7)
    total = get_point_sum(p1)
    p = p + assert_eq(total, 10, "object as param")
    
    print("Object as param:", p, "/ 1")
    return p
end

# ============================================================================
# SECTION 6: Object as Return Value
# ============================================================================

def make_point(x: int, y: int) -> Point:
    return Point(x, y)
end

def test_object_return() -> int:
    print("")
    print("=== SECTION 6: Object as Return Value ===")
    p = 0
    
    p2 = make_point(100, 200)
    p = p + assert_eq(p2.x, 100, "returned object x")
    p = p + assert_eq(p2.y, 200, "returned object y")
    
    print("Object return:", p, "/ 2")
    return p
end

# ============================================================================
# SECTION 7: Chained Attribute Access
# ============================================================================

class Box:
    def __init__(self, pt: Point):
        self.corner = pt
    end
    
    def get_corner_x(self) -> int:
        return self.corner.x
    end
end

def test_chained_attrs() -> int:
    print("")
    print("=== SECTION 7: Chained Attributes ===")
    p = 0
    
    inner_pt = Point(50, 60)
    box = Box(inner_pt)
    
    corner_x = box.get_corner_x()
    p = p + assert_eq(corner_x, 50, "chained via method")
    
    direct_x = box.corner.x
    p = p + assert_eq(direct_x, 50, "direct chained access")
    
    print("Chained attrs:", p, "/ 2")
    return p
end

# ============================================================================
# SECTION 8: Method Returning Computed Value
# ============================================================================

class Rectangle:
    def __init__(self, w: int, h: int):
        self.width = w
        self.height = h
    end
    
    def area(self) -> int:
        return self.width * self.height
    end
    
    def perimeter(self) -> int:
        return 2 * (self.width + self.height)
    end
end

def test_computed_returns() -> int:
    print("")
    print("=== SECTION 8: Computed Returns ===")
    p = 0
    
    rect = Rectangle(5, 3)
    a = rect.area()
    p = p + assert_eq(a, 15, "area computation")
    
    perim = rect.perimeter()
    p = p + assert_eq(perim, 16, "perimeter computation")
    
    print("Computed returns:", p, "/ 2")
    return p
end

# ============================================================================
# SECTION 9: Object Storing Object
# ============================================================================

class Pair:
    def __init__(self, first: Point, second: Point):
        self.first = first
        self.second = second
    end
end

def test_object_in_object() -> int:
    print("")
    print("=== SECTION 9: Object in Object ===")
    p = 0
    
    p_a = Point(1, 2)
    p_b = Point(3, 4)
    pair = Pair(p_a, p_b)
    
    p = p + assert_eq(pair.first.x, 1, "nested object access 1")
    p = p + assert_eq(pair.second.y, 4, "nested object access 2")
    
    print("Object in object:", p, "/ 2")
    return p
end

# ============================================================================
# SECTION 10: Attribute Modification After Construction
# ============================================================================

class Mutable:
    def __init__(self, val: int):
        self.data = val
    end
    
    def set_data(self, new_val: int):
        self.data = new_val
    end
    
    def get_data(self) -> int:
        return self.data
    end
end

def test_post_construction() -> int:
    print("")
    print("=== SECTION 10: Post-Construction Modification ===")
    p = 0
    
    m = Mutable(100)
    before = m.get_data()
    p = p + assert_eq(before, 100, "initial value")
    
    m.set_data(999)
    after = m.get_data()
    p = p + assert_eq(after, 999, "modified value")
    
    print("Post-construction:", p, "/ 2")
    return p
end

# ============================================================================
# MAIN - RUN ALL TESTS
# ============================================================================

def main():
    print("")
    print("############################################")
    print("#     AIMACRO OOP COMPREHENSIVE TEST      #")
    print("############################################")
    
    total = 0
    passed = 0
    
    passed = passed + test_basic_instantiation()
    total = total + 1
    
    passed = passed + test_constructor_params()
    total = total + 2
    
    passed = passed + test_state_modification()
    total = total + 5
    
    passed = passed + test_multiple_instances()
    total = total + 2
    
    passed = passed + test_object_as_param()
    total = total + 1
    
    passed = passed + test_object_return()
    total = total + 2
    
    passed = passed + test_chained_attrs()
    total = total + 2
    
    passed = passed + test_computed_returns()
    total = total + 2
    
    passed = passed + test_object_in_object()
    total = total + 2
    
    passed = passed + test_post_construction()
    total = total + 2
    
    print("")
    print("############################################")
    print("#            FINAL RESULTS                #")
    print("############################################")
    print("")
    print("Total Tests:", total)
    print("Passed:", passed)
    failed = total - passed
    print("Failed:", failed)
    print("")
    
    if passed == total:
        print("*** ALL TESTS PASSED ***")
    else:
        print("*** SOME TESTS FAILED ***")
    end
end